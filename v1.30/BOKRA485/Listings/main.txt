; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\main.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\main.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\main.crf main.c]
                          THUMB

                          AREA ||i.App_Init||, CODE, READONLY, ALIGN=2

                  App_Init PROC
;;;391    // ------------------------------------------------------------------------------------------------------
;;;392    void App_Init(void)
000000  b510              PUSH     {r4,lr}
;;;393    {
;;;394    	memset(&App.Logic[0], 0x00, sizeof(App.Logic[0]) * CFG_LOGIC_CHANNEL_COUNT);	// RESET to zero all channel variables.
000002  2163              MOVS     r1,#0x63
000004  0109              LSLS     r1,r1,#4
000006  480a              LDR      r0,|L1.48|
000008  f7fffffe          BL       __aeabi_memclr4
;;;395    	App.Logic[1].Enabled = true;													// Enable channel 1
00000c  2101              MOVS     r1,#1
00000e  4808              LDR      r0,|L1.48|
000010  7401              STRB     r1,[r0,#0x10]
;;;396    	App.Logic[2].Enabled = true;													// Enable channel 2
000012  3020              ADDS     r0,r0,#0x20
000014  7001              STRB     r1,[r0,#0]
;;;397    	App.Alive_CountDown = CFG_ALIVE_TIME;											// Enable Countdown after restart device
000016  201e              MOVS     r0,#0x1e
000018  4906              LDR      r1,|L1.52|
00001a  86c8              STRH     r0,[r1,#0x36]
;;;398    	App.Write_Output =  true;														// request to write default value into MCP23008
00001c  2001              MOVS     r0,#1
00001e  3120              ADDS     r1,r1,#0x20
000020  7508              STRB     r0,[r1,#0x14]
;;;399    	
;;;400    	App.TickCount = 0;																// Clear TickCounter
000022  2000              MOVS     r0,#0
000024  4a02              LDR      r2,|L1.48|
000026  3a44              SUBS     r2,r2,#0x44
000028  6090              STR      r0,[r2,#8]  ; App
00002a  60d0              STR      r0,[r2,#0xc]  ; App
;;;401    }
00002c  bd10              POP      {r4,pc}
;;;402    
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      App+0x44
                  |L1.52|
                          DCD      App+0x640

                          AREA ||i.Chip_GPIO_WritePortBit||, CODE, READONLY, ALIGN=1

                  Chip_GPIO_WritePortBit PROC
;;;84      */
;;;85     STATIC INLINE void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87     	pGPIO->B[port][pin] = setting;
000002  014c              LSLS     r4,r1,#5
000004  1824              ADDS     r4,r4,r0
000006  54a3              STRB     r3,[r4,r2]
;;;88     }
000008  bd10              POP      {r4,pc}
;;;89     
                          ENDP


                          AREA ||i.Chip_I2CM_Disable||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_Disable PROC
;;;120     */
;;;121    static INLINE void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
000000  6801              LDR      r1,[r0,#0]
;;;122    {
;;;123    	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) & ~I2C_CFG_MSTEN;
000002  06c9              LSLS     r1,r1,#27
000004  0ec9              LSRS     r1,r1,#27
000006  0849              LSRS     r1,r1,#1
000008  0049              LSLS     r1,r1,#1
00000a  6001              STR      r1,[r0,#0]
;;;124    }
00000c  4770              BX       lr
;;;125    
                          ENDP


                          AREA ||i.Chip_I2CM_Enable||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_Enable PROC
;;;109     */
;;;110    static INLINE void Chip_I2CM_Enable(LPC_I2C_T *pI2C)
000000  6801              LDR      r1,[r0,#0]
;;;111    {
;;;112    	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) | I2C_CFG_MSTEN;
000002  06c9              LSLS     r1,r1,#27
000004  0ec9              LSRS     r1,r1,#27
000006  2201              MOVS     r2,#1
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;113    }
00000c  4770              BX       lr
;;;114    
                          ENDP


                          AREA ||i.Chip_I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  Chip_I2C_DisableInt PROC
;;;293     */
;;;294    static INLINE void Chip_I2C_DisableInt(LPC_I2C_T *pI2C, uint32_t intClr)
000000  60c1              STR      r1,[r0,#0xc]
;;;295    {
;;;296    	pI2C->INTENCLR = intClr;
;;;297    }
000002  4770              BX       lr
;;;298    
                          ENDP


                          AREA ||i.Chip_I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  Chip_I2C_EnableInt PROC
;;;282     */
;;;283    static INLINE void Chip_I2C_EnableInt(LPC_I2C_T *pI2C, uint32_t intEn)
000000  6081              STR      r1,[r0,#8]
;;;284    {
;;;285    	pI2C->INTENSET = intEn;
;;;286    }
000002  4770              BX       lr
;;;287    
                          ENDP


                          AREA ||i.Decode_RxCMD||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Decode_RxCMD PROC
;;;190    // ------------------------------------------------------------------------------------------------------
;;;191    void Decode_RxCMD(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;192    {
000002  b08b              SUB      sp,sp,#0x2c
;;;193    	uint32_t olen; //, cmds = 0;
;;;194    	char tmpBuff[16];
;;;195    	char *rxCMD, *rxChannel, *rxParm;
;;;196    	uint32_t Channel, Parm, Response;
;;;197    	char *p;
;;;198    	
;;;199    	rxCMD = strtok((char *) &App.RxCMD[0]," ,\0");									// return first token till space,','or '\0'
000004  a1f9              ADR      r1,|L7.1004|
000006  48fa              LDR      r0,|L7.1008|
000008  f7fffffe          BL       strtok
00000c  9005              STR      r0,[sp,#0x14]
;;;200    	rxChannel = strtok( NULL, " ,\0");												// return next token
00000e  a1f7              ADR      r1,|L7.1004|
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       strtok
000016  9004              STR      r0,[sp,#0x10]
;;;201    	rxParm = strtok( NULL, " ,\0");													// aaaaand return last token
000018  a1f4              ADR      r1,|L7.1004|
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       strtok
000020  9003              STR      r0,[sp,#0xc]
;;;202    	Channel = strtoul(rxChannel, &p, 10);											// return channel as integer
000022  220a              MOVS     r2,#0xa
000024  a902              ADD      r1,sp,#8
000026  9804              LDR      r0,[sp,#0x10]
000028  f7fffffe          BL       strtoul
00002c  4604              MOV      r4,r0
;;;203    	Parm = strtoul(rxParm, &p, 10);													// return parameter as integer
00002e  220a              MOVS     r2,#0xa
000030  a902              ADD      r1,sp,#8
000032  9803              LDR      r0,[sp,#0xc]
000034  f7fffffe          BL       strtoul
000038  4606              MOV      r6,r0
;;;204    	
;;;205    	// Turn On Output Channel
;;;206    	// COMMAND "ON xx,ttt" ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;;207    	if(strncmp((char *) rxCMD, "ON", strlen("ON")) == 0)							// command found with parameters!
00003a  2202              MOVS     r2,#2
00003c  a1ed              ADR      r1,|L7.1012|
00003e  9805              LDR      r0,[sp,#0x14]
000040  f7fffffe          BL       strncmp
000044  2800              CMP      r0,#0
000046  d159              BNE      |L7.252|
;;;208    	{
;;;209    		//LED_YELLOW_ON_TIME;															// YELLOW LED ON
;;;210    		
;;;211    		// if length > CMD (missing divider after CMD), or Time (Parm) is out of range, ignore telegram
;;;212    		if((strlen(rxCMD) == strlen("ON")) || ((Parm < CFG_CMD_PARM_TIME_MAX) && (Parm >= CFG_CMD_PARM_TIME_MIN)))
000048  9805              LDR      r0,[sp,#0x14]
00004a  f7fffffe          BL       strlen
00004e  2802              CMP      r0,#2
000050  d004              BEQ      |L7.92|
000052  48e9              LDR      r0,|L7.1016|
000054  4286              CMP      r6,r0
000056  d24b              BCS      |L7.240|
000058  2e00              CMP      r6,#0
00005a  d049              BEQ      |L7.240|
                  |L7.92|
;;;213    		{
;;;214    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, (const void*) & "RSP ", strlen("RSP "));	// send answer
00005c  2304              MOVS     r3,#4
00005e  a2e7              ADR      r2,|L7.1020|
000060  49e3              LDR      r1,|L7.1008|
000062  3914              SUBS     r1,r1,#0x14
000064  48e7              LDR      r0,|L7.1028|
000066  f7fffffe          BL       Chip_UART_SendRB
;;;215    			olen = sprintf( &tmpBuff[0], "%02d", Channel);							// convert Channel into strings with 2 chars
00006a  4622              MOV      r2,r4
00006c  a1e6              ADR      r1,|L7.1032|
00006e  a806              ADD      r0,sp,#0x18
000070  f7fffffe          BL       __2sprintf
000074  4607              MOV      r7,r0
;;;216    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
000076  463b              MOV      r3,r7
000078  aa06              ADD      r2,sp,#0x18
00007a  49dd              LDR      r1,|L7.1008|
00007c  3914              SUBS     r1,r1,#0x14
00007e  48e1              LDR      r0,|L7.1028|
000080  f7fffffe          BL       Chip_UART_SendRB
;;;217    		
;;;218    			// check if channel is out of range
;;;219    			if((Channel >= CFG_LOGIC_CHANNEL_COUNT) || \
000084  2c63              CMP      r4,#0x63
000086  d205              BCS      |L7.148|
;;;220    			(App.Logic[Channel].Enabled == false)) Response = 2;					// and check active channel is enabled (CONST !)
000088  0121              LSLS     r1,r4,#4
00008a  48d9              LDR      r0,|L7.1008|
00008c  300c              ADDS     r0,r0,#0xc
00008e  5c40              LDRB     r0,[r0,r1]
000090  2800              CMP      r0,#0
000092  d101              BNE      |L7.152|
                  |L7.148|
000094  2502              MOVS     r5,#2
000096  e014              B        |L7.194|
                  |L7.152|
;;;221    			else																	// execute command and read response 
;;;222    			{
;;;223    				if(App.Logic[Channel].Output)										// Channel Activated ?
000098  0121              LSLS     r1,r4,#4
00009a  48d5              LDR      r0,|L7.1008|
00009c  300c              ADDS     r0,r0,#0xc
00009e  1808              ADDS     r0,r1,r0
0000a0  7b40              LDRB     r0,[r0,#0xd]
0000a2  2800              CMP      r0,#0
0000a4  d001              BEQ      |L7.170|
;;;224    				{	
;;;225    					Response = 1;													// channel was already activated
0000a6  2501              MOVS     r5,#1
0000a8  e00b              B        |L7.194|
                  |L7.170|
;;;226    				}
;;;227    				else
;;;228    				{	
;;;229    					App.Logic[Channel].PresetTime = Parm;							// Save time as PresetTime. In Main will be started
0000aa  0122              LSLS     r2,r4,#4
0000ac  48d0              LDR      r0,|L7.1008|
0000ae  300c              ADDS     r0,r0,#0xc
0000b0  1810              ADDS     r0,r2,r0
0000b2  8046              STRH     r6,[r0,#2]
;;;230    					App.Logic[Channel].RemoteEnable = true;							// Chennel enabled remotelly
0000b4  2101              MOVS     r1,#1
0000b6  0122              LSLS     r2,r4,#4
0000b8  48cd              LDR      r0,|L7.1008|
0000ba  300c              ADDS     r0,r0,#0xc
0000bc  1810              ADDS     r0,r2,r0
0000be  7101              STRB     r1,[r0,#4]
;;;231    					Response = 0;													// Return OK
0000c0  2500              MOVS     r5,#0
                  |L7.194|
;;;232    				}
;;;233    			}
;;;234    			// prepare and send response
;;;235    			olen = sprintf( &tmpBuff[0], ",%1d", Response);							// convert Channel into strings with 2 chars
0000c2  462a              MOV      r2,r5
0000c4  a1d2              ADR      r1,|L7.1040|
0000c6  a806              ADD      r0,sp,#0x18
0000c8  f7fffffe          BL       __2sprintf
0000cc  4607              MOV      r7,r0
;;;236    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
0000ce  463b              MOV      r3,r7
0000d0  aa06              ADD      r2,sp,#0x18
0000d2  49c7              LDR      r1,|L7.1008|
0000d4  3914              SUBS     r1,r1,#0x14
0000d6  48cb              LDR      r0,|L7.1028|
0000d8  f7fffffe          BL       Chip_UART_SendRB
;;;237    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, &(uint8_t *) {CFG_TXCMD_ENDCHAR}, 1);	// send END CHAR
0000dc  2000              MOVS     r0,#0
0000de  9001              STR      r0,[sp,#4]
0000e0  2301              MOVS     r3,#1
0000e2  aa01              ADD      r2,sp,#4
0000e4  49c2              LDR      r1,|L7.1008|
0000e6  3914              SUBS     r1,r1,#0x14
0000e8  48c6              LDR      r0,|L7.1028|
0000ea  f7fffffe          BL       Chip_UART_SendRB
;;;238    		}
0000ee  bf00              NOP      
                  |L7.240|
;;;239    		memset(&App.RxCMD[0],0x00, CFG_RXCMD_MAXLEN);								// clear in array
0000f0  210b              MOVS     r1,#0xb
0000f2  48bf              LDR      r0,|L7.1008|
0000f4  f7fffffe          BL       __aeabi_memclr4
                  |L7.248|
;;;240    		return;
;;;241    	}
;;;242    
;;;243    	// Turn Off Output Channel
;;;244    	// COMMAND "OFF xx"	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;;245    	if(strncmp((char *) rxCMD, "OFF", strlen("OFF")) == 0)							// command found with parameters!
;;;246    	{
;;;247    		//LED_YELLOW_ON_TIME;															// YELLOW LED ON	
;;;248    		// if length > CMD (missing divider after CMD), ignore telegram
;;;249    		if(strlen(rxCMD) == strlen("OFF"))
;;;250    		{
;;;251    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, (const void*) & "RSP ", strlen("RSP "));	// send answer
;;;252    			olen = sprintf( &tmpBuff[0], "%02d", Channel);							// convert Channel into strings with 2 chars
;;;253    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;254    		
;;;255    			// check if channel is out of range
;;;256    			if((Channel >= CFG_LOGIC_CHANNEL_COUNT) || \
;;;257    			(App.Logic[Channel].Enabled == false)) Response = 2;					// and check active channel is enabled (CONST !)
;;;258    			else																	// execute command and read response 
;;;259    			{
;;;260    				if(App.Logic[Channel].RemoteEnable)									// Channel Enablked remotelly ?
;;;261    				{	
;;;262    					App.Logic[Channel].RemoteEnable = false;						// Chennel enabled remotelly
;;;263    //					App.Logic[Channel].Output = 0;									// Deactivate channel Output relay
;;;264    //					App.Write_Output = true;										// Request for update MCP23008 Output pins
;;;265    					Response = 0;													// return OK
;;;266    				}
;;;267    				else Response = 1;													// channel was already deactivated
;;;268    			}	
;;;269    			// prepare and send response
;;;270    			olen = sprintf( &tmpBuff[0], ",%1d", Response);							// convert Channel into strings with 2 chars
;;;271    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;272    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, &(uint8_t *) {CFG_TXCMD_ENDCHAR}, 1);	// send END CHAR
;;;273    		}
;;;274    		memset(&App.RxCMD[0],0x00, CFG_RXCMD_MAXLEN);								// clear in array
;;;275    		return;
;;;276    	}
;;;277    
;;;278    	// Report Adapter Status
;;;279    	// COMMAND "ASK" ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;;280    	if(strncmp((char *) rxCMD, "ASK", strlen("ASK")) == 0)							// command found 
;;;281    	{
;;;282    		//LED_YELLOW_ON_TIME;															// YELLOW LED ON
;;;283    		// if length > CMD (missing divider after CMD), ignore telegram
;;;284    		if(strlen(rxCMD) == strlen("ASK"))
;;;285    		{
;;;286    			App.Alive_CountDown = CFG_ALIVE_TIME;									// Reset CountDown Timer
;;;287    			
;;;288    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, (const void*) & "SOK", strlen("SOK"));// send answer
;;;289    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, &(uint8_t *) {CFG_TXCMD_ENDCHAR}, 1);	// send END CHAR
;;;290    		}
;;;291    		memset(&App.RxCMD[0],0x00, CFG_RXCMD_MAXLEN);								// clear in array
;;;292    		return;
;;;293    	}	
;;;294    	
;;;295    	// Report Input Channel Status
;;;296    	// COMMAND "ADI xx"	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;;297    	if(strncmp((char *) rxCMD, "ADI", strlen("ADI")) == 0)							// command found with parameters!
;;;298    	{
;;;299    		//LED_YELLOW_ON_TIME;															// YELLOW LED ON
;;;300    		// if length > CMD (missing divider after CMD), ignore telegram
;;;301    		if(strlen(rxCMD) == strlen("ADI"))
;;;302    		{
;;;303    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, (const void*) & "SDI ", strlen("SDI "));	// send answer
;;;304    			olen = sprintf( &tmpBuff[0], "%02d", Channel);							// convert Channel into strings with 2 chars
;;;305    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;306    		
;;;307    			// check if channel is out of range
;;;308    			if((Channel >= CFG_LOGIC_CHANNEL_COUNT) || \
;;;309    			(App.Logic[Channel].Enabled == false)) Response = 2;					// and check active channel is enabled (CONST !)
;;;310    			else																	// execute command and read response 
;;;311    			{
;;;312    				Response = App.Logic[Channel].Input;								// return Input channel state 0/1
;;;313    			}
;;;314    			// prepare and send response
;;;315    			olen = sprintf( &tmpBuff[0], ",%1d", Response);							// convert Channel into strings with 2 chars
;;;316    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;317    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, &(uint8_t *) {CFG_TXCMD_ENDCHAR}, 1);	// send END CHAR
;;;318    		}
;;;319    		memset(&App.RxCMD[0],0x00, CFG_RXCMD_MAXLEN);								// clear in array
;;;320    		return;
;;;321    	}
;;;322    
;;;323    	// Report Output Channel Status
;;;324    	// COMMAND "ADO xx"	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;;325    	if(strncmp((char *) rxCMD, "ADO", strlen("ADO")) == 0)							// command found with parameters!
;;;326    	{
;;;327    		//LED_YELLOW_ON_TIME;															// YELLOW LED ON
;;;328    		// if length > CMD (missing divider after CMD), ignore telegram
;;;329    		if(strlen(rxCMD) == strlen("ADO"))
;;;330    		{
;;;331    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, (const void*) & "SDO ", strlen("SDO "));	// send answer
;;;332    			olen = sprintf( &tmpBuff[0], "%02d", Channel);							// convert Channel into strings with 2 chars
;;;333    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;334    		
;;;335    			// check if channel is out of range
;;;336    			if((Channel >= CFG_LOGIC_CHANNEL_COUNT) || \
;;;337    			(App.Logic[Channel].Enabled == false)) Response = 2;					// and check active channel is enabled (CONST !)
;;;338    			else																	// execute command and read response 
;;;339    			{
;;;340    				Response = App.Logic[Channel].Output;								// return Output channel state 0/1
;;;341    				if(App.Logic[Channel].PresetTime) App.Alive_CountDown = CFG_ALIVE_TIME;	// If Channel was enabled, also Reset CountDown Timer
;;;342    			}
;;;343    			// prepare and send response
;;;344    			olen = sprintf( &tmpBuff[0], ",%1d", Response);							// convert Channel into strings with 2 chars
;;;345    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;346    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, &(uint8_t *) {CFG_TXCMD_ENDCHAR}, 1);	// send END CHAR
;;;347    		}
;;;348    		memset(&App.RxCMD[0],0x00, CFG_RXCMD_MAXLEN);								// clear in array
;;;349    		return;
;;;350    	}
;;;351    
;;;352    	
;;;353    	// Report unsaved output channel uptime
;;;354    	// COMMAND "SRT xx"	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;;355    	if(strncmp((char *) rxCMD, "SRT", strlen("SRT")) == 0)							// command found with parameters!
;;;356    	{
;;;357    		//LED_YELLOW_ON_TIME;															// YELLOW LED ON
;;;358    		// if length > CMD (missing divider after CMD), ignore telegram
;;;359    		if(strlen(rxCMD) == strlen("SRT"))
;;;360    		{
;;;361    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, (const void*) & "TIM ", strlen("TIM "));	// send answer
;;;362    			olen = sprintf( &tmpBuff[0], "%02d", Channel);							// convert Channel into strings with 2 chars
;;;363    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;364    		
;;;365    			// check if channel is out of range
;;;366    			if((Channel >= CFG_LOGIC_CHANNEL_COUNT) || \
;;;367    			(App.Logic[Channel].Enabled == false)) Response = 0;					// and check active channel is enabled (CONST !)
;;;368    			else																	// execute command and read response 
;;;369    			{
;;;370    				Response = (App.Logic[Channel].OnTime/(CFG_SYSTICKRATE_HZ/CFG_APP_SCANLOGICRATE_HZ));// Operating Time return in second
;;;371    				if(App.Logic[Channel].Output == 0) App.Logic[Channel].OnTime = 0;	// and clear it... but only if Output not active!!
;;;372    			}
;;;373    			// prepare and send response
;;;374    			olen = sprintf( &tmpBuff[0], ",%03d", Response);						// convert Channel into strings with 2 chars
;;;375    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, tmpBuff, olen);	// send string
;;;376    			Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, &(uint8_t *) {CFG_TXCMD_ENDCHAR}, 1);	// send END CHAR
;;;377    		}
;;;378    		memset(&App.RxCMD[0],0x00, CFG_RXCMD_MAXLEN);								// clear in array
;;;379    		return;
;;;380    	}
;;;381    
;;;382    	// if no command decode, clear it:
;;;383    	memset(&App.RxCMD[0],0x00, CFG_RXCMD_MAXLEN);									// clear in array, command not resolved
;;;384    	Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, (const void*) & "ERR 01", strlen("ERR 01"));	// send error flag
;;;385    	Chip_UART_SendRB( CFG_UART_PTRPERI, &App.UART_txRing, &(uint8_t *) {CFG_TXCMD_ENDCHAR}, 1);	// send END CHAR
;;;386    }
0000f8  b00b              ADD      sp,sp,#0x2c
0000fa  bdf0              POP      {r4-r7,pc}
                  |L7.252|
0000fc  2203              MOVS     r2,#3                 ;245
0000fe  a1c6              ADR      r1,|L7.1048|
000100  9805              LDR      r0,[sp,#0x14]         ;245
000102  f7fffffe          BL       strncmp
000106  2800              CMP      r0,#0                 ;245
000108  d14e              BNE      |L7.424|
00010a  9805              LDR      r0,[sp,#0x14]         ;249
00010c  f7fffffe          BL       strlen
000110  2803              CMP      r0,#3                 ;249
000112  d144              BNE      |L7.414|
000114  2304              MOVS     r3,#4                 ;251
000116  a2b9              ADR      r2,|L7.1020|
000118  49b5              LDR      r1,|L7.1008|
00011a  3914              SUBS     r1,r1,#0x14           ;251
00011c  48b9              LDR      r0,|L7.1028|
00011e  f7fffffe          BL       Chip_UART_SendRB
000122  4622              MOV      r2,r4                 ;252
000124  a1b8              ADR      r1,|L7.1032|
000126  a806              ADD      r0,sp,#0x18           ;252
000128  f7fffffe          BL       __2sprintf
00012c  4607              MOV      r7,r0                 ;252
00012e  463b              MOV      r3,r7                 ;253
000130  aa06              ADD      r2,sp,#0x18           ;253
000132  49af              LDR      r1,|L7.1008|
000134  3914              SUBS     r1,r1,#0x14           ;253
000136  48b3              LDR      r0,|L7.1028|
000138  f7fffffe          BL       Chip_UART_SendRB
00013c  2c63              CMP      r4,#0x63              ;256
00013e  d205              BCS      |L7.332|
000140  0121              LSLS     r1,r4,#4              ;257
000142  48ab              LDR      r0,|L7.1008|
000144  300c              ADDS     r0,r0,#0xc            ;257
000146  5c40              LDRB     r0,[r0,r1]            ;257
000148  2800              CMP      r0,#0                 ;257
00014a  d101              BNE      |L7.336|
                  |L7.332|
00014c  2502              MOVS     r5,#2                 ;257
00014e  e00f              B        |L7.368|
                  |L7.336|
000150  0121              LSLS     r1,r4,#4              ;260
000152  48a7              LDR      r0,|L7.1008|
000154  300c              ADDS     r0,r0,#0xc            ;260
000156  1808              ADDS     r0,r1,r0              ;260
000158  7900              LDRB     r0,[r0,#4]            ;260
00015a  2800              CMP      r0,#0                 ;260
00015c  d007              BEQ      |L7.366|
00015e  2100              MOVS     r1,#0                 ;262
000160  0122              LSLS     r2,r4,#4              ;262
000162  48a3              LDR      r0,|L7.1008|
000164  300c              ADDS     r0,r0,#0xc            ;262
000166  1810              ADDS     r0,r2,r0              ;262
000168  7101              STRB     r1,[r0,#4]            ;262
00016a  2500              MOVS     r5,#0                 ;265
00016c  e000              B        |L7.368|
                  |L7.366|
00016e  2501              MOVS     r5,#1                 ;267
                  |L7.368|
000170  462a              MOV      r2,r5                 ;270
000172  a1a7              ADR      r1,|L7.1040|
000174  a806              ADD      r0,sp,#0x18           ;270
000176  f7fffffe          BL       __2sprintf
00017a  4607              MOV      r7,r0                 ;270
00017c  463b              MOV      r3,r7                 ;271
00017e  aa06              ADD      r2,sp,#0x18           ;271
000180  499b              LDR      r1,|L7.1008|
000182  3914              SUBS     r1,r1,#0x14           ;271
000184  489f              LDR      r0,|L7.1028|
000186  f7fffffe          BL       Chip_UART_SendRB
00018a  2000              MOVS     r0,#0                 ;272
00018c  9001              STR      r0,[sp,#4]            ;272
00018e  2301              MOVS     r3,#1                 ;272
000190  aa01              ADD      r2,sp,#4              ;272
000192  4997              LDR      r1,|L7.1008|
000194  3914              SUBS     r1,r1,#0x14           ;272
000196  489b              LDR      r0,|L7.1028|
000198  f7fffffe          BL       Chip_UART_SendRB
00019c  bf00              NOP                            ;273
                  |L7.414|
00019e  210b              MOVS     r1,#0xb               ;274
0001a0  4893              LDR      r0,|L7.1008|
0001a2  f7fffffe          BL       __aeabi_memclr4
0001a6  e7a7              B        |L7.248|
                  |L7.424|
0001a8  2203              MOVS     r2,#3                 ;280
0001aa  a19c              ADR      r1,|L7.1052|
0001ac  9805              LDR      r0,[sp,#0x14]         ;280
0001ae  f7fffffe          BL       strncmp
0001b2  2800              CMP      r0,#0                 ;280
0001b4  d11d              BNE      |L7.498|
0001b6  9805              LDR      r0,[sp,#0x14]         ;284
0001b8  f7fffffe          BL       strlen
0001bc  2803              CMP      r0,#3                 ;284
0001be  d113              BNE      |L7.488|
0001c0  211e              MOVS     r1,#0x1e              ;286
0001c2  4897              LDR      r0,|L7.1056|
0001c4  86c1              STRH     r1,[r0,#0x36]         ;286
0001c6  2303              MOVS     r3,#3                 ;288
0001c8  a296              ADR      r2,|L7.1060|
0001ca  4989              LDR      r1,|L7.1008|
0001cc  3914              SUBS     r1,r1,#0x14           ;288
0001ce  488d              LDR      r0,|L7.1028|
0001d0  f7fffffe          BL       Chip_UART_SendRB
0001d4  2000              MOVS     r0,#0                 ;289
0001d6  9001              STR      r0,[sp,#4]            ;289
0001d8  2301              MOVS     r3,#1                 ;289
0001da  aa01              ADD      r2,sp,#4              ;289
0001dc  4984              LDR      r1,|L7.1008|
0001de  3914              SUBS     r1,r1,#0x14           ;289
0001e0  4888              LDR      r0,|L7.1028|
0001e2  f7fffffe          BL       Chip_UART_SendRB
0001e6  bf00              NOP                            ;290
                  |L7.488|
0001e8  210b              MOVS     r1,#0xb               ;291
0001ea  4881              LDR      r0,|L7.1008|
0001ec  f7fffffe          BL       __aeabi_memclr4
0001f0  e782              B        |L7.248|
                  |L7.498|
0001f2  2203              MOVS     r2,#3                 ;297
0001f4  a18c              ADR      r1,|L7.1064|
0001f6  9805              LDR      r0,[sp,#0x14]         ;297
0001f8  f7fffffe          BL       strncmp
0001fc  2800              CMP      r0,#0                 ;297
0001fe  d143              BNE      |L7.648|
000200  9805              LDR      r0,[sp,#0x14]         ;301
000202  f7fffffe          BL       strlen
000206  2803              CMP      r0,#3                 ;301
000208  d139              BNE      |L7.638|
00020a  2304              MOVS     r3,#4                 ;303
00020c  a287              ADR      r2,|L7.1068|
00020e  4978              LDR      r1,|L7.1008|
000210  3914              SUBS     r1,r1,#0x14           ;303
000212  487c              LDR      r0,|L7.1028|
000214  f7fffffe          BL       Chip_UART_SendRB
000218  4622              MOV      r2,r4                 ;304
00021a  a17b              ADR      r1,|L7.1032|
00021c  a806              ADD      r0,sp,#0x18           ;304
00021e  f7fffffe          BL       __2sprintf
000222  4607              MOV      r7,r0                 ;304
000224  463b              MOV      r3,r7                 ;305
000226  aa06              ADD      r2,sp,#0x18           ;305
000228  4971              LDR      r1,|L7.1008|
00022a  3914              SUBS     r1,r1,#0x14           ;305
00022c  4875              LDR      r0,|L7.1028|
00022e  f7fffffe          BL       Chip_UART_SendRB
000232  2c63              CMP      r4,#0x63              ;308
000234  d205              BCS      |L7.578|
000236  0121              LSLS     r1,r4,#4              ;309
000238  486d              LDR      r0,|L7.1008|
00023a  300c              ADDS     r0,r0,#0xc            ;309
00023c  5c40              LDRB     r0,[r0,r1]            ;309
00023e  2800              CMP      r0,#0                 ;309
000240  d101              BNE      |L7.582|
                  |L7.578|
000242  2502              MOVS     r5,#2                 ;309
000244  e004              B        |L7.592|
                  |L7.582|
000246  0121              LSLS     r1,r4,#4              ;312
000248  4869              LDR      r0,|L7.1008|
00024a  300c              ADDS     r0,r0,#0xc            ;312
00024c  1808              ADDS     r0,r1,r0              ;312
00024e  7b05              LDRB     r5,[r0,#0xc]          ;312
                  |L7.592|
000250  462a              MOV      r2,r5                 ;315
000252  a16f              ADR      r1,|L7.1040|
000254  a806              ADD      r0,sp,#0x18           ;315
000256  f7fffffe          BL       __2sprintf
00025a  4607              MOV      r7,r0                 ;315
00025c  463b              MOV      r3,r7                 ;316
00025e  aa06              ADD      r2,sp,#0x18           ;316
000260  4963              LDR      r1,|L7.1008|
000262  3914              SUBS     r1,r1,#0x14           ;316
000264  4867              LDR      r0,|L7.1028|
000266  f7fffffe          BL       Chip_UART_SendRB
00026a  2000              MOVS     r0,#0                 ;317
00026c  9001              STR      r0,[sp,#4]            ;317
00026e  2301              MOVS     r3,#1                 ;317
000270  aa01              ADD      r2,sp,#4              ;317
000272  495f              LDR      r1,|L7.1008|
000274  3914              SUBS     r1,r1,#0x14           ;317
000276  4863              LDR      r0,|L7.1028|
000278  f7fffffe          BL       Chip_UART_SendRB
00027c  bf00              NOP                            ;318
                  |L7.638|
00027e  210b              MOVS     r1,#0xb               ;319
000280  485b              LDR      r0,|L7.1008|
000282  f7fffffe          BL       __aeabi_memclr4
000286  e737              B        |L7.248|
                  |L7.648|
000288  2203              MOVS     r2,#3                 ;325
00028a  a16a              ADR      r1,|L7.1076|
00028c  9805              LDR      r0,[sp,#0x14]         ;325
00028e  f7fffffe          BL       strncmp
000292  2800              CMP      r0,#0                 ;325
000294  d14d              BNE      |L7.818|
000296  9805              LDR      r0,[sp,#0x14]         ;329
000298  f7fffffe          BL       strlen
00029c  2803              CMP      r0,#3                 ;329
00029e  d143              BNE      |L7.808|
0002a0  2304              MOVS     r3,#4                 ;331
0002a2  a265              ADR      r2,|L7.1080|
0002a4  4952              LDR      r1,|L7.1008|
0002a6  3914              SUBS     r1,r1,#0x14           ;331
0002a8  4856              LDR      r0,|L7.1028|
0002aa  f7fffffe          BL       Chip_UART_SendRB
0002ae  4622              MOV      r2,r4                 ;332
0002b0  a155              ADR      r1,|L7.1032|
0002b2  a806              ADD      r0,sp,#0x18           ;332
0002b4  f7fffffe          BL       __2sprintf
0002b8  4607              MOV      r7,r0                 ;332
0002ba  463b              MOV      r3,r7                 ;333
0002bc  aa06              ADD      r2,sp,#0x18           ;333
0002be  494c              LDR      r1,|L7.1008|
0002c0  3914              SUBS     r1,r1,#0x14           ;333
0002c2  4850              LDR      r0,|L7.1028|
0002c4  f7fffffe          BL       Chip_UART_SendRB
0002c8  2c63              CMP      r4,#0x63              ;336
0002ca  d205              BCS      |L7.728|
0002cc  0121              LSLS     r1,r4,#4              ;337
0002ce  4848              LDR      r0,|L7.1008|
0002d0  300c              ADDS     r0,r0,#0xc            ;337
0002d2  5c40              LDRB     r0,[r0,r1]            ;337
0002d4  2800              CMP      r0,#0                 ;337
0002d6  d101              BNE      |L7.732|
                  |L7.728|
0002d8  2502              MOVS     r5,#2                 ;337
0002da  e00e              B        |L7.762|
                  |L7.732|
0002dc  0121              LSLS     r1,r4,#4              ;340
0002de  4844              LDR      r0,|L7.1008|
0002e0  300c              ADDS     r0,r0,#0xc            ;340
0002e2  1808              ADDS     r0,r1,r0              ;340
0002e4  7b45              LDRB     r5,[r0,#0xd]          ;340
0002e6  0121              LSLS     r1,r4,#4              ;341
0002e8  4841              LDR      r0,|L7.1008|
0002ea  300c              ADDS     r0,r0,#0xc            ;341
0002ec  1808              ADDS     r0,r1,r0              ;341
0002ee  8840              LDRH     r0,[r0,#2]            ;341
0002f0  2800              CMP      r0,#0                 ;341
0002f2  d002              BEQ      |L7.762|
0002f4  211e              MOVS     r1,#0x1e              ;341
0002f6  484a              LDR      r0,|L7.1056|
0002f8  86c1              STRH     r1,[r0,#0x36]         ;341
                  |L7.762|
0002fa  462a              MOV      r2,r5                 ;344
0002fc  a144              ADR      r1,|L7.1040|
0002fe  a806              ADD      r0,sp,#0x18           ;344
000300  f7fffffe          BL       __2sprintf
000304  4607              MOV      r7,r0                 ;344
000306  463b              MOV      r3,r7                 ;345
000308  aa06              ADD      r2,sp,#0x18           ;345
00030a  4939              LDR      r1,|L7.1008|
00030c  3914              SUBS     r1,r1,#0x14           ;345
00030e  483d              LDR      r0,|L7.1028|
000310  f7fffffe          BL       Chip_UART_SendRB
000314  2000              MOVS     r0,#0                 ;346
000316  9001              STR      r0,[sp,#4]            ;346
000318  2301              MOVS     r3,#1                 ;346
00031a  aa01              ADD      r2,sp,#4              ;346
00031c  4934              LDR      r1,|L7.1008|
00031e  3914              SUBS     r1,r1,#0x14           ;346
000320  4838              LDR      r0,|L7.1028|
000322  f7fffffe          BL       Chip_UART_SendRB
000326  bf00              NOP                            ;347
                  |L7.808|
000328  210b              MOVS     r1,#0xb               ;348
00032a  4831              LDR      r0,|L7.1008|
00032c  f7fffffe          BL       __aeabi_memclr4
000330  e6e2              B        |L7.248|
                  |L7.818|
000332  2203              MOVS     r2,#3                 ;355
000334  a142              ADR      r1,|L7.1088|
000336  9805              LDR      r0,[sp,#0x14]         ;355
000338  f7fffffe          BL       strncmp
00033c  2800              CMP      r0,#0                 ;355
00033e  d154              BNE      |L7.1002|
000340  9805              LDR      r0,[sp,#0x14]         ;359
000342  f7fffffe          BL       strlen
000346  2803              CMP      r0,#3                 ;359
000348  d14a              BNE      |L7.992|
00034a  2304              MOVS     r3,#4                 ;361
00034c  a23d              ADR      r2,|L7.1092|
00034e  4928              LDR      r1,|L7.1008|
000350  3914              SUBS     r1,r1,#0x14           ;361
000352  482c              LDR      r0,|L7.1028|
000354  f7fffffe          BL       Chip_UART_SendRB
000358  4622              MOV      r2,r4                 ;362
00035a  a12b              ADR      r1,|L7.1032|
00035c  a806              ADD      r0,sp,#0x18           ;362
00035e  f7fffffe          BL       __2sprintf
000362  4607              MOV      r7,r0                 ;362
000364  463b              MOV      r3,r7                 ;363
000366  aa06              ADD      r2,sp,#0x18           ;363
000368  4921              LDR      r1,|L7.1008|
00036a  3914              SUBS     r1,r1,#0x14           ;363
00036c  4825              LDR      r0,|L7.1028|
00036e  f7fffffe          BL       Chip_UART_SendRB
000372  2c63              CMP      r4,#0x63              ;366
000374  d205              BCS      |L7.898|
000376  0121              LSLS     r1,r4,#4              ;367
000378  481d              LDR      r0,|L7.1008|
00037a  300c              ADDS     r0,r0,#0xc            ;367
00037c  5c40              LDRB     r0,[r0,r1]            ;367
00037e  2800              CMP      r0,#0                 ;367
000380  d101              BNE      |L7.902|
                  |L7.898|
000382  2500              MOVS     r5,#0                 ;367
000384  e015              B        |L7.946|
                  |L7.902|
000386  0122              LSLS     r2,r4,#4              ;370
000388  4919              LDR      r1,|L7.1008|
00038a  310c              ADDS     r1,r1,#0xc            ;370
00038c  1851              ADDS     r1,r2,r1              ;370
00038e  6888              LDR      r0,[r1,#8]            ;370
000390  2164              MOVS     r1,#0x64              ;370
000392  f7fffffe          BL       __aeabi_uidivmod
000396  4605              MOV      r5,r0                 ;370
000398  0121              LSLS     r1,r4,#4              ;371
00039a  4815              LDR      r0,|L7.1008|
00039c  300c              ADDS     r0,r0,#0xc            ;371
00039e  1808              ADDS     r0,r1,r0              ;371
0003a0  7b40              LDRB     r0,[r0,#0xd]          ;371
0003a2  2800              CMP      r0,#0                 ;371
0003a4  d105              BNE      |L7.946|
0003a6  2100              MOVS     r1,#0                 ;371
0003a8  0122              LSLS     r2,r4,#4              ;371
0003aa  4811              LDR      r0,|L7.1008|
0003ac  300c              ADDS     r0,r0,#0xc            ;371
0003ae  1810              ADDS     r0,r2,r0              ;371
0003b0  6081              STR      r1,[r0,#8]            ;371
                  |L7.946|
0003b2  462a              MOV      r2,r5                 ;374
0003b4  a125              ADR      r1,|L7.1100|
0003b6  a806              ADD      r0,sp,#0x18           ;374
0003b8  f7fffffe          BL       __2sprintf
0003bc  4607              MOV      r7,r0                 ;374
0003be  463b              MOV      r3,r7                 ;375
0003c0  aa06              ADD      r2,sp,#0x18           ;375
0003c2  490b              LDR      r1,|L7.1008|
0003c4  3914              SUBS     r1,r1,#0x14           ;375
0003c6  480f              LDR      r0,|L7.1028|
0003c8  f7fffffe          BL       Chip_UART_SendRB
0003cc  2000              MOVS     r0,#0                 ;376
0003ce  9001              STR      r0,[sp,#4]            ;376
0003d0  2301              MOVS     r3,#1                 ;376
0003d2  aa01              ADD      r2,sp,#4              ;376
0003d4  4906              LDR      r1,|L7.1008|
0003d6  3914              SUBS     r1,r1,#0x14           ;376
0003d8  480a              LDR      r0,|L7.1028|
0003da  f7fffffe          BL       Chip_UART_SendRB
0003de  bf00              NOP                            ;377
                  |L7.992|
0003e0  210b              MOVS     r1,#0xb               ;378
0003e2  4803              LDR      r0,|L7.1008|
0003e4  f7fffffe          BL       __aeabi_memclr4
0003e8  e686              B        |L7.248|
                  |L7.1002|
0003ea  e033              B        |L7.1108|
                  |L7.1004|
0003ec  202c00            DCB      " ,",0
0003ef  00                DCB      0
                  |L7.1008|
                          DCD      App+0x38
                  |L7.1012|
0003f4  4f4e00            DCB      "ON",0
0003f7  00                DCB      0
                  |L7.1016|
                          DCD      0x000003e7
                  |L7.1020|
0003fc  52535020          DCB      "RSP ",0
000400  00      
000401  00                DCB      0
000402  00                DCB      0
000403  00                DCB      0
                  |L7.1028|
                          DCD      0x40064000
                  |L7.1032|
000408  25303264          DCB      "%02d",0
00040c  00      
00040d  00                DCB      0
00040e  00                DCB      0
00040f  00                DCB      0
                  |L7.1040|
000410  2c253164          DCB      ",%1d",0
000414  00      
000415  00                DCB      0
000416  00                DCB      0
000417  00                DCB      0
                  |L7.1048|
000418  4f464600          DCB      "OFF",0
                  |L7.1052|
00041c  41534b00          DCB      "ASK",0
                  |L7.1056|
                          DCD      App+0x640
                  |L7.1060|
000424  534f4b00          DCB      "SOK",0
                  |L7.1064|
000428  41444900          DCB      "ADI",0
                  |L7.1068|
00042c  53444920          DCB      "SDI ",0
000430  00      
000431  00                DCB      0
000432  00                DCB      0
000433  00                DCB      0
                  |L7.1076|
000434  41444f00          DCB      "ADO",0
                  |L7.1080|
000438  53444f20          DCB      "SDO ",0
00043c  00      
00043d  00                DCB      0
00043e  00                DCB      0
00043f  00                DCB      0
                  |L7.1088|
000440  53525400          DCB      "SRT",0
                  |L7.1092|
000444  54494d20          DCB      "TIM ",0
000448  00      
000449  00                DCB      0
00044a  00                DCB      0
00044b  00                DCB      0
                  |L7.1100|
00044c  2c253033          DCB      ",%03d",0
000450  6400    
000452  00                DCB      0
000453  00                DCB      0
                  |L7.1108|
000454  210b              MOVS     r1,#0xb               ;383
000456  480a              LDR      r0,|L7.1152|
000458  f7fffffe          BL       __aeabi_memclr4
00045c  2306              MOVS     r3,#6                 ;384
00045e  a209              ADR      r2,|L7.1156|
000460  4907              LDR      r1,|L7.1152|
000462  3914              SUBS     r1,r1,#0x14           ;384
000464  4809              LDR      r0,|L7.1164|
000466  f7fffffe          BL       Chip_UART_SendRB
00046a  2000              MOVS     r0,#0                 ;385
00046c  900a              STR      r0,[sp,#0x28]         ;385
00046e  2301              MOVS     r3,#1                 ;385
000470  aa0a              ADD      r2,sp,#0x28           ;385
000472  4903              LDR      r1,|L7.1152|
000474  3914              SUBS     r1,r1,#0x14           ;385
000476  4805              LDR      r0,|L7.1164|
000478  f7fffffe          BL       Chip_UART_SendRB
00047c  bf00              NOP      
00047e  e63b              B        |L7.248|
;;;387    
                          ENDP

                  |L7.1152|
                          DCD      App+0x38
                  |L7.1156|
000484  45525220          DCB      "ERR 01",0
000488  303100  
00048b  00                DCB      0
                  |L7.1164|
                          DCD      0x40064000

                          AREA ||i.I2C0_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C0_IRQHandler PROC
;;;439    // ------------------------------------------------------------------------------------------------------
;;;440    void I2C_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;441    {
;;;442    	Chip_I2CM_XferHandler(LPC_I2C, &I2CXfer); 										// Call I2CM ISR function with the I2C device and transfer rec
000002  4902              LDR      r1,|L8.12|
000004  4802              LDR      r0,|L8.16|
000006  f7fffffe          BL       Chip_I2CM_XferHandler
;;;443    }
00000a  bd10              POP      {r4,pc}
;;;444    
                          ENDP

                  |L8.12|
                          DCD      I2CXfer
                  |L8.16|
                          DCD      0x40050000

                          AREA ||i.MCP23008_Init||, CODE, READONLY, ALIGN=1

                  MCP23008_Init PROC
;;;106    // ------------------------------------------------------------------------------------------------------
;;;107    void MCP23008_Init(void)
000000  b510              PUSH     {r4,lr}
;;;108    {
;;;109    //	uint16_t arr[12];
;;;110    //	for(uint8_t i=0; i<12; i++)
;;;111    //	{
;;;112    //		MCP23008_Write8(i, 255);
;;;113    //	}
;;;114    //	
;;;115    //	for(uint8_t i=0; i<12; i++)
;;;116    //	{
;;;117    //		arr[i] = MCP23008_Read8(i);
;;;118    //	}	
;;;119    //	for(uint8_t i=0; i<12; i++)
;;;120    //	{
;;;121    //		arr[i] = MCP23008_Read8(i);
;;;122    //	}	
;;;123    
;;;124    	// Set array to regs values:
;;;125    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_IOCON, 0x20);								// Firstly, Disable sequentional access!
000002  2120              MOVS     r1,#0x20
000004  2005              MOVS     r0,#5
000006  f7fffffe          BL       MCP23008_Write8
;;;126    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_IODIR, 0x03);								// G0-GP1 as Input, GP4-GP5 as Output
00000a  2103              MOVS     r1,#3
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       MCP23008_Write8
;;;127    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_IPOL, 0x00);								// normal polarity for all Inp. : 1 as active (power present on physical input terminal)
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       MCP23008_Write8
;;;128    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_GPINTEN, 0x00);							// Interrupt is not used
00001a  2100              MOVS     r1,#0
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       MCP23008_Write8
;;;129    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_DEFVAL, 0x00);							// Interrupt is not used
000022  2100              MOVS     r1,#0
000024  2003              MOVS     r0,#3
000026  f7fffffe          BL       MCP23008_Write8
;;;130    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_INTCON, 0x00);							// Interrupt is not used
00002a  2100              MOVS     r1,#0
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       MCP23008_Write8
;;;131    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_GPPU, 0x00);								// PullUp disabled
000032  2100              MOVS     r1,#0
000034  2006              MOVS     r0,#6
000036  f7fffffe          BL       MCP23008_Write8
;;;132    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_INTCAP, 0x00);							// Interrupt Capture - R/O
00003a  2100              MOVS     r1,#0
00003c  2008              MOVS     r0,#8
00003e  f7fffffe          BL       MCP23008_Write8
;;;133    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_GPIO, 0x00);								// GPIO set to inactive
000042  2100              MOVS     r1,#0
000044  2009              MOVS     r0,#9
000046  f7fffffe          BL       MCP23008_Write8
;;;134    	MCP23008_Write8 (CFG_I2C_MCP23008_REG_OLAT, 0x00);								// Output inactive
00004a  2100              MOVS     r1,#0
00004c  200a              MOVS     r0,#0xa
00004e  f7fffffe          BL       MCP23008_Write8
;;;135    }
000052  bd10              POP      {r4,pc}
;;;136    
                          ENDP


                          AREA ||i.MCP23008_Read8||, CODE, READONLY, ALIGN=2

                  MCP23008_Read8 PROC
;;;72     // ------------------------------------------------------------------------------------------------------
;;;73     uint8_t MCP23008_Read8(uint8_t RegAdr)
000000  b501              PUSH     {r0,lr}
;;;74     {
000002  b082              SUB      sp,sp,#8
;;;75     	uint8_t tmpRxBuff;
;;;76     	
;;;77     //	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, true );		// turn ON indicator
;;;78     
;;;79     	I2CXfer.slaveAddr = CFG_I2C_MCP23008_ADR >> 1;									// SET I2C Slave address
000004  2022              MOVS     r0,#0x22
000006  4913              LDR      r1,|L10.84|
000008  7388              STRB     r0,[r1,#0xe]
;;;80     	I2CXfer.txBuff = &RegAdr;														// select dst register
00000a  a802              ADD      r0,sp,#8
00000c  6008              STR      r0,[r1,#0]  ; I2CXfer
;;;81     	I2CXfer.txSz = 1;																// write 1 bytes
00000e  2001              MOVS     r0,#1
000010  8108              STRH     r0,[r1,#8]
;;;82     	I2CXfer.rxSz = 1;																// we will read 1 byte
000012  8148              STRH     r0,[r1,#0xa]
;;;83     	I2CXfer.status = 0;
000014  2000              MOVS     r0,#0
000016  8188              STRH     r0,[r1,#0xc]
;;;84     
;;;85     	Chip_I2CM_Disable(CFG_I2C_PTRPERI);
000018  480f              LDR      r0,|L10.88|
00001a  f7fffffe          BL       Chip_I2CM_Disable
;;;86     	Chip_I2CM_Enable(CFG_I2C_PTRPERI);	
00001e  480e              LDR      r0,|L10.88|
000020  f7fffffe          BL       Chip_I2CM_Enable
;;;87     
;;;88     	I2CXfer.rxBuff = &tmpRxBuff;													// select local destination for read
000024  a801              ADD      r0,sp,#4
000026  490b              LDR      r1,|L10.84|
000028  6048              STR      r0,[r1,#4]  ; I2CXfer
;;;89     
;;;90     	Chip_I2CM_Xfer(CFG_I2C_PTRPERI, &I2CXfer);
00002a  480b              LDR      r0,|L10.88|
00002c  f7fffffe          BL       Chip_I2CM_Xfer
;;;91     	Chip_I2C_EnableInt(CFG_I2C_PTRPERI, I2C_INTENSET_MSTPENDING | I2C_INTENSET_MSTRARBLOSS | I2C_INTENSET_MSTSTSTPERR | I2C_INTENSET_EVENTTIMEOUT);
000030  490a              LDR      r1,|L10.92|
000032  4809              LDR      r0,|L10.88|
000034  f7fffffe          BL       Chip_I2C_EnableInt
;;;92     	WaitForI2cXferComplete(&I2CXfer);
000038  4806              LDR      r0,|L10.84|
00003a  f7fffffe          BL       WaitForI2cXferComplete
;;;93     	StopWatch_DelayTicks(100);
00003e  2064              MOVS     r0,#0x64
000040  f7fffffe          BL       StopWatch_DelayTicks
;;;94     	Chip_I2C_DisableInt(CFG_I2C_PTRPERI, I2C_INTENSET_MSTPENDING | I2C_INTENSET_MSTRARBLOSS | I2C_INTENSET_MSTSTSTPERR | I2C_INTENSET_EVENTTIMEOUT);
000044  4905              LDR      r1,|L10.92|
000046  4804              LDR      r0,|L10.88|
000048  f7fffffe          BL       Chip_I2C_DisableInt
;;;95     	
;;;96     //	Chip_I2CM_XferBlocking(CFG_I2C_PTRPERI, &I2CXfer);
;;;97     	
;;;98     //	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, false );		// turn OFF indicator
;;;99     
;;;100    	return(tmpRxBuff);
00004c  4668              MOV      r0,sp
00004e  7900              LDRB     r0,[r0,#4]
;;;101    }
000050  bd0e              POP      {r1-r3,pc}
;;;102    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      I2CXfer
                  |L10.88|
                          DCD      0x40050000
                  |L10.92|
                          DCD      0x01000051

                          AREA ||i.MCP23008_Write8||, CODE, READONLY, ALIGN=2

                  MCP23008_Write8 PROC
;;;42     // ------------------------------------------------------------------------------------------------------
;;;43     void MCP23008_Write8(uint8_t RegAdr, uint8_t RegValue)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;45     	static uint8_t tmpTxBuff[2];
;;;46     	
;;;47     //	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, true );		// turn ON indicator
;;;48     	
;;;49     	I2CXfer.slaveAddr = CFG_I2C_MCP23008_ADR >> 1;									// SET I2C Slave address
000006  2022              MOVS     r0,#0x22
000008  4911              LDR      r1,|L11.80|
00000a  7388              STRB     r0,[r1,#0xe]
;;;50     	tmpTxBuff[0] = RegAdr;															// select dst register
00000c  4811              LDR      r0,|L11.84|
00000e  7005              STRB     r5,[r0,#0]
;;;51     	tmpTxBuff[1] = RegValue;														// select register value
000010  7044              STRB     r4,[r0,#1]
;;;52     	I2CXfer.txBuff = &tmpTxBuff[0];													// select dst register
000012  6008              STR      r0,[r1,#0]  ; I2CXfer
;;;53     	I2CXfer.txSz = 2;																// write 2 bytes
000014  2002              MOVS     r0,#2
000016  8108              STRH     r0,[r1,#8]
;;;54     	I2CXfer.rxSz = 0;																// we will not read
000018  2000              MOVS     r0,#0
00001a  8148              STRH     r0,[r1,#0xa]
;;;55     	I2CXfer.status = 0;
00001c  8188              STRH     r0,[r1,#0xc]
;;;56     	
;;;57     	Chip_I2CM_Disable(CFG_I2C_PTRPERI);
00001e  480e              LDR      r0,|L11.88|
000020  f7fffffe          BL       Chip_I2CM_Disable
;;;58     	Chip_I2CM_Enable(CFG_I2C_PTRPERI);	
000024  480c              LDR      r0,|L11.88|
000026  f7fffffe          BL       Chip_I2CM_Enable
;;;59     	Chip_I2CM_Xfer(CFG_I2C_PTRPERI, &I2CXfer);
00002a  4909              LDR      r1,|L11.80|
00002c  480a              LDR      r0,|L11.88|
00002e  f7fffffe          BL       Chip_I2CM_Xfer
;;;60     	Chip_I2C_EnableInt(CFG_I2C_PTRPERI, I2C_INTENSET_MSTPENDING | I2C_INTENSET_MSTRARBLOSS | I2C_INTENSET_MSTSTSTPERR | I2C_INTENSET_EVENTTIMEOUT);
000032  490a              LDR      r1,|L11.92|
000034  4808              LDR      r0,|L11.88|
000036  f7fffffe          BL       Chip_I2C_EnableInt
;;;61     	WaitForI2cXferComplete(&I2CXfer);
00003a  4805              LDR      r0,|L11.80|
00003c  f7fffffe          BL       WaitForI2cXferComplete
;;;62     	StopWatch_DelayTicks(100);
000040  2064              MOVS     r0,#0x64
000042  f7fffffe          BL       StopWatch_DelayTicks
;;;63     	Chip_I2C_DisableInt(CFG_I2C_PTRPERI, I2C_INTENSET_MSTPENDING | I2C_INTENSET_MSTRARBLOSS | I2C_INTENSET_MSTSTSTPERR | I2C_INTENSET_EVENTTIMEOUT);
000046  4905              LDR      r1,|L11.92|
000048  4803              LDR      r0,|L11.88|
00004a  f7fffffe          BL       Chip_I2C_DisableInt
;;;64     	
;;;65     //	Chip_I2CM_XferBlocking(CFG_I2C_PTRPERI, &I2CXfer);
;;;66     
;;;67     //	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, false );		// turn OFF indicator
;;;68     }
00004e  bd70              POP      {r4-r6,pc}
;;;69     
                          ENDP

                  |L11.80|
                          DCD      I2CXfer
                  |L11.84|
                          DCD      tmpTxBuff
                  |L11.88|
                          DCD      0x40050000
                  |L11.92|
                          DCD      0x01000051

                          AREA ||i.Reload_Inputs||, CODE, READONLY, ALIGN=2

                  Reload_Inputs PROC
;;;156    // ------------------------------------------------------------------------------------------------------
;;;157    void Reload_Inputs(void)
000000  b510              PUSH     {r4,lr}
;;;158    {
;;;159    	uint8_t tmpInp = MCP23008_Read8(CFG_I2C_MCP23008_REG_GPIO) & 0x0f;				// Read I2C Inputs and wait for result
000002  2009              MOVS     r0,#9
000004  f7fffffe          BL       MCP23008_Read8
000008  0704              LSLS     r4,r0,#28
00000a  0f24              LSRS     r4,r4,#28
;;;160    	
;;;161    	// In this FW is useable only channel 1 and 2. But I read also 3 and 4 :-)
;;;162    	
;;;163    	App.Logic[0].Input = 0;
00000c  2100              MOVS     r1,#0
00000e  480c              LDR      r0,|L12.64|
000010  7301              STRB     r1,[r0,#0xc]
;;;164    	App.Logic[1].Input = (tmpInp & (1 << 0))? 1: 0;
000012  07e1              LSLS     r1,r4,#31
000014  0fc9              LSRS     r1,r1,#31
000016  7701              STRB     r1,[r0,#0x1c]
;;;165    	App.Logic[2].Input = (tmpInp & (1 << 1))? 1: 0;
000018  2002              MOVS     r0,#2
00001a  4020              ANDS     r0,r0,r4
00001c  0841              LSRS     r1,r0,#1
00001e  4808              LDR      r0,|L12.64|
000020  3020              ADDS     r0,r0,#0x20
000022  7301              STRB     r1,[r0,#0xc]
;;;166    	App.Logic[3].Input = (tmpInp & (1 << 2))? 1: 0;
000024  2004              MOVS     r0,#4
000026  4020              ANDS     r0,r0,r4
000028  0881              LSRS     r1,r0,#2
00002a  4805              LDR      r0,|L12.64|
00002c  3030              ADDS     r0,r0,#0x30
00002e  7301              STRB     r1,[r0,#0xc]
;;;167    	App.Logic[4].Input = (tmpInp & (1 << 3))? 1: 0;
000030  2008              MOVS     r0,#8
000032  4020              ANDS     r0,r0,r4
000034  08c1              LSRS     r1,r0,#3
000036  4802              LDR      r0,|L12.64|
000038  3040              ADDS     r0,r0,#0x40
00003a  7301              STRB     r1,[r0,#0xc]
;;;168    }
00003c  bd10              POP      {r4,pc}
;;;169    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      App+0x44

                          AREA ||i.Rewrite_Outputs||, CODE, READONLY, ALIGN=2

                  Rewrite_Outputs PROC
;;;172    // ------------------------------------------------------------------------------------------------------
;;;173    void Rewrite_Outputs(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175    	uint8_t tmpOut = 0;
000002  2400              MOVS     r4,#0
;;;176    	
;;;177    	// In this FW is useable only channel 1 and 2. But I write also 3 and 4 :-)
;;;178    	
;;;179    	tmpOut |=  (App.Logic[1].Output & 0x01) << 0;
000004  480e              LDR      r0,|L13.64|
000006  7f40              LDRB     r0,[r0,#0x1d]
000008  07c0              LSLS     r0,r0,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  4304              ORRS     r4,r4,r0
;;;180    	tmpOut |=  (App.Logic[2].Output & 0x01) << 1;
00000e  480c              LDR      r0,|L13.64|
000010  3020              ADDS     r0,r0,#0x20
000012  7b40              LDRB     r0,[r0,#0xd]
000014  07c0              LSLS     r0,r0,#31
000016  0f80              LSRS     r0,r0,#30
000018  4304              ORRS     r4,r4,r0
;;;181    	tmpOut |=  (App.Logic[3].Output & 0x01) << 2;
00001a  4809              LDR      r0,|L13.64|
00001c  3030              ADDS     r0,r0,#0x30
00001e  7b40              LDRB     r0,[r0,#0xd]
000020  07c0              LSLS     r0,r0,#31
000022  0f40              LSRS     r0,r0,#29
000024  4304              ORRS     r4,r4,r0
;;;182    	tmpOut |=  (App.Logic[4].Output & 0x01) << 3;
000026  4806              LDR      r0,|L13.64|
000028  3040              ADDS     r0,r0,#0x40
00002a  7b40              LDRB     r0,[r0,#0xd]
00002c  07c0              LSLS     r0,r0,#31
00002e  0f00              LSRS     r0,r0,#28
000030  4304              ORRS     r4,r4,r0
;;;183    	tmpOut = tmpOut << 4;															// Output used only on four upper bits
000032  0124              LSLS     r4,r4,#4
;;;184    	
;;;185    	MCP23008_Write8( CFG_I2C_MCP23008_REG_OLAT, tmpOut);							// Write into MCP23008
000034  4621              MOV      r1,r4
000036  200a              MOVS     r0,#0xa
000038  f7fffffe          BL       MCP23008_Write8
;;;186    }
00003c  bd10              POP      {r4,pc}
;;;187    						
                          ENDP

00003e  0000              DCW      0x0000
                  |L13.64|
                          DCD      App+0x44

                          AREA ||i.StopWatch_DelayMs||, CODE, READONLY, ALIGN=1

                  StopWatch_DelayMs PROC
;;;113     */
;;;114    STATIC INLINE void StopWatch_DelayMs(uint32_t mS)
000000  b570              PUSH     {r4-r6,lr}
;;;115    {
000002  4604              MOV      r4,r0
;;;116    	uint32_t ticks = StopWatch_MsToTicks(mS);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       StopWatch_MsToTicks
00000a  4605              MOV      r5,r0
;;;117    	uint32_t startTime = StopWatch_Start();
00000c  f7fffffe          BL       StopWatch_Start
000010  4606              MOV      r6,r0
;;;118    	while (StopWatch_Elapsed(startTime) < ticks) {}
000012  bf00              NOP      
                  |L14.20|
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       StopWatch_Elapsed
00001a  42a8              CMP      r0,r5
00001c  d3fa              BCC      |L14.20|
;;;119    }
00001e  bd70              POP      {r4-r6,pc}
;;;120    
                          ENDP


                          AREA ||i.StopWatch_DelayTicks||, CODE, READONLY, ALIGN=1

                  StopWatch_DelayTicks PROC
;;;102     */
;;;103    STATIC INLINE void StopWatch_DelayTicks(uint32_t ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;104    {
000002  4604              MOV      r4,r0
;;;105    	uint32_t startTime = StopWatch_Start();
000004  f7fffffe          BL       StopWatch_Start
000008  4605              MOV      r5,r0
;;;106    	while (StopWatch_Elapsed(startTime) < ticks) {}
00000a  bf00              NOP      
                  |L15.12|
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       StopWatch_Elapsed
000012  42a0              CMP      r0,r4
000014  d3fa              BCC      |L15.12|
;;;107    }
000016  bd70              POP      {r4-r6,pc}
;;;108    
                          ENDP


                          AREA ||i.StopWatch_Elapsed||, CODE, READONLY, ALIGN=1

                  StopWatch_Elapsed PROC
;;;58      */
;;;59     STATIC INLINE uint32_t StopWatch_Elapsed(uint32_t startTime)
000000  b510              PUSH     {r4,lr}
;;;60     {
000002  4604              MOV      r4,r0
;;;61     	return StopWatch_Start() - startTime;
000004  f7fffffe          BL       StopWatch_Start
000008  1b00              SUBS     r0,r0,r4
;;;62     }
00000a  bd10              POP      {r4,pc}
;;;63     
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;413    // ------------------------------------------------------------------------------------------------------
;;;414    void SysTick_Handler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;415    {
;;;416    	App.TickCount += 1;																// system counter
000002  4825              LDR      r0,|L17.152|
000004  6882              LDR      r2,[r0,#8]  ; App
000006  68c0              LDR      r0,[r0,#0xc]  ; App
000008  2100              MOVS     r1,#0
00000a  1c52              ADDS     r2,r2,#1
00000c  4148              ADCS     r0,r0,r1
00000e  4922              LDR      r1,|L17.152|
000010  608a              STR      r2,[r1,#8]  ; App
000012  60c8              STR      r0,[r1,#0xc]  ; App
;;;417    	if((App.TickCount % CFG_SYSTICKRATE_HZ) == 0) App.Second_Flag = true;			// each second
000014  4608              MOV      r0,r1
000016  6884              LDR      r4,[r0,#8]  ; App
000018  68c1              LDR      r1,[r0,#0xc]  ; App
00001a  227d              MOVS     r2,#0x7d
00001c  00d2              LSLS     r2,r2,#3
00001e  2300              MOVS     r3,#0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       __aeabi_uldivmod
000026  2100              MOVS     r1,#0
000028  404a              EORS     r2,r2,r1
00002a  404b              EORS     r3,r3,r1
00002c  431a              ORRS     r2,r2,r3
00002e  d102              BNE      |L17.54|
000030  2001              MOVS     r0,#1
000032  491a              LDR      r1,|L17.156|
000034  7788              STRB     r0,[r1,#0x1e]
                  |L17.54|
;;;418    	if((App.TickCount % CFG_APP_SCANLOGICRATE_HZ) == 1) App.ScanLogic_Flag = true;	// each second + 1 ms
000036  4818              LDR      r0,|L17.152|
000038  6884              LDR      r4,[r0,#8]  ; App
00003a  68c1              LDR      r1,[r0,#0xc]  ; App
00003c  220a              MOVS     r2,#0xa
00003e  2300              MOVS     r3,#0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       __aeabi_uldivmod
000046  2101              MOVS     r1,#1
000048  404a              EORS     r2,r2,r1
00004a  431a              ORRS     r2,r2,r3
00004c  d102              BNE      |L17.84|
00004e  2001              MOVS     r0,#1
000050  4912              LDR      r1,|L17.156|
000052  77c8              STRB     r0,[r1,#0x1f]
                  |L17.84|
;;;419    	
;;;420    	if(App.GreenLed_Alive_Count) App.GreenLed_Alive_Count --;						// Green LED lit on. Count to off
000054  4811              LDR      r0,|L17.156|
000056  3820              SUBS     r0,r0,#0x20
000058  8f00              LDRH     r0,[r0,#0x38]  ; App
00005a  2800              CMP      r0,#0
00005c  d007              BEQ      |L17.110|
00005e  480f              LDR      r0,|L17.156|
000060  3820              SUBS     r0,r0,#0x20
000062  8f00              LDRH     r0,[r0,#0x38]  ; App
000064  1e40              SUBS     r0,r0,#1
000066  490d              LDR      r1,|L17.156|
000068  3920              SUBS     r1,r1,#0x20
00006a  8708              STRH     r0,[r1,#0x38]
00006c  e002              B        |L17.116|
                  |L17.110|
;;;421    	else App.GreenLed_Off = true;
00006e  2001              MOVS     r0,#1
000070  490a              LDR      r1,|L17.156|
000072  7748              STRB     r0,[r1,#0x1d]
                  |L17.116|
;;;422    
;;;423    	if(App.YellowLed_Alive_Count) App.YellowLed_Alive_Count --;						// Yellow LED lit on. Count to off
000074  4809              LDR      r0,|L17.156|
000076  3820              SUBS     r0,r0,#0x20
000078  8f40              LDRH     r0,[r0,#0x3a]  ; App
00007a  2800              CMP      r0,#0
00007c  d008              BEQ      |L17.144|
00007e  4807              LDR      r0,|L17.156|
000080  3820              SUBS     r0,r0,#0x20
000082  8f40              LDRH     r0,[r0,#0x3a]  ; App
000084  1e40              SUBS     r0,r0,#1
000086  b281              UXTH     r1,r0
000088  4804              LDR      r0,|L17.156|
00008a  3820              SUBS     r0,r0,#0x20
00008c  8741              STRH     r1,[r0,#0x3a]
00008e  e002              B        |L17.150|
                  |L17.144|
;;;424    	else App.YellowLed_Off = true;
000090  2001              MOVS     r0,#1
000092  4902              LDR      r1,|L17.156|
000094  7708              STRB     r0,[r1,#0x1c]
                  |L17.150|
;;;425    }
000096  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP

                  |L17.152|
                          DCD      App
                  |L17.156|
                          DCD      App+0x660

                          AREA ||i.USART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART0_IRQHandler PROC
;;;430    // ------------------------------------------------------------------------------------------------------
;;;431    void USART0_IRQHandler (void)
000000  b510              PUSH     {r4,lr}
;;;432    {
;;;433    	Chip_UART_IRQRBHandler(LPC_USART0, &App.UART_rxRing, &App.UART_txRing);			// Call RingBuffer UART Handler
000002  4a08              LDR      r2,|L18.36|
000004  4611              MOV      r1,r2
000006  3914              SUBS     r1,r1,#0x14
000008  4807              LDR      r0,|L18.40|
00000a  f7fffffe          BL       Chip_UART_IRQRBHandler
;;;434    	LED_GREEN_ON_TIME;																// GREEN LED ON
00000e  2064              MOVS     r0,#0x64
000010  4906              LDR      r1,|L18.44|
000012  8708              STRH     r0,[r1,#0x38]
000014  2301              MOVS     r3,#1
000016  2213              MOVS     r2,#0x13
000018  2100              MOVS     r1,#0
00001a  2005              MOVS     r0,#5
00001c  0740              LSLS     r0,r0,#29
00001e  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;435    }
000022  bd10              POP      {r4,pc}
;;;436    
                          ENDP

                  |L18.36|
                          DCD      App+0x24
                  |L18.40|
                          DCD      0x40064000
                  |L18.44|
                          DCD      App+0x640

                          AREA ||i.WaitForI2cXferComplete||, CODE, READONLY, ALIGN=1

                  WaitForI2cXferComplete PROC
;;;33     // ------------------------------------------------------------------------------------------------------
;;;34     static void WaitForI2cXferComplete(I2CM_XFER_T *xferRec)
000000  bf00              NOP      
                  |L19.2|
;;;35     {
;;;36     	while ((xferRec->status == I2CM_STATUS_BUSY) || (xferRec->txSz) || (xferRec->rxSz))	// Test for still transferring data
000002  8981              LDRH     r1,[r0,#0xc]
000004  29ff              CMP      r1,#0xff
000006  d0fc              BEQ      |L19.2|
000008  8901              LDRH     r1,[r0,#8]
00000a  2900              CMP      r1,#0
00000c  d1f9              BNE      |L19.2|
00000e  8941              LDRH     r1,[r0,#0xa]
000010  2900              CMP      r1,#0
000012  d1f6              BNE      |L19.2|
;;;37     	{}
;;;38     }
000014  4770              BX       lr
;;;39     
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;449    // ------------------------------------------------------------------------------------------------------
;;;450    int main(void)
000000  b508              PUSH     {r3,lr}
;;;451    {
;;;452    	uint8_t Chnl = 0;
000002  2600              MOVS     r6,#0
;;;453    	
;;;454    	__disable_irq();																// don't intrude me...
000004  b672              CPSID    i
;;;455    	
;;;456    	SystemCoreClockUpdate();														// re-read current clock settings
000006  f7fffffe          BL       SystemCoreClockUpdate
;;;457    	
;;;458    	Board_Init();																	// Initialize MCU Board
00000a  f7fffffe          BL       Board_Init
;;;459    	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, false );		// GREEN LED OFF
00000e  2300              MOVS     r3,#0
000010  2213              MOVS     r2,#0x13
000012  4619              MOV      r1,r3
000014  2005              MOVS     r0,#5
000016  0740              LSLS     r0,r0,#29
000018  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;460    	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_YELLOW_PORTPIN, false );		// Yellow LED OFF
00001c  2300              MOVS     r3,#0
00001e  2212              MOVS     r2,#0x12
000020  4619              MOV      r1,r3
000022  2005              MOVS     r0,#5
000024  0740              LSLS     r0,r0,#29
000026  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;461    
;;;462    	// Application buffers init
;;;463    	RingBuffer_Init(&App.UART_rxRing, rxbuff, 1, CFG_UART_RB_SIZE);					// initialize Rx RingBuffer for UART
00002a  2340              MOVS     r3,#0x40
00002c  2201              MOVS     r2,#1
00002e  49d1              LDR      r1,|L20.884|
000030  48d1              LDR      r0,|L20.888|
000032  f7fffffe          BL       RingBuffer_Init
;;;464    	RingBuffer_Init(&App.UART_txRing, txbuff, 1, CFG_UART_RB_SIZE);					// initialize Tx RingBuffer for UART
000036  2340              MOVS     r3,#0x40
000038  2201              MOVS     r2,#1
00003a  49d0              LDR      r1,|L20.892|
00003c  48ce              LDR      r0,|L20.888|
00003e  3014              ADDS     r0,r0,#0x14
000040  f7fffffe          BL       RingBuffer_Init
;;;465    
;;;466    	App_Init();																		// Now have to initialize application variables, because it used in interrupt also
000044  f7fffffe          BL       App_Init
;;;467    	__enable_irq();
000048  b662              CPSIE    i
;;;468    
;;;469    	StopWatch_Init();																// Initialize stopwatch
00004a  f7fffffe          BL       StopWatch_Init
;;;470    
;;;471    	StopWatch_DelayMs(500);															// first blink after 0.5 sec
00004e  20ff              MOVS     r0,#0xff
000050  30f5              ADDS     r0,r0,#0xf5
000052  f7fffffe          BL       StopWatch_DelayMs
;;;472    	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, true );		// GREEN LED ON	
000056  2301              MOVS     r3,#1
000058  2213              MOVS     r2,#0x13
00005a  2100              MOVS     r1,#0
00005c  2005              MOVS     r0,#5
00005e  0740              LSLS     r0,r0,#29
000060  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;473    	StopWatch_DelayMs(500);															// Lit ON 0.5 sec
000064  20ff              MOVS     r0,#0xff
000066  30f5              ADDS     r0,r0,#0xf5
000068  f7fffffe          BL       StopWatch_DelayMs
;;;474    
;;;475    
;;;476    	MCP23008_Init();																// Initialize MCP23008
00006c  f7fffffe          BL       MCP23008_Init
;;;477    
;;;478    	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, false );		// GREEN LED OFF
000070  2300              MOVS     r3,#0
000072  2213              MOVS     r2,#0x13
000074  4619              MOV      r1,r3
000076  2005              MOVS     r0,#5
000078  0740              LSLS     r0,r0,#29
00007a  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;479    	StopWatch_DelayMs(500);															// wait 0.5 sec
00007e  20ff              MOVS     r0,#0xff
000080  30f5              ADDS     r0,r0,#0xf5
000082  f7fffffe          BL       StopWatch_DelayMs
;;;480    	
;;;481    	Chip_UART_IntEnable(CFG_UART_PTRPERI, UART_INTEN_RXRDY);						// Enable receive data and line status interrupt
000086  2001              MOVS     r0,#1
000088  49bd              LDR      r1,|L20.896|
00008a  60c8              STR      r0,[r1,#0xc]
00008c  bf00              NOP      
;;;482    	Chip_UART_IntDisable(CFG_UART_PTRPERI, UART_INTEN_TXRDY);						// Disable transmit data interrupt for now
00008e  2004              MOVS     r0,#4
000090  6108              STR      r0,[r1,#0x10]
000092  bf00              NOP      
;;;483    	NVIC_EnableIRQ(UART0_IRQn);														// Enable IRQ
000094  2003              MOVS     r0,#3
000096  2800              CMP      r0,#0
000098  db05              BLT      |L20.166|
00009a  06c2              LSLS     r2,r0,#27
00009c  0ed2              LSRS     r2,r2,#27
00009e  2101              MOVS     r1,#1
0000a0  4091              LSLS     r1,r1,r2
0000a2  4ab8              LDR      r2,|L20.900|
0000a4  6011              STR      r1,[r2,#0]
                  |L20.166|
0000a6  bf00              NOP      
;;;484    
;;;485    	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, true );		// GREEN LED ON
0000a8  2301              MOVS     r3,#1
0000aa  2213              MOVS     r2,#0x13
0000ac  2100              MOVS     r1,#0
0000ae  2005              MOVS     r0,#5
0000b0  0740              LSLS     r0,r0,#29
0000b2  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;486    	StopWatch_DelayMs(500);															// Lit ON 0.5 sec
0000b6  20ff              MOVS     r0,#0xff
0000b8  30f5              ADDS     r0,r0,#0xf5
0000ba  f7fffffe          BL       StopWatch_DelayMs
;;;487    	
;;;488    	
;;;489    	Chip_GPIO_WritePortBit( LPC_GPIO_PORT, 0, BRD_LED_GREEN_PORTPIN, false );		// GREEN LED OFF
0000be  2300              MOVS     r3,#0
0000c0  2213              MOVS     r2,#0x13
0000c2  4619              MOV      r1,r3
0000c4  2005              MOVS     r0,#5
0000c6  0740              LSLS     r0,r0,#29
0000c8  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;490    	StopWatch_DelayMs(500);															// wait 0.5 sec
0000cc  20ff              MOVS     r0,#0xff
0000ce  30f5              ADDS     r0,r0,#0xf5
0000d0  f7fffffe          BL       StopWatch_DelayMs
;;;491    
;;;492    
;;;493    	while (1) 
0000d4  e14c              B        |L20.880|
                  |L20.214|
;;;494    	{
;;;495    		// Chip_I2CM_Xfer
;;;496    		if((App.TickCount % 100) == 0) 												// each  50ms
0000d6  48a8              LDR      r0,|L20.888|
0000d8  3810              SUBS     r0,r0,#0x10
0000da  6884              LDR      r4,[r0,#8]  ; App
0000dc  68c1              LDR      r1,[r0,#0xc]  ; App
0000de  2264              MOVS     r2,#0x64
0000e0  2300              MOVS     r3,#0
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       __aeabi_uldivmod
0000e8  2100              MOVS     r1,#0
0000ea  4608              MOV      r0,r1
0000ec  404a              EORS     r2,r2,r1
0000ee  4043              EORS     r3,r3,r0
0000f0  431a              ORRS     r2,r2,r3
0000f2  d101              BNE      |L20.248|
;;;497    		{
;;;498    			Reload_Inputs();														// Read I2C Inputs
0000f4  f7fffffe          BL       Reload_Inputs
                  |L20.248|
;;;499    		}
;;;500    				
;;;501    
;;;502    		// UART Received data process:
;;;503    		if(RingBuffer_GetCount(&App.UART_rxRing))									// some data received?
0000f8  489f              LDR      r0,|L20.888|
0000fa  68c1              LDR      r1,[r0,#0xc]
0000fc  6902              LDR      r2,[r0,#0x10]
0000fe  1a89              SUBS     r1,r1,r2
000100  2900              CMP      r1,#0
000102  d02d              BEQ      |L20.352|
;;;504    		{
;;;505    			uint8_t rxchar;
;;;506    			RingBuffer_Pop(&App.UART_rxRing, &rxchar);								// load char from RxRB
000104  4669              MOV      r1,sp
000106  f7fffffe          BL       RingBuffer_Pop
;;;507    			if(rxchar == CFG_RXCMD_ENDCHAR)											// wait for end char
00010a  4668              MOV      r0,sp
00010c  7800              LDRB     r0,[r0,#0]
00010e  2800              CMP      r0,#0
000110  d110              BNE      |L20.308|
;;;508    			{
;;;509    				LED_YELLOW_ON_TIME;													// Turn On Yellow indication LED
000112  2064              MOVS     r0,#0x64
000114  499c              LDR      r1,|L20.904|
000116  8748              STRH     r0,[r1,#0x3a]
000118  2301              MOVS     r3,#1
00011a  2212              MOVS     r2,#0x12
00011c  2100              MOVS     r1,#0
00011e  2005              MOVS     r0,#5
000120  0740              LSLS     r0,r0,#29
000122  f7fffffe          BL       Chip_GPIO_WritePortBit
;;;510    				Decode_RxCMD();														// ACTION !
000126  f7fffffe          BL       Decode_RxCMD
;;;511    				App.RxCMDLen = 0;													// Point back to start of array
00012a  2100              MOVS     r1,#0
00012c  4892              LDR      r0,|L20.888|
00012e  3030              ADDS     r0,r0,#0x30
000130  70c1              STRB     r1,[r0,#3]
000132  e014              B        |L20.350|
                  |L20.308|
;;;512    			}
;;;513    			else if(App.RxCMDLen <= CFG_RXCMD_MAXLEN) App.RxCMD[App.RxCMDLen++] = toupper(rxchar);// change to upper and store to RxCMD buff
000134  4890              LDR      r0,|L20.888|
000136  3030              ADDS     r0,r0,#0x30
000138  78c0              LDRB     r0,[r0,#3]  ; App
00013a  280b              CMP      r0,#0xb
00013c  dc0f              BGT      |L20.350|
00013e  4668              MOV      r0,sp
000140  7800              LDRB     r0,[r0,#0]
000142  f7fffffe          BL       toupper
000146  b2c1              UXTB     r1,r0
000148  488b              LDR      r0,|L20.888|
00014a  3030              ADDS     r0,r0,#0x30
00014c  78c2              LDRB     r2,[r0,#3]  ; App
00014e  78c0              LDRB     r0,[r0,#3]  ; App
000150  1c40              ADDS     r0,r0,#1
000152  b2c3              UXTB     r3,r0
000154  4888              LDR      r0,|L20.888|
000156  3030              ADDS     r0,r0,#0x30
000158  70c3              STRB     r3,[r0,#3]
00015a  3808              SUBS     r0,r0,#8
00015c  5481              STRB     r1,[r0,r2]
                  |L20.350|
;;;514    		}	
00015e  bf00              NOP      
                  |L20.352|
;;;515    		
;;;516    		
;;;517    		// Logic scanner interval checks:
;;;518    		if(App.ScanLogic_Flag)
000160  4889              LDR      r0,|L20.904|
000162  3020              ADDS     r0,r0,#0x20
000164  7fc0              LDRB     r0,[r0,#0x1f]  ; App
000166  2800              CMP      r0,#0
000168  d07b              BEQ      |L20.610|
;;;519    		{
;;;520    			App.ScanLogic_Flag = false;												// clearerr flag
00016a  2000              MOVS     r0,#0
00016c  4986              LDR      r1,|L20.904|
00016e  3120              ADDS     r1,r1,#0x20
000170  77c8              STRB     r0,[r1,#0x1f]
;;;521    		
;;;522    			for(Chnl = 0; Chnl < CFG_LOGIC_CHANNEL_COUNT; Chnl ++)					// check all 99 channels
000172  2600              MOVS     r6,#0
000174  e0bb              B        |L20.750|
                  |L20.374|
;;;523    			{
;;;524    				if(App.Logic[Chnl].Input)											// Input Active ?
000176  0131              LSLS     r1,r6,#4
000178  487f              LDR      r0,|L20.888|
00017a  3034              ADDS     r0,r0,#0x34
00017c  1808              ADDS     r0,r1,r0
00017e  7b00              LDRB     r0,[r0,#0xc]
000180  2800              CMP      r0,#0
000182  d029              BEQ      |L20.472|
;;;525    				{	
;;;526    					// Time is set? And Output still not set? Remote enabled? But Alive is not zero...
;;;527    					if((App.Logic[Chnl].PresetTime) && (App.Logic[Chnl].Output == 0) && (App.Alive_CountDown) && (App.Logic[Chnl].RemoteEnable))
000184  0131              LSLS     r1,r6,#4
000186  487c              LDR      r0,|L20.888|
000188  3034              ADDS     r0,r0,#0x34
00018a  1808              ADDS     r0,r1,r0
00018c  8840              LDRH     r0,[r0,#2]
00018e  2800              CMP      r0,#0
000190  d044              BEQ      |L20.540|
000192  0131              LSLS     r1,r6,#4
000194  4878              LDR      r0,|L20.888|
000196  3034              ADDS     r0,r0,#0x34
000198  1808              ADDS     r0,r1,r0
00019a  7b40              LDRB     r0,[r0,#0xd]
00019c  2800              CMP      r0,#0
00019e  d13d              BNE      |L20.540|
0001a0  4879              LDR      r0,|L20.904|
0001a2  8ec0              LDRH     r0,[r0,#0x36]  ; App
0001a4  2800              CMP      r0,#0
0001a6  d039              BEQ      |L20.540|
0001a8  0131              LSLS     r1,r6,#4
0001aa  4873              LDR      r0,|L20.888|
0001ac  3034              ADDS     r0,r0,#0x34
0001ae  1808              ADDS     r0,r1,r0
0001b0  7900              LDRB     r0,[r0,#4]
0001b2  2800              CMP      r0,#0
0001b4  d032              BEQ      |L20.540|
;;;528    					{
;;;529    						App.Logic[Chnl].OnTime = 0;									// Reset OnTime OnTime
0001b6  2100              MOVS     r1,#0
0001b8  0132              LSLS     r2,r6,#4
0001ba  486f              LDR      r0,|L20.888|
0001bc  3034              ADDS     r0,r0,#0x34
0001be  1810              ADDS     r0,r2,r0
0001c0  6081              STR      r1,[r0,#8]
;;;530    						App.Logic[Chnl].Output = 1;									// Yes, switch ON relay and start counting
0001c2  2101              MOVS     r1,#1
0001c4  0132              LSLS     r2,r6,#4
0001c6  486c              LDR      r0,|L20.888|
0001c8  3034              ADDS     r0,r0,#0x34
0001ca  1810              ADDS     r0,r2,r0
0001cc  7341              STRB     r1,[r0,#0xd]
;;;531    						App.Write_Output = true;									// Request for update MCP23008 Output pins
0001ce  2001              MOVS     r0,#1
0001d0  496d              LDR      r1,|L20.904|
0001d2  3120              ADDS     r1,r1,#0x20
0001d4  7508              STRB     r0,[r1,#0x14]
0001d6  e021              B        |L20.540|
                  |L20.472|
;;;532    					}
;;;533    				}
;;;534    				else																// pin deactivated
;;;535    				{
;;;536    					// STOPPER: PIN Deactivated
;;;537    					if((App.Logic[Chnl].PresetTime) && (App.Logic[Chnl].Output))	// Time was set? Output Activated?
0001d8  0131              LSLS     r1,r6,#4
0001da  4867              LDR      r0,|L20.888|
0001dc  3034              ADDS     r0,r0,#0x34
0001de  1808              ADDS     r0,r1,r0
0001e0  8840              LDRH     r0,[r0,#2]
0001e2  2800              CMP      r0,#0
0001e4  d01a              BEQ      |L20.540|
0001e6  0131              LSLS     r1,r6,#4
0001e8  4863              LDR      r0,|L20.888|
0001ea  3034              ADDS     r0,r0,#0x34
0001ec  1808              ADDS     r0,r1,r0
0001ee  7b40              LDRB     r0,[r0,#0xd]
0001f0  2800              CMP      r0,#0
0001f2  d013              BEQ      |L20.540|
;;;538    					{
;;;539    						App.Logic[Chnl].Output = 0;									// Yes, switch OFF relay and stop counting
0001f4  2100              MOVS     r1,#0
0001f6  0132              LSLS     r2,r6,#4
0001f8  485f              LDR      r0,|L20.888|
0001fa  3034              ADDS     r0,r0,#0x34
0001fc  1810              ADDS     r0,r2,r0
0001fe  7341              STRB     r1,[r0,#0xd]
;;;540    						App.Logic[Chnl].PresetTime = 0;								// clear also Preset time.
000200  0132              LSLS     r2,r6,#4
000202  485d              LDR      r0,|L20.888|
000204  3034              ADDS     r0,r0,#0x34
000206  1810              ADDS     r0,r2,r0
000208  8041              STRH     r1,[r0,#2]
;;;541    						App.Logic[Chnl].RemoteEnable = false;						// Clear remote enable flag
00020a  0132              LSLS     r2,r6,#4
00020c  485a              LDR      r0,|L20.888|
00020e  3034              ADDS     r0,r0,#0x34
000210  1810              ADDS     r0,r2,r0
000212  7101              STRB     r1,[r0,#4]
;;;542    						App.Write_Output = true;									// Request for update MCP23008 Output pins
000214  2001              MOVS     r0,#1
000216  495c              LDR      r1,|L20.904|
000218  3120              ADDS     r1,r1,#0x20
00021a  7508              STRB     r0,[r1,#0x14]
                  |L20.540|
;;;543    					}
;;;544    				}
;;;545    
;;;546    				// STOPPER: Reached Preset time?
;;;547    				if(App.Logic[Chnl].OnTime == (App.Logic[Chnl].PresetTime*(CFG_SYSTICKRATE_HZ/CFG_APP_SCANLOGICRATE_HZ)))
00021c  0131              LSLS     r1,r6,#4
00021e  4856              LDR      r0,|L20.888|
000220  3034              ADDS     r0,r0,#0x34
000222  1808              ADDS     r0,r1,r0
000224  0132              LSLS     r2,r6,#4
000226  6881              LDR      r1,[r0,#8]
000228  4853              LDR      r0,|L20.888|
00022a  3034              ADDS     r0,r0,#0x34
00022c  1810              ADDS     r0,r2,r0
00022e  8840              LDRH     r0,[r0,#2]
000230  2264              MOVS     r2,#0x64
000232  4350              MULS     r0,r2,r0
000234  4281              CMP      r1,r0
000236  d115              BNE      |L20.612|
;;;548    				{
;;;549    					App.Logic[Chnl].Output = 0;										// Yes, switch Off relay and stop counting
000238  2100              MOVS     r1,#0
00023a  0132              LSLS     r2,r6,#4
00023c  484e              LDR      r0,|L20.888|
00023e  3034              ADDS     r0,r0,#0x34
000240  1810              ADDS     r0,r2,r0
000242  7341              STRB     r1,[r0,#0xd]
;;;550    					App.Logic[Chnl].PresetTime = 0;									// clear also Preset time.
000244  0132              LSLS     r2,r6,#4
000246  484c              LDR      r0,|L20.888|
000248  3034              ADDS     r0,r0,#0x34
00024a  1810              ADDS     r0,r2,r0
00024c  8041              STRH     r1,[r0,#2]
;;;551    					App.Logic[Chnl].RemoteEnable = false;							// Clear remote enable flag
00024e  0132              LSLS     r2,r6,#4
000250  4849              LDR      r0,|L20.888|
000252  3034              ADDS     r0,r0,#0x34
000254  1810              ADDS     r0,r2,r0
000256  7101              STRB     r1,[r0,#4]
;;;552    					App.Write_Output = true;										// Request for update MCP23008 Output pins
000258  2001              MOVS     r0,#1
00025a  494b              LDR      r1,|L20.904|
00025c  3120              ADDS     r1,r1,#0x20
00025e  7508              STRB     r0,[r1,#0x14]
000260  e010              B        |L20.644|
                  |L20.610|
000262  e047              B        |L20.756|
                  |L20.612|
;;;553    				}
;;;554    				else App.Logic[Chnl].OnTime += App.Logic[Chnl].Output;				// No, If Output enabled, Counting OnTime Upp by 1.
000264  0131              LSLS     r1,r6,#4
000266  4844              LDR      r0,|L20.888|
000268  3034              ADDS     r0,r0,#0x34
00026a  1808              ADDS     r0,r1,r0
00026c  0132              LSLS     r2,r6,#4
00026e  6881              LDR      r1,[r0,#8]
000270  4841              LDR      r0,|L20.888|
000272  3034              ADDS     r0,r0,#0x34
000274  1810              ADDS     r0,r2,r0
000276  7b40              LDRB     r0,[r0,#0xd]
000278  1809              ADDS     r1,r1,r0
00027a  0132              LSLS     r2,r6,#4
00027c  483e              LDR      r0,|L20.888|
00027e  3034              ADDS     r0,r0,#0x34
000280  1810              ADDS     r0,r2,r0
000282  6081              STR      r1,[r0,#8]
                  |L20.644|
;;;555    
;;;556    				
;;;557    				// STOPPER: OFF Command
;;;558    				if(App.Logic[Chnl].RemoteEnable == false)							// Alive CountDown reached?
000284  0131              LSLS     r1,r6,#4
000286  483c              LDR      r0,|L20.888|
000288  3034              ADDS     r0,r0,#0x34
00028a  1808              ADDS     r0,r1,r0
00028c  7900              LDRB     r0,[r0,#4]
00028e  2800              CMP      r0,#0
000290  d113              BNE      |L20.698|
;;;559    				{
;;;560    					App.Logic[Chnl].Output = 0;										// Yes, switch OFF relay and stop counting
000292  2100              MOVS     r1,#0
000294  0132              LSLS     r2,r6,#4
000296  4838              LDR      r0,|L20.888|
000298  3034              ADDS     r0,r0,#0x34
00029a  1810              ADDS     r0,r2,r0
00029c  7341              STRB     r1,[r0,#0xd]
;;;561    					App.Logic[Chnl].PresetTime = 0;									// clear also Preset time.
00029e  0132              LSLS     r2,r6,#4
0002a0  4835              LDR      r0,|L20.888|
0002a2  3034              ADDS     r0,r0,#0x34
0002a4  1810              ADDS     r0,r2,r0
0002a6  8041              STRH     r1,[r0,#2]
;;;562    					App.Logic[Chnl].RemoteEnable = false;							// Clear remote enable flag
0002a8  0132              LSLS     r2,r6,#4
0002aa  4833              LDR      r0,|L20.888|
0002ac  3034              ADDS     r0,r0,#0x34
0002ae  1810              ADDS     r0,r2,r0
0002b0  7101              STRB     r1,[r0,#4]
;;;563    					
;;;564    					App.Write_Output = true;										// Request for update MCP23008 Output pins
0002b2  2001              MOVS     r0,#1
0002b4  4934              LDR      r1,|L20.904|
0002b6  3120              ADDS     r1,r1,#0x20
0002b8  7508              STRB     r0,[r1,#0x14]
                  |L20.698|
;;;565    				}
;;;566    				
;;;567    				// STOPPER: Alive timer
;;;568    				if(App.Alive_CountDown == 0)										// Alive CountDown reached?
0002ba  4833              LDR      r0,|L20.904|
0002bc  8ec0              LDRH     r0,[r0,#0x36]  ; App
0002be  2800              CMP      r0,#0
0002c0  d113              BNE      |L20.746|
;;;569    				{
;;;570    					App.Logic[Chnl].Output = 0;										// Yes, switch OFF relay and stop counting
0002c2  2100              MOVS     r1,#0
0002c4  0132              LSLS     r2,r6,#4
0002c6  482c              LDR      r0,|L20.888|
0002c8  3034              ADDS     r0,r0,#0x34
0002ca  1810              ADDS     r0,r2,r0
0002cc  7341              STRB     r1,[r0,#0xd]
;;;571    					App.Logic[Chnl].PresetTime = 0;									// clear also Preset time.
0002ce  0132              LSLS     r2,r6,#4
0002d0  4829              LDR      r0,|L20.888|
0002d2  3034              ADDS     r0,r0,#0x34
0002d4  1810              ADDS     r0,r2,r0
0002d6  8041              STRH     r1,[r0,#2]
;;;572    					App.Logic[Chnl].RemoteEnable = false;							// Clear remote enable flag
0002d8  0132              LSLS     r2,r6,#4
0002da  4827              LDR      r0,|L20.888|
0002dc  3034              ADDS     r0,r0,#0x34
0002de  1810              ADDS     r0,r2,r0
0002e0  7101              STRB     r1,[r0,#4]
;;;573    					
;;;574    					App.Write_Output = true;										// Request for update MCP23008 Output pins
0002e2  2001              MOVS     r0,#1
0002e4  4928              LDR      r1,|L20.904|
0002e6  3120              ADDS     r1,r1,#0x20
0002e8  7508              STRB     r0,[r1,#0x14]
                  |L20.746|
0002ea  1c70              ADDS     r0,r6,#1              ;522
0002ec  b2c6              UXTB     r6,r0                 ;522
                  |L20.750|
0002ee  2e63              CMP      r6,#0x63              ;522
0002f0  da00              BGE      |L20.756|
0002f2  e740              B        |L20.374|
                  |L20.756|
;;;575    				}				
;;;576    			}
;;;577    		}
;;;578    
;;;579    
;;;580    		
;;;581    		// One Second Interval:		
;;;582    		if(App.Second_Flag)
0002f4  4824              LDR      r0,|L20.904|
0002f6  3020              ADDS     r0,r0,#0x20
0002f8  7f80              LDRB     r0,[r0,#0x1e]  ; App
0002fa  2800              CMP      r0,#0
0002fc  d00d              BEQ      |L20.794|
;;;583    		{
;;;584    			// Alive timer reached 0. All Outputs have to switch OFF
;;;585    			// This is a higher priority settings.
;;;586    			if(App.Alive_CountDown) App.Alive_CountDown--;							// decrease if can...
0002fe  4822              LDR      r0,|L20.904|
000300  8ec0              LDRH     r0,[r0,#0x36]  ; App
000302  2800              CMP      r0,#0
000304  d005              BEQ      |L20.786|
000306  4820              LDR      r0,|L20.904|
000308  8ec0              LDRH     r0,[r0,#0x36]  ; App
00030a  1e40              SUBS     r0,r0,#1
00030c  b281              UXTH     r1,r0
00030e  481e              LDR      r0,|L20.904|
000310  86c1              STRH     r1,[r0,#0x36]
                  |L20.786|
;;;587    			App.Second_Flag = false;
000312  2000              MOVS     r0,#0
000314  491c              LDR      r1,|L20.904|
000316  3120              ADDS     r1,r1,#0x20
000318  7788              STRB     r0,[r1,#0x1e]
                  |L20.794|
;;;588    	
;;;589    			//Chip_GPIO_SetPinToggle( LPC_GPIO_PORT, 0, BRD_LED_YELLOW_PORTPIN);		// RUN indicator
;;;590    		}
;;;591    
;;;592    		if(App.GreenLed_Off) LED_GREEN_OFF;
00031a  481b              LDR      r0,|L20.904|
00031c  3020              ADDS     r0,r0,#0x20
00031e  7f40              LDRB     r0,[r0,#0x1d]  ; App
000320  2800              CMP      r0,#0
000322  d00a              BEQ      |L20.826|
000324  2300              MOVS     r3,#0
000326  2213              MOVS     r2,#0x13
000328  4619              MOV      r1,r3
00032a  2005              MOVS     r0,#5
00032c  0740              LSLS     r0,r0,#29
00032e  f7fffffe          BL       Chip_GPIO_WritePortBit
000332  2000              MOVS     r0,#0
000334  4914              LDR      r1,|L20.904|
000336  3120              ADDS     r1,r1,#0x20
000338  7748              STRB     r0,[r1,#0x1d]
                  |L20.826|
;;;593    		if(App.YellowLed_Off) LED_YELLOW_OFF;
00033a  4813              LDR      r0,|L20.904|
00033c  3020              ADDS     r0,r0,#0x20
00033e  7f00              LDRB     r0,[r0,#0x1c]  ; App
000340  2800              CMP      r0,#0
000342  d00a              BEQ      |L20.858|
000344  2300              MOVS     r3,#0
000346  2212              MOVS     r2,#0x12
000348  4619              MOV      r1,r3
00034a  2005              MOVS     r0,#5
00034c  0740              LSLS     r0,r0,#29
00034e  f7fffffe          BL       Chip_GPIO_WritePortBit
000352  2000              MOVS     r0,#0
000354  490c              LDR      r1,|L20.904|
000356  3120              ADDS     r1,r1,#0x20
000358  7708              STRB     r0,[r1,#0x1c]
                  |L20.858|
;;;594    		
;;;595    		
;;;596    		if(App.Write_Output) 													// Write I2C Outputs
00035a  480b              LDR      r0,|L20.904|
00035c  3020              ADDS     r0,r0,#0x20
00035e  7d00              LDRB     r0,[r0,#0x14]  ; App
000360  2800              CMP      r0,#0
000362  d005              BEQ      |L20.880|
;;;597    		{
;;;598    			Rewrite_Outputs();													// Put into MCP23008
000364  f7fffffe          BL       Rewrite_Outputs
;;;599    			App.Write_Output = false;											// clear request flag
000368  2000              MOVS     r0,#0
00036a  4907              LDR      r1,|L20.904|
00036c  3120              ADDS     r1,r1,#0x20
00036e  7508              STRB     r0,[r1,#0x14]
                  |L20.880|
000370  e6b1              B        |L20.214|
;;;600    		}
;;;601    		
;;;602    	}	// End While(1)
;;;603    } 		// End main()
                          ENDP

000372  0000              DCW      0x0000
                  |L20.884|
                          DCD      rxbuff
                  |L20.888|
                          DCD      App+0x10
                  |L20.892|
                          DCD      txbuff
                  |L20.896|
                          DCD      0x40064000
                  |L20.900|
                          DCD      0xe000e100
                  |L20.904|
                          DCD      App+0x640

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  App
                          %        1664
                  rxbuff
                          %        64
                  txbuff
                          %        64
                  I2CXfer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  tmpTxBuff
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_ee5e2dae____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___6_main_c_ee5e2dae____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_ee5e2dae____REVSH|
#line 480
|__asm___6_main_c_ee5e2dae____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
