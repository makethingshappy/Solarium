; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\iap.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\iap.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\iap.crf lpc_chip_82x\src\iap.c]
                          THUMB

                          AREA ||i.Chip_IAP_BlankCheckSector||, CODE, READONLY, ALIGN=1

                  Chip_IAP_BlankCheckSector PROC
;;;92     /* Blank check sector */
;;;93     uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector)
000000  b530              PUSH     {r4,r5,lr}
;;;94     {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;95     	uint32_t command[5], result[5];
;;;96     
;;;97     	command[0] = IAP_BLANK_CHECK_SECTOR_CMD;
000008  2035              MOVS     r0,#0x35
00000a  9006              STR      r0,[sp,#0x18]
;;;98     	command[1] = strSector;
00000c  9407              STR      r4,[sp,#0x1c]
;;;99     	command[2] = endSector;
00000e  9508              STR      r5,[sp,#0x20]
;;;100    	iap_entry(command, result);
000010  a901              ADD      r1,sp,#4
000012  a806              ADD      r0,sp,#0x18
000014  f7fffffe          BL       iap_entry
;;;101    
;;;102    	return result[0];
000018  9801              LDR      r0,[sp,#4]
00001a  b2c0              UXTB     r0,r0
;;;103    }
00001c  b00b              ADD      sp,sp,#0x2c
00001e  bd30              POP      {r4,r5,pc}
;;;104    
                          ENDP


                          AREA ||i.Chip_IAP_Compare||, CODE, READONLY, ALIGN=1

                  Chip_IAP_Compare PROC
;;;127    /* IAP compare */
;;;128    uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp)
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;130    	uint32_t command[5], result[5];
;;;131    
;;;132    	command[0] = IAP_COMPARE_CMD;
00000a  2038              MOVS     r0,#0x38
00000c  9005              STR      r0,[sp,#0x14]
;;;133    	command[1] = dstAdd;
00000e  9406              STR      r4,[sp,#0x18]
;;;134    	command[2] = srcAdd;
000010  9507              STR      r5,[sp,#0x1c]
;;;135    	command[3] = bytescmp;
000012  9608              STR      r6,[sp,#0x20]
;;;136    	iap_entry(command, result);
000014  4669              MOV      r1,sp
000016  a805              ADD      r0,sp,#0x14
000018  f7fffffe          BL       iap_entry
;;;137    
;;;138    	return result[0];
00001c  9800              LDR      r0,[sp,#0]
00001e  b2c0              UXTB     r0,r0
;;;139    }
000020  b00a              ADD      sp,sp,#0x28
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.Chip_IAP_CopyRamToFlash||, CODE, READONLY, ALIGN=2

                  Chip_IAP_CopyRamToFlash PROC
;;;63     /* Copy RAM to flash */
;;;64     uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt)
000000  b570              PUSH     {r4-r6,lr}
;;;65     {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;66     	uint32_t command[5], result[5];
;;;67     
;;;68     	command[0] = IAP_WRISECTOR_CMD;
00000a  2033              MOVS     r0,#0x33
00000c  9005              STR      r0,[sp,#0x14]
;;;69     	command[1] = dstAdd;
00000e  9406              STR      r4,[sp,#0x18]
;;;70     	command[2] = (uint32_t) srcAdd;
000010  9507              STR      r5,[sp,#0x1c]
;;;71     	command[3] = byteswrt;
000012  9608              STR      r6,[sp,#0x20]
;;;72     	command[4] = SystemCoreClock / 1000;
000014  217d              MOVS     r1,#0x7d
000016  00c9              LSLS     r1,r1,#3
000018  4806              LDR      r0,|L3.52|
00001a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  9009              STR      r0,[sp,#0x24]
;;;73     	iap_entry(command, result);
000022  4669              MOV      r1,sp
000024  a805              ADD      r0,sp,#0x14
000026  f7fffffe          BL       iap_entry
;;;74     
;;;75     	return result[0];
00002a  9800              LDR      r0,[sp,#0]
00002c  b2c0              UXTB     r0,r0
;;;76     }
00002e  b00a              ADD      sp,sp,#0x28
000030  bd70              POP      {r4-r6,pc}
;;;77     
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      SystemCoreClock

                          AREA ||i.Chip_IAP_ErasePage||, CODE, READONLY, ALIGN=2

                  Chip_IAP_ErasePage PROC
;;;167    /* Erase page */
;;;168    uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage)
000000  b530              PUSH     {r4,r5,lr}
;;;169    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;170    	uint32_t command[5], result[5];
;;;171    
;;;172    	command[0] = IAP_ERASE_PAGE_CMD;
000008  203b              MOVS     r0,#0x3b
00000a  9006              STR      r0,[sp,#0x18]
;;;173    	command[1] = strPage;
00000c  9407              STR      r4,[sp,#0x1c]
;;;174    	command[2] = endPage;
00000e  9508              STR      r5,[sp,#0x20]
;;;175    	command[3] = SystemCoreClock / 1000;
000010  217d              MOVS     r1,#0x7d
000012  00c9              LSLS     r1,r1,#3
000014  4806              LDR      r0,|L4.48|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  9009              STR      r0,[sp,#0x24]
;;;176    	iap_entry(command, result);
00001e  a901              ADD      r1,sp,#4
000020  a806              ADD      r0,sp,#0x18
000022  f7fffffe          BL       iap_entry
;;;177    
;;;178    	return result[0];
000026  9801              LDR      r0,[sp,#4]
000028  b2c0              UXTB     r0,r0
;;;179    }
00002a  b00b              ADD      sp,sp,#0x2c
00002c  bd30              POP      {r4,r5,pc}
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      SystemCoreClock

                          AREA ||i.Chip_IAP_EraseSector||, CODE, READONLY, ALIGN=2

                  Chip_IAP_EraseSector PROC
;;;78     /* Erase sector */
;;;79     uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector)
000000  b530              PUSH     {r4,r5,lr}
;;;80     {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;81     	uint32_t command[5], result[5];
;;;82     
;;;83     	command[0] = IAP_ERSSECTOR_CMD;
000008  2034              MOVS     r0,#0x34
00000a  9006              STR      r0,[sp,#0x18]
;;;84     	command[1] = strSector;
00000c  9407              STR      r4,[sp,#0x1c]
;;;85     	command[2] = endSector;
00000e  9508              STR      r5,[sp,#0x20]
;;;86     	command[3] = SystemCoreClock / 1000;
000010  217d              MOVS     r1,#0x7d
000012  00c9              LSLS     r1,r1,#3
000014  4806              LDR      r0,|L5.48|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  9009              STR      r0,[sp,#0x24]
;;;87     	iap_entry(command, result);
00001e  a901              ADD      r1,sp,#4
000020  a806              ADD      r0,sp,#0x18
000022  f7fffffe          BL       iap_entry
;;;88     
;;;89     	return result[0];
000026  9801              LDR      r0,[sp,#4]
000028  b2c0              UXTB     r0,r0
;;;90     }
00002a  b00b              ADD      sp,sp,#0x2c
00002c  bd30              POP      {r4,r5,pc}
;;;91     
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      SystemCoreClock

                          AREA ||i.Chip_IAP_PreSectorForReadWrite||, CODE, READONLY, ALIGN=1

                  Chip_IAP_PreSectorForReadWrite PROC
;;;50     /* Prepare sector for write operation */
;;;51     uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector)
000000  b530              PUSH     {r4,r5,lr}
;;;52     {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;53     	uint32_t command[5], result[5];
;;;54     
;;;55     	command[0] = IAP_PREWRRITE_CMD;
000008  2032              MOVS     r0,#0x32
00000a  9006              STR      r0,[sp,#0x18]
;;;56     	command[1] = strSector;
00000c  9407              STR      r4,[sp,#0x1c]
;;;57     	command[2] = endSector;
00000e  9508              STR      r5,[sp,#0x20]
;;;58     	iap_entry(command, result);
000010  a901              ADD      r1,sp,#4
000012  a806              ADD      r0,sp,#0x18
000014  f7fffffe          BL       iap_entry
;;;59     
;;;60     	return result[0];
000018  9801              LDR      r0,[sp,#4]
00001a  b2c0              UXTB     r0,r0
;;;61     }
00001c  b00b              ADD      sp,sp,#0x2c
00001e  bd30              POP      {r4,r5,pc}
;;;62     
                          ENDP


                          AREA ||i.Chip_IAP_ReadBootCode||, CODE, READONLY, ALIGN=1

                  Chip_IAP_ReadBootCode PROC
;;;116    /* Read boot code version number */
;;;117    uint32_t Chip_IAP_ReadBootCode(void)
000000  b500              PUSH     {lr}
;;;118    {
000002  b08b              SUB      sp,sp,#0x2c
;;;119    	uint32_t command[5], result[5];
;;;120    
;;;121    	command[0] = IAP_READ_BOOT_CODE_CMD;
000004  2037              MOVS     r0,#0x37
000006  9006              STR      r0,[sp,#0x18]
;;;122    	iap_entry(command, result);
000008  a901              ADD      r1,sp,#4
00000a  a806              ADD      r0,sp,#0x18
00000c  f7fffffe          BL       iap_entry
;;;123    
;;;124    	return result[1] & 0xffff;
000010  9802              LDR      r0,[sp,#8]
000012  b280              UXTH     r0,r0
;;;125    }
000014  b00b              ADD      sp,sp,#0x2c
000016  bd00              POP      {pc}
;;;126    
                          ENDP


                          AREA ||i.Chip_IAP_ReadPID||, CODE, READONLY, ALIGN=1

                  Chip_IAP_ReadPID PROC
;;;105    /* Read part identification number */
;;;106    uint32_t Chip_IAP_ReadPID(void)
000000  b500              PUSH     {lr}
;;;107    {
000002  b08b              SUB      sp,sp,#0x2c
;;;108    	uint32_t command[5], result[5];
;;;109    
;;;110    	command[0] = IAP_REPID_CMD;
000004  2036              MOVS     r0,#0x36
000006  9006              STR      r0,[sp,#0x18]
;;;111    	iap_entry(command, result);
000008  a901              ADD      r1,sp,#4
00000a  a806              ADD      r0,sp,#0x18
00000c  f7fffffe          BL       iap_entry
;;;112    
;;;113    	return result[1];
000010  9802              LDR      r0,[sp,#8]
;;;114    }
000012  b00b              ADD      sp,sp,#0x2c
000014  bd00              POP      {pc}
;;;115    
                          ENDP


                          AREA ||i.Chip_IAP_ReadUID||, CODE, READONLY, ALIGN=1

                  Chip_IAP_ReadUID PROC
;;;152    /* Read the unique ID */
;;;153    uint32_t Chip_IAP_ReadUID(uint32_t* uid)
000000  b530              PUSH     {r4,r5,lr}
;;;154    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4605              MOV      r5,r0
;;;155    	uint32_t command[5], result[5];
;;;156    	uint32_t i;
;;;157    	
;;;158    	command[0] = IAP_READ_UID_CMD;
000006  203a              MOVS     r0,#0x3a
000008  9006              STR      r0,[sp,#0x18]
;;;159    	iap_entry(command, result);
00000a  a901              ADD      r1,sp,#4
00000c  a806              ADD      r0,sp,#0x18
00000e  f7fffffe          BL       iap_entry
;;;160    
;;;161    	for (i=0; i<4; i++)
000012  2400              MOVS     r4,#0
000014  e006              B        |L9.36|
                  |L9.22|
;;;162    		*(uid+i) = result[i+1];
000016  1c60              ADDS     r0,r4,#1
000018  0080              LSLS     r0,r0,#2
00001a  a901              ADD      r1,sp,#4
00001c  5808              LDR      r0,[r1,r0]
00001e  00a1              LSLS     r1,r4,#2
000020  5068              STR      r0,[r5,r1]
000022  1c64              ADDS     r4,r4,#1              ;161
                  |L9.36|
000024  2c04              CMP      r4,#4                 ;161
000026  d3f6              BCC      |L9.22|
;;;163    	
;;;164    	return result[0];
000028  9801              LDR      r0,[sp,#4]
;;;165    }
00002a  b00b              ADD      sp,sp,#0x2c
00002c  bd30              POP      {r4,r5,pc}
;;;166    
                          ENDP


                          AREA ||i.Chip_IAP_ReinvokeISP||, CODE, READONLY, ALIGN=1

                  Chip_IAP_ReinvokeISP PROC
;;;141    /* Reinvoke ISP */
;;;142    uint8_t Chip_IAP_ReinvokeISP(void)
000000  b500              PUSH     {lr}
;;;143    {
000002  b08b              SUB      sp,sp,#0x2c
;;;144    	uint32_t command[5], result[5];
;;;145    
;;;146    	command[0] = IAP_REINVOKE_ISP_CMD;
000004  2039              MOVS     r0,#0x39
000006  9006              STR      r0,[sp,#0x18]
;;;147    	iap_entry(command, result);
000008  a901              ADD      r1,sp,#4
00000a  a806              ADD      r0,sp,#0x18
00000c  f7fffffe          BL       iap_entry
;;;148    
;;;149    	return result[0];
000010  9801              LDR      r0,[sp,#4]
000012  b2c0              UXTB     r0,r0
;;;150    }
000014  b00b              ADD      sp,sp,#0x2c
000016  bd00              POP      {pc}
;;;151    
                          ENDP


                          AREA ||i.iap_entry||, CODE, READONLY, ALIGN=2

                  iap_entry PROC
;;;82      */
;;;83     static INLINE void iap_entry(unsigned int cmd_param[], unsigned int status_result[])
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;85     	((IAP_ENTRY_T) IAP_ENTRY_LOCATION)(cmd_param, status_result);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  4a01              LDR      r2,|L11.16|
00000c  4790              BLX      r2
;;;86     }
00000e  bd70              POP      {r4-r6,pc}
;;;87     
                          ENDP

                  |L11.16|
                          DCD      0x1fff1ff1

;*** Start embedded assembler ***

#line 1 "lpc_chip_82x\\src\\iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_ec493fae____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___5_iap_c_ec493fae____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_iap_c_ec493fae____REVSH|
#line 480
|__asm___5_iap_c_ec493fae____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
