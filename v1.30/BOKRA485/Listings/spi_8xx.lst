L 1 "lpc_chip_82x\src\spi_8xx.c"
N/*
N * @brief LPC8xx SPI driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#include "chip.h"
L 1 ".\lpc_chip_82x\inc\chip.h" 1
N/*
N * @brief LPC8xx basic chip inclusion file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CHIP_H_
N#define __CHIP_H_
N
N#include "lpc_types.h"
L 1 ".\lpc_chip_82x\inc\lpc_types.h" 1
N/*
N * @brief Common types used in LPC functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __LPC_TYPES_H_
N#define __LPC_TYPES_H_
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 36 ".\lpc_chip_82x\inc\lpc_types.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060016
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 37 ".\lpc_chip_82x\inc\lpc_types.h" 2
N
N/** @defgroup LPC_Types CHIP: LPC Common Types
N * @ingroup CHIP_Common
N * @{
N */
N
N/** @defgroup LPC_Types_Public_Types LPC Public Types
N * @{
N */
N
N/**
N * @brief Boolean Type definition
N */
Ntypedef enum {FALSE = 0, TRUE = !FALSE} Bool;
N
N/**
N * @brief Boolean Type definition
N */
N#if !defined(__cplusplus)
X#if !0L
N// typedef enum {false = 0, true = !false} bool;
N#endif
N
N/**
N * @brief Flag Status and Interrupt Flag Status type definition
N */
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
N#define PARAM_SETSTATE(State) ((State == RESET) || (State == SET))
N
N/**
N * @brief Functional State Definition
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define PARAM_FUNCTIONALSTATE(State) ((State == DISABLE) || (State == ENABLE))
N
N/**
N * @ Status type definition
N */
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
N
N/**
N * Read/Write transfer type mode (Block or non-block)
N */
Ntypedef enum {
N	NONE_BLOCKING = 0,		/**< None Blocking type */
N	BLOCKING,				/**< Blocking type */
N} TRANSFER_BLOCK_T;
N
N/** Pointer to Function returning Void (any number of parameters) */
Ntypedef void (*PFV)();
N
N/** Pointer to Function returning int32_t (any number of parameters) */
Ntypedef int32_t (*PFI)();
N
N/**
N * @}
N */
N
N/** @defgroup LPC_Types_Public_Macros  LPC Public Macros
N * @{
N */
N
N/* _BIT(n) sets the bit at position "n"
N * _BIT(n) is intended to be used in "OR" and "AND" expressions:
N * e.g., "(_BIT(3) | _BIT(7))".
N */
N#undef _BIT
N/* Set bit macro */
N#define _BIT(n) (1 << (n))
N
N/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
N * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
N * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
N */
N#undef _SBF
N/* Set bit field macro */
N#define _SBF(f, v) ((v) << (f))
N
N/* _BITMASK constructs a symbol with 'field_width' least significant
N * bits set.
N * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
N * The symbol is intended to be used to limit the bit field width
N * thusly:
N * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
N * If "any_expression" results in a value that is larger than can be
N * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
N * used with the _SBF example above, the example would be written:
N * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
N * This ensures that the value written to a_reg is no wider than
N * 16 bits, and makes the code easier to read and understand.
N */
N#undef _BITMASK
N/* Bitmask creation macro */
N#define _BITMASK(field_width) ( _BIT(field_width) - 1)
N
N/* NULL pointer */
N#ifndef NULL
N#define NULL ((void *) 0)
N#endif
N
N/* Number of elements in an array */
N#define NELEMENTS(array)  (sizeof(array) / sizeof(array[0]))
N
N/* Static data/function define */
N#define STATIC static
N/* External data/function define */
N#define EXTERN extern
N
N#if !defined(MAX)
X#if !0L
N#define MAX(a, b) (((a) > (b)) ? (a) : (b))
N#endif
N#if !defined(MIN)
X#if !0L
N#define MIN(a, b) (((a) < (b)) ? (a) : (b))
N#endif
N
N/**
N * @}
N */
N
N/* Old Type Definition compatibility */
N/** @addtogroup LPC_Types_Public_Types
N * @{
N */
N
N/** LPC type for character type */
Ntypedef char CHAR;
N
N/** LPC type for 8 bit unsigned value */
Ntypedef uint8_t UNS_8;
N
N/** LPC type for 8 bit signed value */
Ntypedef int8_t INT_8;
N
N/** LPC type for 16 bit unsigned value */
Ntypedef uint16_t UNS_16;
N
N/** LPC type for 16 bit signed value */
Ntypedef int16_t INT_16;
N
N/** LPC type for 32 bit unsigned value */
Ntypedef uint32_t UNS_32;
N
N/** LPC type for 32 bit signed value */
Ntypedef int32_t INT_32;
N
N/** LPC type for 64 bit signed value */
Ntypedef int64_t INT_64;
N
N/** LPC type for 64 bit unsigned value */
Ntypedef uint64_t UNS_64;
N
N#ifdef __CODE_RED
S#define BOOL_32 bool
S#define BOOL_16 bool
S#define BOOL_8  bool
N#else
N/** 32 bit boolean type */
Ntypedef bool BOOL_32;
Xtypedef _Bool BOOL_32;
N
N/** 16 bit boolean type */
Ntypedef bool BOOL_16;
Xtypedef _Bool BOOL_16;
N
N/** 8 bit boolean type */
Ntypedef bool BOOL_8;
Xtypedef _Bool BOOL_8;
N#endif
N
N#ifdef __CC_ARM
N#define INLINE  __inline
N#else
S#define INLINE inline
N#endif
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#endif /* __LPC_TYPES_H_ */
L 36 ".\lpc_chip_82x\inc\chip.h" 2
N#include "sys_config.h"
L 1 ".\lpc_chip_82x\inc\sys_config.h" 1
N/*
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SYS_CONFIG_H_
N#define __SYS_CONFIG_H_
N
N/* Build for LPC8XX chip family */
N#define CHIP_LPC8XX
N#define CHIP_LPC82X
N
N#endif /* __SYS_CONFIG_H_ */
L 37 ".\lpc_chip_82x\inc\chip.h" 2
N#include "cmsis.h"
L 1 ".\lpc_chip_82x\inc\cmsis.h" 1
N/*
N * @brief Basic CMSIS include file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CMSIS_H_
N#define __CMSIS_H_
N
N#include "lpc_types.h"
N#include "sys_config.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CMSIS_8XX_ALL CHIP: LPC8xx CMSIS include file
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N// Kill warning "#pragma push with no matching #pragma pop"
N  #pragma diag_suppress 2525
N//  #pragma push
N  #pragma anon_unions
N#elif defined(__CWCC__)
S  #pragma push
S  #pragma cpp_extensions on
S#elif defined(__GNUC__)
S/* anonymous unions are enabled by default */
S#elif defined(__IAR_SYSTEMS_ICC__)
S//  #pragma push // FIXME not usable for IAR
S  #pragma language=extended
S#else
S  #error Not supported compiler type
N#endif
N
N#if !defined(CORE_M0PLUS)
X#if !1L
S#error Please #define CORE_M0PLUS
N#endif
N
N/** @defgroup CMSIS_8XX CHIP: LPC8xx Cortex CMSIS definitions
N * @ingroup CMSIS_8XX_ALL
N * @{
N */
N
N/* Configuration of the Cortex-M0+ Processor and Core Peripherals */
N#define __CM0PLUS_REV             0x0001	/*!< Cortex-M0+ Core Revision                          */
N#define __MPU_PRESENT             0			/*!< MPU present or not                               */
N#define __VTOR_PRESENT            1			/*!< VTOR is present in this implementation           */
N#define __NVIC_PRIO_BITS          2			/*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used     */
N
N/**
N * @}
N */
N
N/** @defgroup CMSIS_8XX_IRQ CHIP: LPC8xx peripheral interrupt numbers
N * @ingroup CMSIS_8XX_ALL
N * @{
N */
N
Ntypedef enum {
N	/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N	Reset_IRQn                    = -15,	/*!< 1 Reset Vector, invoked on Power up and warm reset */
N	NonMaskableInt_IRQn           = -14,	/*!< 2 Non Maskable Interrupt                           */
N	HardFault_IRQn                = -13,	/*!< 3 Cortex-M0 Hard Fault Interrupt                   */
N	SVCall_IRQn                   = -5,		/*!< 11 Cortex-M0 SV Call Interrupt                     */
N	PendSV_IRQn                   = -2,		/*!< 14 Cortex-M0 Pend SV Interrupt                     */
N	SysTick_IRQn                  = -1,		/*!< 15 Cortex-M0 System Tick Interrupt                 */
N
N	/******  LPC8xx Specific Interrupt Numbers ********************************************************/
N	SPI0_IRQn                     = 0,		/*!< SPI0                                             */
N	SPI1_IRQn                     = 1,		/*!< SPI1                                             */
N	Reserved0_IRQn                = 2,		/*!< Reserved Interrupt                               */
N	UART0_IRQn                    = 3,		/*!< USART0                                           */
N	UART1_IRQn                    = 4,		/*!< USART1                                           */
N	UART2_IRQn                    = 5,		/*!< USART2                                           */
N	Reserved1_IRQn                = 6,		/*!< Reserved Interrupt                               */
N	I2C1_IRQn                     = 7,		/*!< I2C1                                             */
N	I2C0_IRQn                     = 8,		/*!< I2C0                                             */
N	I2C_IRQn                      = 8,		/*!< Alias for I2C0                                   */
N	SCT_IRQn                      = 9,		/*!< SCT                                              */
N	MRT_IRQn                      = 10,		/*!< MRT                                              */
N	CMP_IRQn                      = 11,		/*!< CMP                                              */
N	WDT_IRQn                      = 12,		/*!< WDT                                              */
N	BOD_IRQn                      = 13,		/*!< BOD                                              */
N	FLASH_IRQn                    = 14,		/*!< Flash interrupt                                  */
N	WKT_IRQn                      = 15,		/*!< WKT Interrupt                                    */
N	ADC_SEQA_IRQn                 = 16,		/*!< ADC sequence A completion                        */
N	ADC_SEQB_IRQn                 = 17,		/*!< ADC sequence B completion                        */
N	ADC_THCMP_IRQn                = 18,		/*!< ADC threshold compare                            */
N	ADC_OVR_IRQn                  = 19,		/*!< ADC overrun                                      */
N	DMA_IRQn                      = 20,		/*!< Reserved Interrupt                               */
N	I2C2_IRQn                     = 21,		/*!< Reserved Interrupt                               */
N	I2C3_IRQn                     = 22,		/*!< Reserved Interrupt                               */
N	Reserved2_IRQn                = 23,		/*!< Reserved Interrupt                               */
N	PININT0_IRQn                  = 24,		/*!< External Interrupt 0                             */
N	PIN_INT0_IRQn                 = 24,		/*!< External Interrupt 0 (alias)                     */
N	PININT1_IRQn                  = 25,		/*!< External Interrupt 1                             */
N	PIN_INT1_IRQn                 = 25,		/*!< External Interrupt 1 (alias)                     */
N	PININT2_IRQn                  = 26,		/*!< External Interrupt 2                             */
N	PIN_INT2_IRQn                 = 26,		/*!< External Interrupt 2 (alias)                     */
N	PININT3_IRQn                  = 27,		/*!< External Interrupt 3                             */
N	PIN_INT3_IRQn                 = 27,		/*!< External Interrupt 3 (alias)                     */
N	PININT4_IRQn                  = 28,		/*!< External Interrupt 4                             */
N	PIN_INT4_IRQn                 = 28,		/*!< External Interrupt 4 (alias)                     */
N	PININT5_IRQn                  = 29,		/*!< External Interrupt 5                             */
N	PIN_INT5_IRQn                 = 29,		/*!< External Interrupt 5 (alias)                     */
N	PININT6_IRQn                  = 30,		/*!< External Interrupt 6                             */
N	PIN_INT6_IRQn                 = 30,		/*!< External Interrupt 6 (alias)                     */
N	PININT7_IRQn                  = 31,		/*!< External Interrupt 7                             */
N	PIN_INT7_IRQn                 = 31,		/*!< External Interrupt 7 (alias)                     */
N} IRQn_Type;
N
N/**
N * @}
N */
N
N#include "core_cm0plus.h"				/*!< Cortex-M0+ processor and core peripherals        */
L 1 ".\_CMSIS\v5.20\Include\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V5.0.3
N * @date     09. August 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
N#define __CORE_CM0PLUS_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex-M0+
N  @{
N */
N
N#include "cmsis_version.h"
L 1 ".\_CMSIS\v5.20\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 1U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 ".\_CMSIS\v5.20\Include\core_cm0plus.h" 2
N 
N/*  CMSIS CM0+ definitions */
N#define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
N                                       __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) |                                        __CM0PLUS_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 ".\_CMSIS\v5.20\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 ".\_CMSIS\v5.20\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (ARM compiler V5) header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060300 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#else
S  (void)fpscr;
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 ".\_CMSIS\v5.20\Include\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S  
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 ".\_CMSIS\v5.20\Include\core_cm0plus.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
N#define __CORE_CM0PLUS_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000U
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex-M0+ */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N#else
S        uint32_t RESERVED0;
N#endif
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0 == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S} MPU_Type;
S
S#define MPU_TYPE_RALIASES                  1U
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0+ header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0 == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N/*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
N/*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N           If VTOR is not present address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S    uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S  uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0 == 1U)
S
S#include "mpu_armv7.h"
S
N#endif
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 147 ".\lpc_chip_82x\inc\cmsis.h" 2
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CMSIS_H_ */
L 38 ".\lpc_chip_82x\inc\chip.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifndef CORE_M0PLUS
S#error CORE_M0PLUS is not defined for the LPC8xx architecture
S#error CORE_M0PLUS should be defined as part of your compiler define list
N#endif
N
N#ifndef CHIP_LPC8XX
S#error The LPC8XX Chip include path is used for this build, but
S#error CHIP_LPC8XX is not defined!
N#endif
N
N/** @defgroup PERIPH_8XX_BASE CHIP: LPC8xx Peripheral addresses and register set declarations
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/* Base addresses */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_ROM_BASE          (0x1FFF0000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_AHB_BASE          (0x50000000UL)
N
N/* APB0 peripherals */
N#define LPC_WWDT_BASE         (0x40000000UL)
N#define LPC_MRT_BASE          (0x40004000UL)
N#define LPC_WKT_BASE          (0x40008000UL)
N#define LPC_SWM_BASE          (0x4000C000UL)
N#define LPC_ADC_BASE          (0x4001C000UL)  /* Available only on LPC82x */
N#define LPC_PMU_BASE          (0x40020000UL)
N#define LPC_CMP_BASE          (0x40024000UL)
N#define LPC_DMATIRGMUX_BASE   (0x40028000UL)  /* Available only on LPC82x */
N#define LPC_INMUX_BASE        (0x4002C000UL)  /* Available only on LPC82x */
N
N#define LPC_FMC_BASE          (0x40040000UL)
N#define LPC_IOCON_BASE        (0x40044000UL)
N#define LPC_SYSCTL_BASE       (0x40048000UL)
N#define LPC_I2C0_BASE         (0x40050000UL)
N#define LPC_I2C1_BASE         (0x40054000UL)  /* Available only on LPC82x */
N#define LPC_SPI0_BASE         (0x40058000UL)
N#define LPC_SPI1_BASE         (0x4005C000UL)
N#define LPC_USART0_BASE       (0x40064000UL)
N#define LPC_USART1_BASE       (0x40068000UL)
N#define LPC_USART2_BASE       (0x4006C000UL)
N#define LPC_I2C2_BASE         (0x40070000UL)  /* Available only on LPC82x */
N#define LPC_I2C3_BASE         (0x40074000UL)  /* Available only on LPC82x */
N
N/* AHB peripherals */
N#define LPC_CRC_BASE          (0x50000000UL)
N#define LPC_SCT_BASE          (0x50004000UL)
N#define LPC_DMA_BASE          (0x50008000UL)  /* Available only on LPC82x */
N
N#define LPC_GPIO_PORT_BASE    (0xA0000000UL)
N#define LPC_PIN_INT_BASE      (0xA0004000UL)
N
N#define LPC_WWDT            ((LPC_WWDT_T     *) LPC_WWDT_BASE)
N#define LPC_SPI0            ((LPC_SPI_T      *) LPC_SPI0_BASE)
N#define LPC_SPI1            ((LPC_SPI_T      *) LPC_SPI1_BASE)
N#define LPC_USART0          ((LPC_USART_T    *) LPC_USART0_BASE)
N#define LPC_USART1          ((LPC_USART_T    *) LPC_USART1_BASE)
N#define LPC_USART2          ((LPC_USART_T    *) LPC_USART2_BASE)
N#define LPC_WKT             ((LPC_WKT_T         *) LPC_WKT_BASE)
N#define LPC_PMU             ((LPC_PMU_T         *) LPC_PMU_BASE)
N#define LPC_CRC             ((LPC_CRC_T         *) LPC_CRC_BASE)
N#define LPC_SCT             ((LPC_SCT_T         *) LPC_SCT_BASE)
N#define LPC_GPIO_PORT       ((LPC_GPIO_T        *) LPC_GPIO_PORT_BASE)
N#define LPC_PININT          ((LPC_PIN_INT_T     *) LPC_PIN_INT_BASE)
N#define LPC_IOCON           ((LPC_IOCON_T       *) LPC_IOCON_BASE)
N#define LPC_SWM             ((LPC_SWM_T         *) LPC_SWM_BASE)
N#define LPC_SYSCTL          ((LPC_SYSCTL_T      *) LPC_SYSCTL_BASE)
N#define LPC_CMP             ((LPC_CMP_T         *) LPC_CMP_BASE)
N#define LPC_FMC             ((LPC_FMC_T         *) LPC_FMC_BASE)
N#define LPC_MRT             ((LPC_MRT_T         *) LPC_MRT_BASE)
N#define LPC_I2C0            ((LPC_I2C_T         *) LPC_I2C0_BASE)
N
N#ifdef CHIP_LPC82X
N/* Peripherals available only on LPC82x */
N#define LPC_ADC             ((LPC_ADC_T         *) LPC_ADC_BASE)
N#define LPC_I2C1            ((LPC_I2C_T         *) LPC_I2C1_BASE)
N#define LPC_I2C2            ((LPC_I2C_T         *) LPC_I2C2_BASE)
N#define LPC_I2C3            ((LPC_I2C_T         *) LPC_I2C3_BASE)
N#define LPC_DMA             ((LPC_DMA_T         *) LPC_DMA_BASE)
N#define LPC_DMATRIGMUX      ((LPC_DMATRIGMUX_T  *) LPC_DMATIRGMUX_BASE)
N#define LPC_INMUX           ((LPC_INMUX_T       *) LPC_INMUX_BASE)
N#endif
N
N/* Base address Alias list */
N#define LPC_I2C_BASE         LPC_I2C0_BASE
N#define LPC_I2C              LPC_I2C0
N#define LPC_SYSCON           LPC_SYSCTL
N
N/* IRQ Handler alias list */
N#ifdef CHIP_LPC82X
N#define I2C_IRQHandler       I2C0_IRQHandler
N#define PININT0_IRQHandler   PIN_INT0_IRQHandler
N#define PININT1_IRQHandler   PIN_INT1_IRQHandler
N#define PININT2_IRQHandler   PIN_INT2_IRQHandler
N#define PININT3_IRQHandler   PIN_INT3_IRQHandler
N#define PININT4_IRQHandler   PIN_INT4_IRQHandler
N#define PININT5_IRQHandler   PIN_INT5_IRQHandler
N#define PININT6_IRQHandler   PIN_INT6_IRQHandler
N#define PININT7_IRQHandler   PIN_INT7_IRQHandler
N#endif
N
N/**
N * @}
N */
N
N/** @ingroup CHIP_8XX_DRIVER_OPTIONS
N * @{
N */
N
N/**
N * @brief	System oscillator rate
N * This value is defined externally to the chip layer and contains
N * the value in Hz for the external oscillator for the board. If using the
N * internal oscillator, this rate can be 0.
N */
Nextern const uint32_t OscRateIn;
N
N/**
N * @brief	Clock rate on the CLKIN pin
N * This value is defined externally to the chip layer and contains
N * the value in Hz for the CLKIN pin for the board. If this pin isn't used,
N * this rate can be 0.
N */
Nextern const uint32_t ExtRateIn;
N
N/**
N * @}
N */
N
N/* Include order is important! */
N#include "romapi_8xx.h"
L 1 ".\lpc_chip_82x\inc\romapi_8xx.h" 1
N/*
N * @brief LPC8xx ROM API declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ROMAPI_8XX_H_
N#define __ROMAPI_8XX_H_
N
N#include "iap.h"
L 1 ".\lpc_chip_82x\inc\iap.h" 1
N/*
N * @brief Common IAP support functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __IAP_H_
N#define __IAP_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup COMMON_IAP CHIP: Common Chip ISP/IAP commands and return codes
N * @ingroup CHIP_Common
N * @{
N */
N
N/* IAP command definitions */
N#define IAP_PREWRRITE_CMD           50	/*!< Prepare sector for write operation command */
N#define IAP_WRISECTOR_CMD           51	/*!< Write Sector command */
N#define IAP_ERSSECTOR_CMD           52	/*!< Erase Sector command */
N#define IAP_BLANK_CHECK_SECTOR_CMD  53	/*!< Blank check sector */
N#define IAP_REPID_CMD               54	/*!< Read PartID command */
N#define IAP_READ_BOOT_CODE_CMD      55	/*!< Read Boot code version */
N#define IAP_COMPARE_CMD             56	/*!< Compare two RAM address locations */
N#define IAP_REINVOKE_ISP_CMD        57	/*!< Reinvoke ISP */
N#define IAP_READ_UID_CMD            58	/*!< Read UID */
N#define IAP_ERASE_PAGE_CMD          59	/*!< Erase page */
N#define IAP_EEPROM_WRITE            61	/*!< EEPROM Write command */
N#define IAP_EEPROM_READ             62	/*!< EEPROM READ command */
N
N/* IAP response definitions */
N#define IAP_CMD_SUCCESS             0	/*!< Command is executed successfully */
N#define IAP_INVALID_COMMAND         1	/*!< Invalid command */
N#define IAP_SRC_ADDR_ERROR          2	/*!< Source address is not on word boundary */
N#define IAP_DST_ADDR_ERROR          3	/*!< Destination address is not on a correct boundary */
N#define IAP_SRC_ADDR_NOT_MAPPED     4	/*!< Source address is not mapped in the memory map */
N#define IAP_DST_ADDR_NOT_MAPPED     5	/*!< Destination address is not mapped in the memory map */
N#define IAP_COUNT_ERROR             6	/*!< Byte count is not multiple of 4 or is not a permitted value */
N#define IAP_INVALID_SECTOR          7	/*!< Sector number is invalid or end sector number is greater than start sector number */
N#define IAP_SECTOR_NOT_BLANK        8	/*!< Sector is not blank */
N#define IAP_SECTOR_NOT_PREPARED     9	/*!< Command to prepare sector for write operation was not executed */
N#define IAP_COMPARE_ERROR           10	/*!< Source and destination data not equal */
N#define IAP_BUSY                    11	/*!< Flash programming hardware interface is busy */
N#define IAP_PARAM_ERROR             12	/*!< nsufficient number of parameters or invalid parameter */
N#define IAP_ADDR_ERROR              13	/*!< Address is not on word boundary */
N#define IAP_ADDR_NOT_MAPPED         14	/*!< Address is not mapped in the memory map */
N#define IAP_CMD_LOCKED              15	/*!< Command is locked */
N#define IAP_INVALID_CODE            16	/*!< Unlock code is invalid */
N#define IAP_INVALID_BAUD_RATE       17	/*!< Invalid baud rate setting */
N#define IAP_INVALID_STOP_BIT        18	/*!< Invalid stop bit setting */
N#define IAP_CRP_ENABLED             19	/*!< Code read protection enabled */
N
N/* IAP_ENTRY API function type */
Ntypedef void (*IAP_ENTRY_T)(unsigned int[], unsigned int[]);
N
N/**
N * @brief	Prepare sector for write operation
N * @param	strSector	: Start sector number
N * @param	endSector	: End sector number
N * @return	Status code to indicate the command is executed successfully or not
N * @note	This command must be executed before executing "Copy RAM to flash"
N *			or "Erase Sector" command.
N *			The end sector must be greater than or equal to start sector number
N */
Nuint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector);
N
N/**
N * @brief	Copy RAM to flash
N * @param	dstAdd		: Destination FLASH address where data bytes are to be written
N * @param	srcAdd		: Source RAM address where data bytes are to be read
N * @param	byteswrt	: Number of bytes to be written
N * @return	Status code to indicate the command is executed successfully or not
N * @note	The addresses should be a 256 byte boundary and the number of bytes
N *			should be 256 | 512 | 1024 | 4096
N */
Nuint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt);
N
N/**
N * @brief	Erase sector
N * @param	strSector	: Start sector number
N * @param	endSector	: End sector number
N * @return	Status code to indicate the command is executed successfully or not
N * @note	The end sector must be greater than or equal to start sector number
N */
Nuint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector);
N
N/**
N * @brief Blank check a sector or multiples sector of on-chip flash memory
N * @param	strSector	: Start sector number
N * @param	endSector	: End sector number
N * @return	Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK
N * @note	The end sector must be greater than or equal to start sector number
N */
N// FIXME - There are two return value (result[0] & result[1]
N// Result0:Offset of the first non blank word location if the Status Code is
N// SECTOR_NOT_BLANK.
N// Result1:Contents of non blank word location.
Nuint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector);
N
N/**
N * @brief	Read part identification number
N * @return	Part identification number
N */
Nuint32_t Chip_IAP_ReadPID(void);
N
N/**
N * @brief	Read boot code version number
N * @return	Boot code version number
N */
Nuint32_t Chip_IAP_ReadBootCode(void);
N
N/**
N * @brief	Compare the memory contents at two locations
N * @param	dstAdd		: Destination of the RAM address of data bytes to be compared
N * @param	srcAdd		: Source of the RAM address of data bytes to be compared
N * @param	bytescmp	: Number of bytes to be compared
N * @return	Offset of the first mismatch of the status code is COMPARE_ERROR
N * @note	The addresses should be a word boundary and number of bytes should be
N *			a multiply of 4
N */
Nuint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp);
N
N/**
N * @brief	IAP reinvoke ISP to invoke the bootloader in ISP mode
N * @return	none
N */
Nuint8_t Chip_IAP_ReinvokeISP(void);
N
N/**
N * @brief	Read the unique ID
N * @return	Status code to indicate the command is executed successfully or not
N */
Nuint32_t Chip_IAP_ReadUID(uint32_t* uid);
N
N/**
N * @brief	Erase a page or multiple papers of on-chip flash memory
N * @param	strPage	: Start page number
N * @param	endPage	: End page number
N * @return	Status code to indicate the command is executed successfully or not
N * @note	The page number must be greater than or equal to start page number
N */
N// FIXME - There are four return value
N// Result0:The first 32-bit word (at the lowest address)
N// Result1:The second 32-bit word.
N// Result2:The third 32-bit word.
N// Result3:The fourth 32-bit word.
Nuint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __IAP_H_ */
L 36 ".\lpc_chip_82x\inc\romapi_8xx.h" 2
N#include "error_8xx.h"
L 1 ".\lpc_chip_82x\inc\error_8xx.h" 1
N/*
N * @brief Error code returned by LPC8xx Boot ROM drivers/library functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ERROR_8XX_H__
N#define __ERROR_8XX_H__
N
N/** @defgroup ROMAPI_ERRORCODES_8XX CHIP: LPC8xx ROM API error codes
N * @ingroup ROMAPI_8XX
N * @{
N */
N
N/** Error code returned by Boot ROM drivers/library functions
N*
N*  Error codes are a 32-bit value with :
N*      - The 16 MSB contains the peripheral code number
N*      - The 16 LSB contains an error code number associated to that peripheral
N*
N*/
Ntypedef enum
N{
N  /**\b 0x00000000*/ LPC_OK = 0,		/**< enum value returned on Successful completion */
N  /**\b 0x00000001*/ LPC_ERROR,			/**< enum value returned on general error (I2C) */
N
N  /* ISP related errors */
N  ERR_ISP_BASE = 0x00000000,
N  /**\b 0x00000001*/ ERR_ISP_INVALID_COMMAND = ERR_ISP_BASE + 1,
N  /**\b 0x00000002*/ ERR_ISP_SRC_ADDR_ERROR,			/*!< Source address not on word boundary */
N  /**\b 0x00000003*/ ERR_ISP_DST_ADDR_ERROR,			/*!< Destination address not on word or 256 byte boundary */
N  /**\b 0x00000004*/ ERR_ISP_SRC_ADDR_NOT_MAPPED,
N  /**\b 0x00000005*/ ERR_ISP_DST_ADDR_NOT_MAPPED,
N  /**\b 0x00000006*/ ERR_ISP_COUNT_ERROR,				/*!< Byte count is not multiple of 4 or is not a permitted value */
N  /**\b 0x00000007*/ ERR_ISP_INVALID_SECTOR,
N  /**\b 0x00000008*/ ERR_ISP_SECTOR_NOT_BLANK,
N  /**\b 0x00000009*/ ERR_ISP_SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION,
N  /**\b 0x0000000A*/ ERR_ISP_COMPARE_ERROR,
N  /**\b 0x0000000B*/ ERR_ISP_BUSY,						/*!< Flash programming hardware interface is busy */
N  /**\b 0x0000000C*/ ERR_ISP_PARAM_ERROR,				/*!< Insufficient number of parameters */
N  /**\b 0x0000000D*/ ERR_ISP_ADDR_ERROR,				/*!< Address not on word boundary */
N  /**\b 0x0000000E*/ ERR_ISP_ADDR_NOT_MAPPED,
N  /**\b 0x0000000F*/ ERR_ISP_CMD_LOCKED,				/*!< Command is locked */
N  /**\b 0x00000010*/ ERR_ISP_INVALID_CODE,				/*!< Unlock code is invalid */
N  /**\b 0x00000011*/ ERR_ISP_INVALID_BAUD_RATE,
N  /**\b 0x00000012*/ ERR_ISP_INVALID_STOP_BIT,
N  /**\b 0x00000013*/ ERR_ISP_CODE_READ_PROTECTION_ENABLED,
N
N  /* I2C related errors */
N  ERR_I2C_BASE = 0x00060000,
N  /**\b 0x00060001*/ ERR_I2C_NAK = ERR_I2C_BASE + 1,		/*!< NAK */
N  /**\b 0x00060002*/ ERR_I2C_BUFFER_OVERFLOW,				/*!< Buffer overflow */
N  /**\b 0x00060003*/ ERR_I2C_BYTE_COUNT_ERR,				/*!< Byte count error */
N  /**\b 0x00060004*/ ERR_I2C_LOSS_OF_ARBRITRATION,			/*!< Loss of arbitration */
N  /**\b 0x00060005*/ ERR_I2C_SLAVE_NOT_ADDRESSED,			/*!< Slave not addressed */
N  /**\b 0x00060006*/ ERR_I2C_LOSS_OF_ARBRITRATION_NAK_BIT,	/*!< Loss arbritation NAK */
N  /**\b 0x00060007*/ ERR_I2C_GENERAL_FAILURE,				/*!< General failure */
N  /**\b 0x00060008*/ ERR_I2C_REGS_SET_TO_DEFAULT,			/*!< Set to default */
N  /**\b 0x00060009*/ ERR_I2C_TIMEOUT,						/*!< I2C Timeout */
N
N  /* UART related errors */
N  /**\b 0x00080001*/ ERR_NO_ERROR = LPC_OK,					/*!< Receive is busy */
N  ERR_UART_BASE = 0x00080000,
N  /**\b 0x00080001*/ ERR_UART_RXD_BUSY = ERR_UART_BASE + 1,	/*!< Receive is busy */
N  /**\b 0x00080002*/ ERR_UART_TXD_BUSY,						/*!< Transmit is busy */
N  /**\b 0x00080003*/ ERR_UART_OVERRUN_FRAME_PARITY_NOISE,	/*!< Overrun, Frame, Parity , Receive Noise error */
N  /**\b 0x00080004*/ ERR_UART_UNDERRUN,						/*!< Underrun */
N  /**\b 0x00080005*/ ERR_UART_PARAM,						/*!< Parameter error */
N} ErrorCode_t;
N
N/**
N * @}
N */
N
N#endif /* __ERROR_8XX_H__ */
L 37 ".\lpc_chip_82x\inc\romapi_8xx.h" 2
N#include "rom_i2c_8xx.h"
L 1 ".\lpc_chip_82x\inc\rom_i2c_8xx.h" 1
N/*
N * @brief LPC8xx I2C ROM API declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ROM_I2C_8XX_H_
N#define __ROM_I2C_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CHIP_I2CROM_8XX CHIP: LPC8xx I2C ROM API declarations and functions
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief LPC8xx I2C ROM driver handle structure
N */
Ntypedef void *I2C_HANDLE_T;
N
N/**
N * @brief LPC8xx I2C ROM driver callback function
N */
Ntypedef void  (*I2C_CALLBK_T)(uint32_t err_code, uint32_t n);
N
N/**
N * LPC8xx I2C ROM driver parameter structure
N */
Ntypedef struct I2C_PARAM {
N	uint32_t        num_bytes_send;		/*!< No. of bytes to send */
N	uint32_t        num_bytes_rec;		/*!< No. of bytes to receive */
N	uint8_t         *buffer_ptr_send;	/*!< Pointer to send buffer */
N	uint8_t         *buffer_ptr_rec;	/*!< Pointer to receive buffer */
N	I2C_CALLBK_T    func_pt;			/*!< Callback function */
N	uint8_t         stop_flag;			/*!< Stop flag */
N	uint8_t         dummy[3];
N} I2C_PARAM_T;
N
N/**
N * LPC8xx I2C ROM driver result structure
N */
Ntypedef struct I2C_RESULT {
N	uint32_t n_bytes_sent;	/*!< No. of bytes sent */
N	uint32_t n_bytes_recd;	/*!< No. of bytes received */
N} I2C_RESULT_T;
N
N/**
N * LPC8xx I2C ROM driver modes enum
N */
Ntypedef enum CHIP_I2C_MODE {
N	IDLE,			/*!< IDLE state */
N	MASTER_SEND,	/*!< Master send state */
N	MASTER_RECEIVE,	/*!< Master Receive state */
N	SLAVE_SEND,		/*!< Slave send state */
N	SLAVE_RECEIVE	/*!< Slave receive state */
N} CHIP_I2C_MODE_T;
N
N/**
N * LPC8xx I2C ROM driver APIs structure
N */
Ntypedef struct  I2CD_API {
N	/*!< Interrupt Support Routine */
N	void (*i2c_isr_handler)(I2C_HANDLE_T *handle);
N
N	/*!< MASTER functions */
N	ErrorCode_t (*i2c_master_transmit_poll)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_master_receive_poll)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_master_tx_rx_poll)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_master_transmit_intr)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_master_receive_intr)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_master_tx_rx_intr)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N
N	/*!< SLAVE functions */
N	ErrorCode_t (*i2c_slave_receive_poll)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_slave_transmit_poll)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_slave_receive_intr)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_slave_transmit_intr)(I2C_HANDLE_T *handle, I2C_PARAM_T *param, I2C_RESULT_T *result);
N	ErrorCode_t (*i2c_set_slave_addr)(I2C_HANDLE_T *handle, uint32_t slave_addr_0_3, uint32_t slave_mask_0_3);
N
N	/*!< OTHER support functions */
N	uint32_t        (*i2c_get_mem_size)(void);
N	I2C_HANDLE_T *  (*i2c_setup)( uint32_t  i2c_base_addr, uint32_t * start_of_ram);
N	ErrorCode_t     (*i2c_set_bitrate)(I2C_HANDLE_T *handle, uint32_t  p_clk_in_hz, uint32_t bitrate_in_bps);
N	uint32_t        (*i2c_get_firmware_version)(void);
N	CHIP_I2C_MODE_T (*i2c_get_status)(I2C_HANDLE_T *handle);
N	ErrorCode_t     (*i2c_set_timeout)(I2C_HANDLE_T *handle, uint32_t timeout);
N} I2CD_API_T;
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ROM_I2C_8XX_H_ */
L 38 ".\lpc_chip_82x\inc\romapi_8xx.h" 2
N#include "rom_pwr_8xx.h"
L 1 ".\lpc_chip_82x\inc\rom_pwr_8xx.h" 1
N/*
N * @brief LPC8xx Power ROM API declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ROM_PWR_8XX_H_
N#define __ROM_PWR_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup PWRD_8XX CHIP: LPC8xx Power ROM API declarations and functions
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief LPC8xx Power ROM APIs - set_pll mode options
N */
N#define CPU_FREQ_EQU    0
N#define CPU_FREQ_LTE    1
N#define CPU_FREQ_GTE    2
N#define CPU_FREQ_APPROX 3
N
N/**
N * @brief LPC8xx Power ROM APIs - set_pll response0 options
N */
N#define PLL_CMD_SUCCESS    0
N#define PLL_INVALID_FREQ   1
N#define PLL_INVALID_MODE   2
N#define PLL_FREQ_NOT_FOUND 3
N#define PLL_NOT_LOCKED     4
N
N/**
N * @brief LPC8xx Power ROM APIs - set_power mode options
N */
N#define PWR_DEFAULT         0
N#define PWR_CPU_PERFORMANCE 1
N#define PWR_EFFICIENCY      2
N#define PWR_LOW_CURRENT     3
N
N/**
N * @brief LPC8xx Power ROM APIs - set_power response0 options
N */
N#define PWR_CMD_SUCCESS  0
N#define PWR_INVALID_FREQ 1
N#define PWR_INVALID_MODE 2
N
N/**
N * @brief LPC8XX Power ROM API structure
N */
Ntypedef struct PWRD_API {
N	void (*set_pll)(uint32_t cmd[], uint32_t resp[]);	/*!< Set PLL function */
N	void (*set_power)(uint32_t cmd[], uint32_t resp[]);	/*!< Set power function */
N} PWRD_API_T;
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ROM_PWR_8XX_H_ */
L 39 ".\lpc_chip_82x\inc\romapi_8xx.h" 2
N#include "rom_uart_8xx.h"
L 1 ".\lpc_chip_82x\inc\rom_uart_8xx.h" 1
N/*
N * @brief LPC8xx UART ROM API declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ROM_UART_8XX_H_
N#define __ROM_UART_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup UARTROM_8XX CHIP: LPC8xx UART ROM API declarations and functions
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief UART ROM driver - UART errors in UART configuration used in uart_init function
N */
N#define OVERRUN_ERR_EN		(1 << 0)	/*!< Bit 0: Enable overrun error */
N#define UNDERRUN_ERR_EN		(1 << 1)	/*!< Bit 1: Enable underrun error */
N#define FRAME_ERR_EN		(1 << 2)	/*!< Bit 2: enable frame error */
N#define PARITY_ERR_EN		(1 << 3)	/*!< Bit 3: enable parity error */
N#define RXNOISE_ERR_EN		(1 << 4)	/*!< Bit 4: enable receive noise error */
N
N/**
N * Macros for UART errors
N */
N/*!< Enable all the UART errors */
N#define ALL_ERR_EN			(OVERRUN_ERR_EN | UNDERRUN_ERR_EN | FRAME_ERR_EN | PARITY_ERR_EN | \
N							 RXNOISE_ERR_EN)
X#define ALL_ERR_EN			(OVERRUN_ERR_EN | UNDERRUN_ERR_EN | FRAME_ERR_EN | PARITY_ERR_EN | 							 RXNOISE_ERR_EN)
N/*!< Disable all the errors */
N#define NO_ERR_EN			(0)
N
N/**
N * Transfer mode values in UART parameter structure.
N * Used in uart_get_line & uart_put_line function
N */
N/*!< 0x00: uart_get_line: stop transfer when the buffer is full */
N/*!< 0x00: uart_put_line: stop transfer when the buffer is empty */
N#define TX_MODE_BUF_EMPTY		(0x00)
N#define RX_MODE_BUF_FULL		(0x00)
N/*!< 0x01: uart_get_line: stop transfer when CRLF are received */
N/*!< 0x01: uart_put_line: transfer stopped after reaching \0 and CRLF is sent out after that */
N#define TX_MODE_SZERO_SEND_CRLF	(0x01)
N#define RX_MODE_CRLF_RECVD		(0x01)
N/*!< 0x02: uart_get_line: stop transfer when LF are received */
N/*!< 0x02: uart_put_line: transfer stopped after reaching \0. And LF is sent out after that */
N#define TX_MODE_SZERO_SEND_LF	(0x02)
N#define RX_MODE_LF_RECVD		(0x02)
N/*!< 0x03: uart_get_line: RESERVED */
N/*!< 0x03: uart_put_line: transfer stopped after reaching \0 */
N#define TX_MODE_SZERO			(0x03)
N
N/**
N * @brief UART ROM driver modes
N */
N#define DRIVER_MODE_POLLING		(0x00)	/*!< Polling mode */
N#define DRIVER_MODE_INTERRUPT	(0x01)	/*!< Interrupt mode */
N#define DRIVER_MODE_DMA			(0x02)	/*!< DMA mode */
N
N/**
N * @brief UART ROM driver UART handle
N */
Ntypedef void UART_HANDLE_T;
N
N/**
N * @brief UART ROM driver UART callback function
N */
Ntypedef void (*UART_CALLBK_T)(uint32_t err_code, uint32_t n);
N
N/**
N * @brief UART ROM driver UART DMA callback function
N */
Ntypedef void (*UART_DMA_REQ_T)(uint32_t src_adr, uint32_t dst_adr, uint32_t size);
N
N/**
N * @brief UART ROM driver configutaion structure
N */
Ntypedef struct {
N	uint32_t sys_clk_in_hz;		/*!< main clock in Hz */
N	uint32_t baudrate_in_hz;	/*!< Baud rate in Hz */
N	uint8_t  config;			/*!< Configuration value */
N								/*!<  bit1:0  Data Length: 00: 7 bits length, 01: 8 bits length, others: reserved */
N								/*!<  bit3:2  Parity: 00: No Parity, 01: reserved, 10: Even, 11: Odd */
N								/*!<  bit4:   Stop Bit(s): 0: 1 Stop bit, 1: 2 Stop bits */
N	uint8_t sync_mod;			/*!< Sync mode settings */
N								/*!<  bit0:  Mode: 0: Asynchronous mode, 1: Synchronous  mode */
N								/*!<  bit1:  0: Un_RXD is sampled on the falling edge of SCLK */
N								/*!<         1: Un_RXD is sampled on the rising edge of SCLK */
N								/*!<  bit2:  0: Start and stop bits are transmitted as in asynchronous mode) */
N								/*!<         1: Start and stop bits are not transmitted) */
N								/*!<  bit3:  0: The UART is a  slave in Synchronous mode */
N								/*!<         1: The UART is a master in Synchronous mode */
N	uint16_t error_en;			/*!< Errors to be enabled */
N								/*!<  bit0: Overrun Errors Enabled */
N								/*!<  bit1: Underrun Errors Enabled */
N								/*!<  bit2: FrameErr Errors Enabled */
N								/*!<  bit3: ParityErr Errors Enabled */
N								/*!<  bit4: RxNoise Errors Enabled */
N} UART_CONFIG_T;
N
N/**
N * @brief UART ROM driver parameter structure
N */
Ntypedef struct {
N	uint8_t         *buffer;		/*!< Pointer to data buffer */
N	uint32_t        size;			/*!< Size of the buffer */
N	uint16_t        transfer_mode;	/*!< Transfer mode settings */
N									/*!<   0x00: uart_get_line: stop transfer when the buffer is full */
N									/*!<   0x00: uart_put_line: stop transfer when the buffer is empty */
N									/*!<   0x01: uart_get_line: stop transfer when CRLF are received */
N									/*!<   0x01: uart_put_line: transfer stopped after reaching \0 and CRLF is sent out after that */
N									/*!<   0x02: uart_get_line: stop transfer when LF are received */
N									/*!<   0x02: uart_put_line: transfer stopped after reaching \0 and LF is sent out after that */
N									/*!<   0x03: uart_get_line: RESERVED */
N									/*!<   0x03: uart_put_line: transfer stopped after reaching \0 */
N	uint16_t        driver_mode;	/*!< Driver mode */
N									/*!<  0x00: Polling mode, function blocked until transfer completes */
N									/*!<  0x01: Interrupt mode, function immediately returns, callback invoked when transfer completes */
N									/*!<  0x02: DMA mode, in case DMA block is available, DMA req function is called for UART DMA channel setup, then callback function indicate that transfer completes */
N	UART_CALLBK_T   callback_func_pt;	/*!< callback function pointer */
N	UART_DMA_REQ_T  dma_req_func_pt;	/*!< UART DMA channel setup function pointer, not applicable on LPC8xx */
N} UART_PARAM_T;
N
N/**
N * @brief UART ROM driver APIs structure
N */
Ntypedef struct UARTD_API {
N	/*!< UART Configuration functions */
N	uint32_t        (*uart_get_mem_size)(void);	/*!< Get the memory size needed by one Min UART instance */
N	UART_HANDLE_T * (*uart_setup)(uint32_t base_addr, uint8_t * ram);	/*!< Setup Min UART instance with provided memory and return the handle to this instance */
N	uint32_t        (*uart_init)(UART_HANDLE_T *handle, UART_CONFIG_T *set);	/*!< Setup baud rate and operation mode for uart, then enable uart */
N
N	/*!< UART polling functions block until completed */
N	uint8_t         (*uart_get_char)(UART_HANDLE_T *handle);	/*!< Receive one Char from uart. This functions is only returned after Char is received. In case Echo is enabled, the received data is sent out immediately */
N	void            (*uart_put_char)(UART_HANDLE_T *handle, uint8_t data);	/*!< Send one Char through uart. This function is only returned after data is sent */
N	uint32_t        (*uart_get_line)(UART_HANDLE_T *handle, UART_PARAM_T *param);	/*!< Receive multiple bytes from UART */
N	uint32_t        (*uart_put_line)(UART_HANDLE_T *handle, UART_PARAM_T *param);	/*!< Send string (end with \0) or raw data through UART */
N
N	/*!< UART interrupt functions return immediately and callback when completed */
N	void            (*uart_isr)(UART_HANDLE_T *handle);	/*!< UART interrupt service routine. To use this routine, the corresponding USART interrupt must be enabled. This function is invoked by the user ISR */
N} UARTD_API_T;
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ROM_UART_8XX_H_ */
L 40 ".\lpc_chip_82x\inc\romapi_8xx.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup ROMAPI_8XX CHIP: LPC8xx ROM API declarations and functions
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief LPC8XX High level ROM API structure
N */
Ntypedef struct ROM_API {
N	const uint32_t    unused[3];
N	const PWRD_API_T  *pPWRD;	/*!< Power profiles API function table */
N	const uint32_t    p_dev1;
N	const I2CD_API_T  *pI2CD;	/*!< I2C driver routines functions table */
N	const uint32_t    p_dev3;
N	const uint32_t    p_dev4;
N	const uint32_t    p_dev5;
N	const UARTD_API_T *pUARTD;	/*!< UART driver routines function table */
N} LPC_ROM_API_T;
N
N/* Pointer to ROM API function address */
N#define LPC_ROM_API_BASE_LOC	0x1FFF1FF8UL
N#define LPC_ROM_API		(*(LPC_ROM_API_T * *) LPC_ROM_API_BASE_LOC)
N
N/* Pointer to @ref PWRD_API_T functions in ROM */
N#define LPC_PWRD_API    ((LPC_ROM_API)->pPWRD)
N
N/* Pointer to @ref I2CD_API_T functions in ROM */
N#define LPC_I2CD_API    ((LPC_ROM_API)->pI2CD)
N
N/* Pointer to @ref UARTD_API_T functions in ROM */
N#define LPC_UARTD_API   ((LPC_ROM_API)->pUARTD)
N
N/* Pointer to ROM IAP entry functions */
N#define IAP_ENTRY_LOCATION        0X1FFF1FF1UL
N
N/**
N * @brief LPC8XX IAP_ENTRY API function type
N */
Nstatic INLINE void iap_entry(unsigned int cmd_param[], unsigned int status_result[])
Xstatic __inline void iap_entry(unsigned int cmd_param[], unsigned int status_result[])
N{
N	((IAP_ENTRY_T) IAP_ENTRY_LOCATION)(cmd_param, status_result);
X	((IAP_ENTRY_T) 0X1FFF1FF1UL)(cmd_param, status_result);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ROMAPI_8XX_H_ */
L 176 ".\lpc_chip_82x\inc\chip.h" 2
N#include "syscon_8xx.h"
L 1 ".\lpc_chip_82x\inc\syscon_8xx.h" 1
N/*
N * @brief LPC8xx System & Control driver inclusion file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SYSCTL_8XX_H_
N#define __SYSCTL_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SYSCTL_8XX CHIP: LPC8xx System and Control Driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * System reset status values
N */
N#define SYSCTL_RST_POR    (1 << 0)	/*!< POR reset status */
N#define SYSCTL_RST_EXTRST (1 << 1)	/*!< External reset status */
N#define SYSCTL_RST_WDT    (1 << 2)	/*!< Watchdog reset status */
N#define SYSCTL_RST_BOD    (1 << 3)	/*!< Brown-out detect reset status */
N#define SYSCTL_RST_SYSRST (1 << 4)	/*!< software system reset status */
N
N/**
N * Peripheral interrupt wakeup events values
N */
N#define SYSCTL_WAKEUP_SPI0TINT    (1 << 0)	/*!< SPI0 interrupt wake-up */
N#define SYSCTL_WAKEUP_SPI1INT     (1 << 1)	/*!< SPI0 interrupt wake-up */
N#define SYSCTL_WAKEUP_USART0INT   (1 << 3)	/*!< USART0 interrupt wake-up */
N#define SYSCTL_WAKEUP_USART1INT   (1 << 4)	/*!< USART1 interrupt wake-up */
N#define SYSCTL_WAKEUP_USART2INT   (1 << 5)	/*!< USART2 interrupt wake-up */
N#define SYSCTL_WAKEUP_I2C0INT     (1 << 8)	/*!< I2C0 interrupt wake-up */
N#define SYSCTL_WAKEUP_I2C1INT     (1 << 7)	/*!< I2C1 interrupt wake-up [Available only on LPC82X] */
N#define SYSCTL_WAKEUP_I2C2INT     (1 << 21)	/*!< I2C2 interrupt wake-up [Available only on LPC82X] */
N#define SYSCTL_WAKEUP_I2C3INT     (1 << 22)	/*!< I2C3 interrupt wake-up [Available only on LPC82X] */
N#define SYSCTL_WAKEUP_WWDTINT     (1 << 12)	/*!< WWDT interrupt wake-up */
N#define SYSCTL_WAKEUP_BODINT      (1 << 13)	/*!< Brown Out Detect (BOD) interrupt wake-up */
N#define SYSCTL_WAKEUP_WKTINT      (1 << 15)	/*!< Self wake-up timer interrupt wake-up */
N#define SYSCTL_WAKEUP_I2CINT      SYSCTL_WAKEUP_I2C0INT /*!< Same as #SYSCTL_WAKEUP_I2CINT */
N
N/**
N * Deep sleep setup values
N */
N#define SYSCTL_DEEPSLP_BOD_PD    (1 << 3)	/*!< BOD power-down control in Deep-sleep mode, powered down */
N#define SYSCTL_DEEPSLP_WDTOSC_PD (1 << 6)	/*!< Watchdog oscillator power control in Deep-sleep, powered down */
N
N/**
N * Deep sleep to wakeup and power state setup values
N */
N#define SYSCTL_SLPWAKE_IRCOUT_PD (1 << 0)	/*!< IRC oscillator output wake-up configuration */
N#define SYSCTL_SLPWAKE_IRC_PD    (1 << 1)	/*!< IRC oscillator power-down wake-up configuration */
N#define SYSCTL_SLPWAKE_FLASH_PD  (1 << 2)	/*!< Flash wake-up configuration */
N#define SYSCTL_SLPWAKE_BOD_PD    (1 << 3)	/*!< BOD wake-up configuration */
N#define SYSCTL_SLPWAKE_ADC_PD    (1 << 4)	/*!< ADC wake-up configuration [Available only on LPC82x] */
N#define SYSCTL_SLPWAKE_SYSOSC_PD (1 << 5)	/*!< System oscillator wake-up configuration */
N#define SYSCTL_SLPWAKE_WDTOSC_PD (1 << 6)	/*!< Watchdog oscillator wake-up configuration */
N#define SYSCTL_SLPWAKE_SYSPLL_PD (1 << 7)	/*!< System PLL wake-up configuration */
N#define SYSCTL_SLPWAKE_ACMP_PD   (1 << 15)	/*!< Analog comparator wake-up configuration */
N
N/**
N * Non-Maskable Interrupt Enable/Disable value
N */
N#define SYSCTL_NMISRC_ENABLE   ((uint32_t) 1 << 31)	/*!< Enable the Non-Maskable Interrupt (NMI) source */
N
N/**
N * @brief LPC8XX System Control and Clock register block structure
N */
Ntypedef struct {
N	__IO uint32_t SYSMEMREMAP;			/*!< Offset: 0x000 System memory remap (R/W) */
X	volatile uint32_t SYSMEMREMAP;			 
N	__IO uint32_t PRESETCTRL;			/*!< Offset: 0x004 Peripheral reset control (R/W) */
X	volatile uint32_t PRESETCTRL;			 
N	__IO uint32_t SYSPLLCTRL;			/*!< Offset: 0x008 System PLL control (R/W) */
X	volatile uint32_t SYSPLLCTRL;			 
N	__IO uint32_t SYSPLLSTAT;			/*!< Offset: 0x00C System PLL status (R/W ) */
X	volatile uint32_t SYSPLLSTAT;			 
N	uint32_t RESERVED0[4];
N	__IO uint32_t SYSOSCCTRL;			/*!< Offset: 0x020 System oscillator control (R/W) */
X	volatile uint32_t SYSOSCCTRL;			 
N	__IO uint32_t WDTOSCCTRL;			/*!< Offset: 0x024 Watchdog oscillator control (R/W) */
X	volatile uint32_t WDTOSCCTRL;			 
N	__IO uint32_t IRCCTRL;              /*!< Offset: 0x028 IRC Control Register (Available only in LPC82X) */
X	volatile uint32_t IRCCTRL;               
N	uint32_t RESERVED1[1];
N	__IO uint32_t SYSRSTSTAT;			/*!< Offset: 0x030 System reset status Register (R/W ) */
X	volatile uint32_t SYSRSTSTAT;			 
N	uint32_t RESERVED2[3];
N	__IO uint32_t SYSPLLCLKSEL;			/*!< Offset: 0x040 System PLL clock source select (R/W) */
X	volatile uint32_t SYSPLLCLKSEL;			 
N	__IO uint32_t SYSPLLCLKUEN;			/*!< Offset: 0x044 System PLL clock source update enable (R/W) */
X	volatile uint32_t SYSPLLCLKUEN;			 
N	uint32_t RESERVED3[10];
N	__IO uint32_t MAINCLKSEL;			/*!< Offset: 0x070 Main clock source select (R/W) */
X	volatile uint32_t MAINCLKSEL;			 
N	__IO uint32_t MAINCLKUEN;			/*!< Offset: 0x074 Main clock source update enable (R/W) */
X	volatile uint32_t MAINCLKUEN;			 
N	__IO uint32_t SYSAHBCLKDIV;			/*!< Offset: 0x078 System AHB clock divider (R/W) */
X	volatile uint32_t SYSAHBCLKDIV;			 
N	uint32_t RESERVED4[1];
N	__IO uint32_t SYSAHBCLKCTRL;		/*!< Offset: 0x080 System AHB clock control (R/W) */
X	volatile uint32_t SYSAHBCLKCTRL;		 
N	uint32_t RESERVED5[4];
N	__IO uint32_t UARTCLKDIV;			/*!< Offset: 0x094 UART clock divider (R/W) */
X	volatile uint32_t UARTCLKDIV;			 
N	uint32_t RESERVED6[18];
N	__IO uint32_t CLKOUTSEL;			/*!< Offset: 0x0E0 CLKOUT clock source select (R/W) */
X	volatile uint32_t CLKOUTSEL;			 
N	__IO uint32_t CLKOUTUEN;			/*!< Offset: 0x0E4 CLKOUT clock source update enable (R/W) */
X	volatile uint32_t CLKOUTUEN;			 
N	__IO uint32_t CLKOUTDIV;			/*!< Offset: 0x0E8 CLKOUT clock divider (R/W) */
X	volatile uint32_t CLKOUTDIV;			 
N	uint32_t RESERVED7;
N	__IO uint32_t UARTFRGDIV;			/*!< Offset: 0x0F0 UART fractional divider SUB(R/W) */
X	volatile uint32_t UARTFRGDIV;			 
N	__IO uint32_t UARTFRGMULT;			/*!< Offset: 0x0F4 UART fractional divider ADD(R/W) */
X	volatile uint32_t UARTFRGMULT;			 
N	uint32_t RESERVED8[1];
N	__IO uint32_t EXTTRACECMD;			/*!< Offset: 0x0FC External trace buffer command register  */
X	volatile uint32_t EXTTRACECMD;			 
N	__IO uint32_t PIOPORCAP0;			/*!< Offset: 0x100 POR captured PIO status 0 (R/ ) */
X	volatile uint32_t PIOPORCAP0;			 
N	uint32_t RESERVED9[12];
N	__IO uint32_t IOCONCLKDIV[7];		/*!< Offset: 0x134 Peripheral clock x to the IOCON block for programmable glitch filter */
X	volatile uint32_t IOCONCLKDIV[7];		 
N	__IO uint32_t BODCTRL;				/*!< Offset: 0x150 BOD control (R/W) */
X	volatile uint32_t BODCTRL;				 
N	__IO uint32_t SYSTCKCAL;			/*!< Offset: 0x154 System tick counter calibration (R/W) */
X	volatile uint32_t SYSTCKCAL;			 
N	uint32_t RESERVED10[6];
N	__IO uint32_t IRQLATENCY;			/*!< Offset: 0x170 IRQ delay */
X	volatile uint32_t IRQLATENCY;			 
N	__IO uint32_t NMISRC;				/*!< Offset: 0x174 NMI Source Control     */
X	volatile uint32_t NMISRC;				 
N	__IO uint32_t PINTSEL[8];			/*!< Offset: 0x178 GPIO Pin Interrupt Select register 0 */
X	volatile uint32_t PINTSEL[8];			 
N	uint32_t RESERVED11[27];
N	__IO uint32_t STARTERP0;			/*!< Offset: 0x204 Start logic signal enable Register 0 (R/W) */
X	volatile uint32_t STARTERP0;			 
N	uint32_t RESERVED12[3];
N	__IO uint32_t STARTERP1;			/*!< Offset: 0x214 Start logic signal enable Register 0 (R/W) */
X	volatile uint32_t STARTERP1;			 
N	uint32_t RESERVED13[6];
N	__IO uint32_t PDSLEEPCFG;			/*!< Offset: 0x230 Power-down states in Deep-sleep mode (R/W) */
X	volatile uint32_t PDSLEEPCFG;			 
N	__IO uint32_t PDAWAKECFG;			/*!< Offset: 0x234 Power-down states after wake-up (R/W) */
X	volatile uint32_t PDAWAKECFG;			 
N	__IO uint32_t PDRUNCFG;				/*!< Offset: 0x238 Power-down configuration Register (R/W) */
X	volatile uint32_t PDRUNCFG;				 
N	uint32_t RESERVED14[111];
N	__I  uint32_t DEVICEID;				/*!< Offset: 0x3F8 Device ID (R/ ) */
X	volatile const  uint32_t DEVICEID;				 
N} LPC_SYSCTL_T;
N
N/**
N * @brief IOCON Perpipheral Clock divider selction for input filter
N * sampling clock
N */
Ntypedef enum CHIP_PIN_CLKDIV {
N	IOCONCLKDIV0 = 0,				/*!< Clock divider 0 */
N	IOCONCLKDIV1,					/*!< Clock divider 1 */
N	IOCONCLKDIV2,					/*!< Clock divider 2 */
N	IOCONCLKDIV3,					/*!< Clock divider 3 */
N	IOCONCLKDIV4,					/*!< Clock divider 4 */
N	IOCONCLKDIV5,					/*!< Clock divider 5 */
N	IOCONCLKDIV6,					/*!< Clock divider 6 */
N	IOCONCLK_MAX = IOCONCLKDIV6		/*!< Top value used to reverse the dividers */
N} CHIP_PIN_CLKDIV_T;
N
N/* Reserved bits masks for registers */
N#define SYSCTL_SYSMEMREMAP_RESERVED     (~3)
N#define SYSCTL_SYSPLLCTRL_RESERVED      (~0x7f)
N#define SYSCTL_SYSPLLSTAT_RESERVED      (~1)
N#define SYSCTL_SYSOSCCTRL_RESERVED      (~3)
N#define SYSCTL_WDTOSCCTRL_RESERVED      (~0x1ff)
N#define SYSCTL_SYSRSTSTAT_RESERVED      (~0x1f)
N#define SYSCTL_SYSPLLCLKSEL_RESERVED    (~3)
N#define SYSCTL_SYSPLLCLKUEN_RESERVED    (~1)
N#define SYSCTL_MAINCLKSEL_RESERVED      (~3)
N#define SYSCTL_MAINCLKUEN_RESERVED      (~1)
N#define SYSCTL_SYSAHBCLKDIV_RESERVED    (~0xff)
N#define SYSCTL_UARTCLKDIV_RESERVED      (~0xff)
N#define SYSCTL_CLKOUTSEL_RESERVED       (~3)
N#define SYSCTL_CLKOUTUEN_RESERVED       (~1)
N#define SYSCTL_CLKOUTDIV_RESERVED       (~0xff)
N#define SYSCTL_UARTFRGDIV_RESERVED      (~0xff)
N#define SYSCTL_UARTFRGMULT_RESERVED     (~0xff)
N#define SYSCTL_EXTTRACECMD_RESERVED     (~3)
N#define SYSCTL_IOCONCLKDIV_RESERVED     (~0xff)
N#define SYSCTL_BODCTRL_RESERVED         (~0x1f)
N#define SYSCTL_SYSTCKCAL_RESERVED       0xfc000000
N#define SYSCTL_IRQLATENCY_RESERVED      (~0xff)
N#define SYSCTL_NMISRC_RESERVED          (~(0x1f|(1u<<31)))
N#define SYSCTL_PINTSEL_RESERVED         (~0x3f)
N#define SYSCTL_STARTERP0_RESERVED       (~0xff)
N#if defined(CHIP_LPC82X)
X#if 1L
N#define SYSCTL_PRESETCTRL_RESERVED      0xfffe2000
N#define SYSCTL_SYSAHBCLKCTRL_RESERVED   0xda100000
N#define SYSCTL_PIOPORCAP0_RESERVED      0xfffc0000
N#define SYSCTL_STARTERP1_RESERVED       ((1<<2)|(1<<6)|(7<<9)|(1<<14)|0xff9f0000)
N#else
S#define SYSCTL_PRESETCTRL_RESERVED      0xffffe000
S#define SYSCTL_SYSAHBCLKCTRL_RESERVED   0xfff00000
S#define SYSCTL_PIOPORCAP0_RESERVED      0xffffc000
S#define SYSCTL_STARTERP1_RESERVED       ((1<<2)|(3<<6)|(7<<9)|(1<<14)|(0x1f<<16)|0xff800000)
N#endif
N/* The following have reserved bits, but they are specially handled elsewhere. */
N/* #define SYSCTL_PDSLEEPCFG_RESERVED      (~(1<<3)|(3<<4)|(1<<6)) */
N/* #define SYSCTL_PDAWAKECFG_RESERVED */
N/* #define SYSCTL_PDRUNCFG_RESERVED   */
N
N/**
N * System memory remap modes used to remap interrupt vectors
N */
Ntypedef enum CHIP_SYSCTL_BOOT_MODE_REMAP {
N	REMAP_BOOT_LOADER_MODE,	/*!< Interrupt vectors are re-mapped to Boot ROM */
N	REMAP_USER_RAM_MODE,	/*!< Interrupt vectors are re-mapped to user Static RAM */
N	REMAP_USER_FLASH_MODE	/*!< Interrupt vectors are not re-mapped and reside in Flash */
N} CHIP_SYSCTL_BOOT_MODE_REMAP_T;
N
N/**
N * Peripheral reset identifiers
N */
Ntypedef enum {
N	RESET_SPI0,			/*!< SPI0 reset control */
N	RESET_SPI1,			/*!< SPI1 reset control */
N	RESET_UARTFBRG,		/*!< UART fractional baud rate generator reset control */
N	RESET_USART0,		/*!< USART0 reset control */
N	RESET_USART1,		/*!< USART1 reset control */
N	RESET_USART2,		/*!< USART2 reset control */
N	RESET_I2C0,			/*!< I2C0 reset control */
N	RESET_MRT,			/*!< MRT reset control */
N	RESET_SCT,			/*!< SCT reset control */
N	RESET_WKT,			/*!< Self wake-up timer (WKT) control */
N	RESET_GPIO,			/*!< GPIO reset control */
N	RESET_FLASH,		/*!< FLASH reset control */
N	RESET_ACMP,			/*!< ACMP reset control */
N	RESET_I2C1 = 14,	/*!< I2C1 reset control [Available only in LPC82x] */
N	RESET_I2C2,			/*!< I2C2 reset control [Available only in LPC82x] */
N	RESET_I2C3,			/*!< I2C3 reset control [Available only in LPC82x] */
N} CHIP_SYSCTL_PERIPH_RESET_T;
N
N/* Reset Alias */
N#define RESET_I2C    RESET_I2C0
N
N/**
N * Brown-out detector reset level
N */
Ntypedef enum CHIP_SYSCTL_BODRSTLVL {
N	SYSCTL_BODRSTLVL_0,	/*!< Brown-out reset at 1.46 ~ 1.63v */
N	SYSCTL_BODRSTLVL_1,	/*!< Brown-out reset at 2.06v ~ 2.15v */
N	SYSCTL_BODRSTLVL_2,	/*!< Brown-out reset at 2.35v ~ 2.43v */
N	SYSCTL_BODRSTLVL_3,	/*!< Brown-out reset at 2.63v ~ 2.71v */
N} CHIP_SYSCTL_BODRSTLVL_T;
N
N/**
N * Brown-out detector interrupt level
N */
Ntypedef enum CHIP_SYSCTL_BODRINTVAL {
N	SYSCTL_BODINTVAL_LVL0,	/* Brown-out interrupt at 1.65 ~ 1.80v */
N	SYSCTL_BODINTVAL_LVL1,	/* Brown-out interrupt at 2.22v ~ 2.35v*/
N	SYSCTL_BODINTVAL_LVL2,	/* Brown-out interrupt at 2.52v ~ 2.66v */
N	SYSCTL_BODINTVAL_LVL3,	/* Brown-out interrupt at 2.80v ~ 2.90v */
N} CHIP_SYSCTL_BODRINTVAL_T;
N
N/**
N * @brief	Re-map interrupt vectors
N * @param	remap	: system memory map value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_Map(CHIP_SYSCTL_BOOT_MODE_REMAP_T remap)
Xstatic __inline void Chip_SYSCTL_Map(CHIP_SYSCTL_BOOT_MODE_REMAP_T remap)
N{
N	LPC_SYSCTL->SYSMEMREMAP = (uint32_t) remap;
X	((LPC_SYSCTL_T *) (0x40048000UL))->SYSMEMREMAP = (uint32_t) remap;
N}
N
N/**
N * @brief	Assert reset for a peripheral
N * @param	periph	: Peripheral to assert reset for
N * @return	Nothing
N * @note	The peripheral will stay in reset until reset is de-asserted. Call
N * Chip_SYSCTL_DeassertPeriphReset() to de-assert the reset
N */
NSTATIC INLINE void Chip_SYSCTL_AssertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
Xstatic __inline void Chip_SYSCTL_AssertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
N{
N	LPC_SYSCTL->PRESETCTRL &= ~((1 << (uint32_t) periph) | SYSCTL_PRESETCTRL_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->PRESETCTRL &= ~((1 << (uint32_t) periph) | 0xfffe2000);
N}
N
N/**
N * @brief	De-assert reset for a peripheral
N * @param	periph	: Peripheral to de-assert reset for
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_DeassertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
Xstatic __inline void Chip_SYSCTL_DeassertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
N{
N	LPC_SYSCTL->PRESETCTRL = (1 << (uint32_t) periph) | (LPC_SYSCTL->PRESETCTRL & ~SYSCTL_PRESETCTRL_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->PRESETCTRL = (1 << (uint32_t) periph) | (((LPC_SYSCTL_T *) (0x40048000UL))->PRESETCTRL & ~0xfffe2000);
N}
N
N/**
N * @brief	Resets a peripheral
N * @param	periph	:	Peripheral to reset
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_PeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
Xstatic __inline void Chip_SYSCTL_PeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
N{
N	Chip_SYSCTL_AssertPeriphReset(periph);
N	Chip_SYSCTL_DeassertPeriphReset(periph);
N}
N
N/**
N * @brief	Get system reset status
N * @return	An Or'ed value of SYSCTL_RST_*
N * @note	This function returns the detected reset source(s).
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetSystemRSTStatus(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetSystemRSTStatus(void)
N{
N	return LPC_SYSCTL->SYSRSTSTAT & ~SYSCTL_SYSRSTSTAT_RESERVED;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->SYSRSTSTAT & ~(~0x1f);
N}
N
N/**
N * @brief	Clear system reset status
N * @param	reset	: An Or'ed value of SYSCTL_RST_* status to clear
N * @return	Nothing
N * @note	This function clears the specified reset source(s).
N */
NSTATIC INLINE void Chip_SYSCTL_ClearSystemRSTStatus(uint32_t reset)
Xstatic __inline void Chip_SYSCTL_ClearSystemRSTStatus(uint32_t reset)
N{
N	LPC_SYSCTL->SYSRSTSTAT = reset;
X	((LPC_SYSCTL_T *) (0x40048000UL))->SYSRSTSTAT = reset;
N}
N
N/**
N * @brief	Read POR captured PIO status
N * @return	captured POR PIO status
N * @note	Some devices only support index 0.
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetPORPIOStatus(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetPORPIOStatus(void)
N{
N	return LPC_SYSCTL->PIOPORCAP0 & ~SYSCTL_PIOPORCAP0_RESERVED;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->PIOPORCAP0 & ~0xfffc0000;
N}
N
N/**
N * @brief	Set brown-out detection interrupt and reset levels
N * @param	rstlvl	: Brown-out detector reset level
N * @param	intlvl	: Brown-out interrupt level
N * @return	Nothing
N * @note	Brown-out detection reset will be disabled upon exiting this function.
N * Use Chip_SYSCTL_EnableBODReset() to re-enable
N */
NSTATIC INLINE void Chip_SYSCTL_SetBODLevels(CHIP_SYSCTL_BODRSTLVL_T rstlvl,
Xstatic __inline void Chip_SYSCTL_SetBODLevels(CHIP_SYSCTL_BODRSTLVL_T rstlvl,
N											CHIP_SYSCTL_BODRINTVAL_T intlvl)
N{
N	LPC_SYSCTL->BODCTRL = ((uint32_t) rstlvl) | (((uint32_t) intlvl) << 2);
X	((LPC_SYSCTL_T *) (0x40048000UL))->BODCTRL = ((uint32_t) rstlvl) | (((uint32_t) intlvl) << 2);
N}
N
N/**
N * @brief	Enable brown-out detection reset
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_EnableBODReset(void)
Xstatic __inline void Chip_SYSCTL_EnableBODReset(void)
N{
N	LPC_SYSCTL->BODCTRL = (1 << 4) | (LPC_SYSCTL->BODCTRL & ~SYSCTL_BODCTRL_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->BODCTRL = (1 << 4) | (((LPC_SYSCTL_T *) (0x40048000UL))->BODCTRL & ~(~0x1f));
N}
N
N/**
N * @brief	Disable brown-out detection reset
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_DisableBODReset(void)
Xstatic __inline void Chip_SYSCTL_DisableBODReset(void)
N{
N	LPC_SYSCTL->BODCTRL &= ~((1 << 4) | SYSCTL_BODCTRL_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->BODCTRL &= ~((1 << 4) | (~0x1f));
N}
N
N/**
N * @brief	Set System tick timer calibration value
N * @param	sysCalVal	: System tick timer calibration value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_SetSYSTCKCAL(uint32_t sysCalVal)
Xstatic __inline void Chip_SYSCTL_SetSYSTCKCAL(uint32_t sysCalVal)
N{
N	LPC_SYSCTL->SYSTCKCAL = sysCalVal;
X	((LPC_SYSCTL_T *) (0x40048000UL))->SYSTCKCAL = sysCalVal;
N}
N
N/**
N * @brief	Set System IRQ latency
N * @param	latency	: Latency in clock ticks
N * @return	Nothing
N * @note	Sets the IRQ latency, a value between 0 and 255 clocks. Lower
N * values allow better latency
N */
NSTATIC INLINE void Chip_SYSCTL_SetIRQLatency(uint32_t latency)
Xstatic __inline void Chip_SYSCTL_SetIRQLatency(uint32_t latency)
N{
N	LPC_SYSCTL->IRQLATENCY = latency;
X	((LPC_SYSCTL_T *) (0x40048000UL))->IRQLATENCY = latency;
N}
N
N/**
N * @brief	Get System IRQ latency value
N * @return	IRQ Latency in clock ticks
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetIRQLatency(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetIRQLatency(void)
N{
N	return LPC_SYSCTL->IRQLATENCY & ~SYSCTL_IRQLATENCY_RESERVED;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->IRQLATENCY & ~(~0xff);
N}
N
N/**
N * @brief	Set source for non-maskable interrupt (NMI)
N * @param	intsrc	: IRQ number to assign to the NMI
N * @return	Nothing
N * @note	The NMI source will be disabled upon exiting this function. Use the
N * Chip_SYSCTL_EnableNMISource() function to enable the NMI source
N */
NSTATIC INLINE void Chip_SYSCTL_SetNMISource(uint32_t intsrc)
Xstatic __inline void Chip_SYSCTL_SetNMISource(uint32_t intsrc)
N{
N    /* Disable NMI first */
N    LPC_SYSCTL->NMISRC &= ~(SYSCTL_NMISRC_ENABLE | SYSCTL_NMISRC_RESERVED);
X    ((LPC_SYSCTL_T *) (0x40048000UL))->NMISRC &= ~(((uint32_t) 1 << 31) | (~(0x1f|(1u<<31))));
N    
N    /* Set new NMI source. */
N	LPC_SYSCTL->NMISRC = intsrc;
X	((LPC_SYSCTL_T *) (0x40048000UL))->NMISRC = intsrc;
N}
N
N/**
N * @brief	Enable interrupt used for NMI source
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_EnableNMISource(void)
Xstatic __inline void Chip_SYSCTL_EnableNMISource(void)
N{
N	LPC_SYSCTL->NMISRC = SYSCTL_NMISRC_ENABLE | (LPC_SYSCTL->NMISRC & ~SYSCTL_NMISRC_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->NMISRC = ((uint32_t) 1 << 31) | (((LPC_SYSCTL_T *) (0x40048000UL))->NMISRC & ~(~(0x1f|(1u<<31))));
N}
N
N/**
N * @brief	Disable interrupt used for NMI source
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_DisableNMISource(void)
Xstatic __inline void Chip_SYSCTL_DisableNMISource(void)
N{
N	LPC_SYSCTL->NMISRC &= ~(SYSCTL_NMISRC_ENABLE | SYSCTL_NMISRC_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->NMISRC &= ~(((uint32_t) 1 << 31) | (~(0x1f|(1u<<31))));
N}
N
N/**
N * @brief	Setup a pin source for the pin interrupts (0-7)
N * @param	intno	: IRQ number
N * @param	pin		: pin number (see comments)
N * @return	Nothing
N * @note	For each pin (0-7) that supports an interrupt, the pin number is assigned
N * to that interrupt with this function. Values 0-17 map to pins PIO0-0 to
N * PIO0-17 (For LPC82X Values from 0-28 could be used for PIO0-28).
N */
NSTATIC INLINE void Chip_SYSCTL_SetPinInterrupt(uint32_t intno, uint32_t pin)
Xstatic __inline void Chip_SYSCTL_SetPinInterrupt(uint32_t intno, uint32_t pin)
N{
N	LPC_SYSCTL->PINTSEL[intno] = (uint32_t) pin;
X	((LPC_SYSCTL_T *) (0x40048000UL))->PINTSEL[intno] = (uint32_t) pin;
N}
N
N/**
N * @brief	Enables a pin's (PINT) wakeup logic
N * @param	pin	: pin number
N * @return	Nothing
N * @note	Different devices support different pins, see the user manual
N * for supported pins
N */
NSTATIC INLINE void Chip_SYSCTL_EnablePINTWakeup(uint32_t pin)
Xstatic __inline void Chip_SYSCTL_EnablePINTWakeup(uint32_t pin)
N{
N	LPC_SYSCTL->STARTERP0 = (1 << pin) | (LPC_SYSCTL->STARTERP0 & ~SYSCTL_STARTERP0_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->STARTERP0 = (1 << pin) | (((LPC_SYSCTL_T *) (0x40048000UL))->STARTERP0 & ~(~0xff));
N}
N
N/**
N * @brief	Disables a pin's (PINT) wakeup logic
N * @param	pin	: pin number
N * @return	Nothing
N * @note	Different devices support different pins, see the user manual for supported pins.
N */
NSTATIC INLINE void Chip_SYSCTL_DisablePINTWakeup(uint32_t pin)
Xstatic __inline void Chip_SYSCTL_DisablePINTWakeup(uint32_t pin)
N{
N	LPC_SYSCTL->STARTERP0 &= ~((1 << pin) | SYSCTL_STARTERP0_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->STARTERP0 &= ~((1 << pin) | (~0xff));
N}
N
N/**
N * @brief	Enables peripheral's wakeup logic
N * @param	periphmask	: OR'ed values of SYSCTL_WAKEUP_* for wakeup
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_EnablePeriphWakeup(uint32_t periphmask)
Xstatic __inline void Chip_SYSCTL_EnablePeriphWakeup(uint32_t periphmask)
N{
N	LPC_SYSCTL->STARTERP1 = periphmask | (LPC_SYSCTL->STARTERP0 & ~SYSCTL_STARTERP0_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->STARTERP1 = periphmask | (((LPC_SYSCTL_T *) (0x40048000UL))->STARTERP0 & ~(~0xff));
N}
N
N/**
N * @brief	Disables peripheral's wakeup logic
N * @param	periphmask	: OR'ed values of SYSCTL_WAKEUP_* for wakeup
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_DisablePeriphWakeup(uint32_t periphmask)
Xstatic __inline void Chip_SYSCTL_DisablePeriphWakeup(uint32_t periphmask)
N{
N	LPC_SYSCTL->STARTERP1 &= ~(periphmask | SYSCTL_STARTERP1_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->STARTERP1 &= ~(periphmask | ((1<<2)|(1<<6)|(7<<9)|(1<<14)|0xff9f0000));
N}
N
N/**
N * @brief	Returns current deep sleep mask
N * @return	OR'ed values of SYSCTL_DEEPSLP_* values
N * @note	A high bit indicates the peripheral will power down on deep sleep.
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetDeepSleepPD(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetDeepSleepPD(void)
N{
N	return LPC_SYSCTL->PDSLEEPCFG;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->PDSLEEPCFG;
N}
N
N/**
N * @brief	Return current wakup mask
N * @return	OR'ed values of SYSCTL_SLPWAKE_* values
N * @note	A high state indicates the peripehral will powerup on wakeup.
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetWakeup(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetWakeup(void)
N{
N	return LPC_SYSCTL->PDAWAKECFG;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->PDAWAKECFG;
N}
N
N/**
N * @brief	Power up one or more blocks or peripherals
N * @return	OR'ed values of SYSCTL_SLPWAKE_* values
N * @note	A high state indicates the peripheral is powered down.
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetPowerStates(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetPowerStates(void)
N{
N	return LPC_SYSCTL->PDRUNCFG;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->PDRUNCFG;
N}
N
N/**
N * @brief	Return the device ID
N * @return	Device ID
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetDeviceID(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetDeviceID(void)
N{
N	return LPC_SYSCTL->DEVICEID;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->DEVICEID;
N}
N
N/**
N * @brief	Setup deep sleep behaviour for power down
N * @param	sleepmask	: OR'ed values of SYSCTL_DEEPSLP_* values (high to powerdown on deepsleep)
N * @return	Nothing
N * @note	This must be setup prior to using deep sleep. See the user manual
N * *(PDSLEEPCFG register) for more info on setting this up. This function selects
N * which peripherals are powered down on deep sleep.
N * This function should only be called once with all options for power-down
N * in that call
N */
Nvoid Chip_SYSCTL_SetDeepSleepPD(uint32_t sleepmask);
N
N/**
N * @brief	Setup wakeup behaviour from deep sleep
N * @param	wakeupmask	: OR'ed values of SYSCTL_SLPWAKE_* values (high is powered down)
N * @return	Nothing
N * @note	This must be setup prior to using deep sleep. See the user manual
N * *(PDWAKECFG register) for more info on setting this up. This function selects
N * which peripherals are powered up on exit from deep sleep.
N * This function should only be called once with all options for wakeup
N * in that call
N */
Nvoid Chip_SYSCTL_SetWakeup(uint32_t wakeupmask);
N
N/**
N * @brief	Power down one or more blocks or peripherals
N * @param	powerdownmask	: OR'ed values of SYSCTL_SLPWAKE_* values
N * @return	Nothing
N */
Nvoid Chip_SYSCTL_PowerDown(uint32_t powerdownmask);
N
N/**
N * @brief	Power up one or more blocks or peripherals
N * @param	powerupmask	: OR'ed values of SYSCTL_SLPWAKE_* values
N * @return	Nothing
N */
Nvoid Chip_SYSCTL_PowerUp(uint32_t powerupmask);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSCTL_8XX_H_ */
L 177 ".\lpc_chip_82x\inc\chip.h" 2
N#include "clock_8xx.h"
L 1 ".\lpc_chip_82x\inc\clock_8xx.h" 1
N/*
N * @brief LPC8xx clock driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CLOCK_8XX_H_
N#define __CLOCK_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CLOCK_8XX CHIP: LPC8xx Clock Driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/* Internal oscillator frequency */
N#define SYSCTL_IRC_FREQ     (12000000)
N#ifndef MAX_CLOCK_FREQ
N#define MAX_CLOCK_FREQ		(30000000)
N#endif
N
N/**
N * Clock sources for system and USB PLLs
N */
Ntypedef enum CHIP_SYSCTL_PLLCLKSRC {
N	SYSCTL_PLLCLKSRC_IRC = 0,		/*!< Internal oscillator */
N	SYSCTL_PLLCLKSRC_SYSOSC,		/*!< Crystal (system) oscillator */
N	SYSCTL_PLLCLKSRC_RESERVED,
N	SYSCTL_PLLCLKSRC_EXT_CLKIN,	/*!< External clock input */
N} CHIP_SYSCTL_PLLCLKSRC_T;
N
N/**
N * Watchdog oscillator analog output frequency selection
N * values enum (plus or minus 40%)
N */
Ntypedef enum CHIP_WDTLFO_OSC {
N	WDTLFO_OSC_ILLEGAL,
N	WDTLFO_OSC_0_60,	/*!< 0.6 MHz watchdog/LFO rate */
N	WDTLFO_OSC_1_05,	/*!< 1.05 MHz watchdog/LFO rate */
N	WDTLFO_OSC_1_40,	/*!< 1.4 MHz watchdog/LFO rate */
N	WDTLFO_OSC_1_75,	/*!< 1.75 MHz watchdog/LFO rate */
N	WDTLFO_OSC_2_10,	/*!< 2.1 MHz watchdog/LFO rate */
N	WDTLFO_OSC_2_40,	/*!< 2.4 MHz watchdog/LFO rate */
N	WDTLFO_OSC_2_70,	/*!< 2.7 MHz watchdog/LFO rate */
N	WDTLFO_OSC_3_00,	/*!< 3.0 MHz watchdog/LFO rate */
N	WDTLFO_OSC_3_25,	/*!< 3.25 MHz watchdog/LFO rate */
N	WDTLFO_OSC_3_50,	/*!< 3.5 MHz watchdog/LFO rate */
N	WDTLFO_OSC_3_75,	/*!< 3.75 MHz watchdog/LFO rate */
N	WDTLFO_OSC_4_00,	/*!< 4.0 MHz watchdog/LFO rate */
N	WDTLFO_OSC_4_20,	/*!< 4.2 MHz watchdog/LFO rate */
N	WDTLFO_OSC_4_40,	/*!< 4.4 MHz watchdog/LFO rate */
N	WDTLFO_OSC_4_60		/*!< 4.6 MHz watchdog/LFO rate */
N} CHIP_WDTLFO_OSC_T;
N
N/**
N * Clock sources for main system clock
N */
Ntypedef enum CHIP_SYSCTL_MAINCLKSRC {
N	SYSCTL_MAINCLKSRC_IRC = 0,		/*!< Internal oscillator */
N	SYSCTL_MAINCLKSRC_PLLIN,		/*!< System PLL input */
N	SYSCTL_MAINCLKSRC_WDTOSC,		/*!< Watchdog oscillator rate */
N	SYSCTL_MAINCLKSRC_PLLOUT,		/*!< System PLL output */
N} CHIP_SYSCTL_MAINCLKSRC_T;
N
N/**
N * System and peripheral clocks enum
N */
Ntypedef enum CHIP_SYSCTL_CLOCK {
N	SYSCTL_CLOCK_SYS = 0,	/*!< System clock */
N	SYSCTL_CLOCK_ROM,		/*!< ROM clock */
N	SYSCTL_CLOCK_RAM,		/*!< RAM clock */
N	SYSCTL_CLOCK_FLASHREG,	/*!< FLASH register interface clock */
N	SYSCTL_CLOCK_FLASH,		/*!< FLASH array access clock */
N	SYSCTL_CLOCK_I2C0,		/*!< I2C0 clock */
N	SYSCTL_CLOCK_GPIO,		/*!< GPIO clock */
N	SYSCTL_CLOCK_SWM,		/*!< Switch matrix clock */
N	SYSCTL_CLOCK_SCT,		/*!< State configurable timer clock */
N	SYSCTL_CLOCK_WKT,		/*!< Self wake-up timer clock */
N	SYSCTL_CLOCK_MRT,		/*!< Multi-rate timer clock */
N	SYSCTL_CLOCK_SPI0,		/*!< SPI0 clock */
N	SYSCTL_CLOCK_SPI1,		/*!< SPI01 clock */
N	SYSCTL_CLOCK_CRC,		/*!< CRC clock */
N	SYSCTL_CLOCK_UART0,		/*!< UART0 clock */
N	SYSCTL_CLOCK_UART1,		/*!< UART1 clock */
N	SYSCTL_CLOCK_UART2,		/*!< UART2 clock */
N	SYSCTL_CLOCK_WWDT,		/*!< Watchdog clock */
N	SYSCTL_CLOCK_IOCON,		/*!< IOCON clock */
N	SYSCTL_CLOCK_ACOMP,		/*!< Analog comparator clock */
N
N	/* LPC82x Specific Clocks */
N	SYSCTL_CLOCK_I2C1 = 21, /*!< I2C1 Clock */
N	SYSCTL_CLOCK_I2C2,      /*!< I2C2 Clock */
N	SYSCTL_CLOCK_I2C3,      /*!< I2C3 Clock */
N	SYSCTL_CLOCK_ADC,       /*!< 12-Bit ADC Clock */
N	SYSCTL_CLOCK_MTB = 26,  /*!< Macro Trace Buffer [USED FOR DEBUGGING] */
N	SYSCTL_CLOCK_DMA = 29,  /*!< DMA Clock */
N} CHIP_SYSCTL_CLOCK_T;
N
N/* Clock name alias */
N#define SYSCTL_CLOCK_I2C       SYSCTL_CLOCK_I2C0
N#define SYSCTL_CLOCK_ACMP     SYSCTL_CLOCK_ACOMP
N
N/**
N * Clock sources for CLKOUT
N */
Ntypedef enum CHIP_SYSCTL_CLKOUTSRC {
N	SYSCTL_CLKOUTSRC_IRC = 0,		/*!< Internal oscillator for CLKOUT */
N	SYSCTL_CLKOUTSRC_SYSOSC,		/*!< System oscillator for CLKOUT */
N	SYSCTL_CLKOUTSRC_WDTOSC,		/*!< Watchdog oscillator for CLKOUT */
N	SYSCTL_CLKOUTSRC_MAINSYSCLK,	/*!< Main system clock for CLKOUT */
N} CHIP_SYSCTL_CLKOUTSRC_T;
N
N/**
N * @brief	Set System PLL divider values
N * @param	msel    : PLL feedback divider value
N * @param	psel    : PLL post divider value
N * @return	Nothing
N * @note	See the user manual for how to setup the PLL
N */
NSTATIC INLINE void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
Xstatic __inline void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
N{
N	LPC_SYSCTL->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
X	((LPC_SYSCTL_T *) (0x40048000UL))->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
N}
N
N/**
N * @brief	Read System PLL status
N * @return	true if the PLL is locked, false if not locked
N */
NSTATIC INLINE bool Chip_Clock_IsSystemPLLLocked(void)
Xstatic __inline _Bool Chip_Clock_IsSystemPLLLocked(void)
N{
N	return (bool) ((LPC_SYSCTL->SYSPLLSTAT & 1) != 0);
X	return (_Bool) ((((LPC_SYSCTL_T *) (0x40048000UL))->SYSPLLSTAT & 1) != 0);
N}
N
N/**
N * @brief	Setup Watchdog oscillator rate and divider
N * @param	wdtclk	: Selected watchdog clock rate
N * @param	div		: Watchdog divider value, even value between 2 and 64
N * @return	Nothing
N * @note	Watchdog rate = selected rate divided by divider rate
N */
NSTATIC INLINE void Chip_Clock_SetWDTOSC(CHIP_WDTLFO_OSC_T wdtclk, uint8_t div)
Xstatic __inline void Chip_Clock_SetWDTOSC(CHIP_WDTLFO_OSC_T wdtclk, uint8_t div)
N{
N	LPC_SYSCTL->WDTOSCCTRL  = (((uint32_t) wdtclk) << 5) | ((div >> 1) - 1);
X	((LPC_SYSCTL_T *) (0x40048000UL))->WDTOSCCTRL  = (((uint32_t) wdtclk) << 5) | ((div >> 1) - 1);
N}
N
N/**
N * @brief   Returns the main clock source
N * @return	Main clock source
N */
NSTATIC INLINE CHIP_SYSCTL_MAINCLKSRC_T Chip_Clock_GetMainClockSource(void)
Xstatic __inline CHIP_SYSCTL_MAINCLKSRC_T Chip_Clock_GetMainClockSource(void)
N{
N	return (CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & ~SYSCTL_MAINCLKSEL_RESERVED);
X	return (CHIP_SYSCTL_MAINCLKSRC_T) (((LPC_SYSCTL_T *) (0x40048000UL))->MAINCLKSEL & ~(~3));
N}
N
N/**
N * @brief	Set system clock divider
N * @param	div	: divider for system clock
N * @return	Nothing
N * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
N * rate is the main system clock divided by this value.
N */
NSTATIC INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
Xstatic __inline void Chip_Clock_SetSysClockDiv(uint32_t div)
N{
N	LPC_SYSCTL->SYSAHBCLKDIV  = div;
X	((LPC_SYSCTL_T *) (0x40048000UL))->SYSAHBCLKDIV  = div;
N}
N
N/**
N * @brief	Enable system or peripheral clock
N * @param	clk	: Clock to enable
N * @return	Nothing
N */
NSTATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
Xstatic __inline void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
N{
N	LPC_SYSCTL->SYSAHBCLKCTRL = (1 << clk) | (LPC_SYSCTL->SYSAHBCLKCTRL & ~SYSCTL_SYSAHBCLKCTRL_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->SYSAHBCLKCTRL = (1 << clk) | (((LPC_SYSCTL_T *) (0x40048000UL))->SYSAHBCLKCTRL & ~0xda100000);
N}
N
N/**
N * @brief	Disable system or peripheral clock
N * @param	clk	: Clock to disable
N * @return	Nothing
N */
NSTATIC INLINE void Chip_Clock_DisablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
Xstatic __inline void Chip_Clock_DisablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
N{
N	LPC_SYSCTL->SYSAHBCLKCTRL &= ~((1 << clk) | SYSCTL_SYSAHBCLKCTRL_RESERVED);
X	((LPC_SYSCTL_T *) (0x40048000UL))->SYSAHBCLKCTRL &= ~((1 << clk) | 0xda100000);
N}
N
N/**
N * @brief	Set UART divider clock
N * @param	div	: divider for UART clock
N * @return	Nothing
N * @note	Use 0 to disable, or a divider value of 1 to 255. The UART clock
N * rate is the main system clock divided by this value.
N */
NSTATIC INLINE void Chip_Clock_SetUARTClockDiv(uint32_t div)
Xstatic __inline void Chip_Clock_SetUARTClockDiv(uint32_t div)
N{
N	LPC_SYSCTL->UARTCLKDIV = div;
X	((LPC_SYSCTL_T *) (0x40048000UL))->UARTCLKDIV = div;
N}
N
N/**
N * @brief	Return UART divider
N * @return	divider for UART clock
N * @note	A value of 0 means the clock is disabled.
N */
NSTATIC INLINE uint32_t Chip_Clock_GetUARTClockDiv(void)
Xstatic __inline uint32_t Chip_Clock_GetUARTClockDiv(void)
N{
N	return LPC_SYSCTL->UARTCLKDIV & ~SYSCTL_UARTCLKDIV_RESERVED;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->UARTCLKDIV & ~(~0xff);
N}
N
N/**
N * @brief	Set The USART Fractional Generator Divider
N * @param   div  :  Fractional Generator Divider value, should be 0xFF
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_SetUSARTFRGDivider(uint8_t div)
Xstatic __inline void Chip_SYSCTL_SetUSARTFRGDivider(uint8_t div)
N{
N	LPC_SYSCTL->UARTFRGDIV = (uint32_t) div;
X	((LPC_SYSCTL_T *) (0x40048000UL))->UARTFRGDIV = (uint32_t) div;
N}
N
N/**
N * @brief	Get The USART Fractional Generator Divider
N * @return	Value of USART Fractional Generator Divider
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetUSARTFRGDivider(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetUSARTFRGDivider(void)
N{
N	return LPC_SYSCTL->UARTFRGDIV & ~SYSCTL_UARTFRGDIV_RESERVED;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->UARTFRGDIV & ~(~0xff);
N}
N
N/**
N * @brief	Set The USART Fractional Generator Multiplier
N * @param   mult  :  An 8-bit value (0-255) U_PCLK = UARTCLKDIV/(1 + MULT/256)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SYSCTL_SetUSARTFRGMultiplier(uint8_t mult)
Xstatic __inline void Chip_SYSCTL_SetUSARTFRGMultiplier(uint8_t mult)
N{
N	LPC_SYSCTL->UARTFRGMULT = (uint32_t) mult;
X	((LPC_SYSCTL_T *) (0x40048000UL))->UARTFRGMULT = (uint32_t) mult;
N}
N
N/**
N * @brief	Get The USART Fractional Generator Multiplier
N * @return	Value of USART Fractional Generator Multiplier
N */
NSTATIC INLINE uint32_t Chip_SYSCTL_GetUSARTFRGMultiplier(void)
Xstatic __inline uint32_t Chip_SYSCTL_GetUSARTFRGMultiplier(void)
N{
N	return LPC_SYSCTL->UARTFRGMULT & ~SYSCTL_UARTFRGMULT_RESERVED;
X	return ((LPC_SYSCTL_T *) (0x40048000UL))->UARTFRGMULT & ~(~0xff);
N}
N
N/**
N * @brief	Set USART 0/1/2 UART base rate (up to main clock rate)
N * @param	rate	: Desired rate for fractional divider/multipler output
N * @param	fEnable	: true to use fractional clocking, false for integer clocking
N * @return	Actual rate generated
N * @note	USARTs 0 - 2 use the same base clock for their baud rate
N *			basis. This function is used to generate that clock, while the
N *			UART driver's SetBaud functions will attempt to get the closest
N *			baud rate from this base clock without altering it. This needs
N *			to be setup prior to individual UART setup.<br>
N *			UARTs need a base clock 16x faster than the baud rate, so if you
N *			need a 115.2Kbps baud rate, you will need a clock rate of at
N *			least (115.2K * 16). The UART base clock is generated from the
N *			main system clock, so fractional clocking may be the only
N *			possible choice when using a low main system clock frequency.
N *			Do not alter the FRGCLKDIV register after this call.
N */
Nuint32_t Chip_Clock_SetUSARTNBaseClockRate(uint32_t rate, bool fEnable);
Xuint32_t Chip_Clock_SetUSARTNBaseClockRate(uint32_t rate, _Bool fEnable);
N
N/**
N * @brief	Get USART 0/1/2 UART base rate
N * @return	USART 0/1/2 UART base rate
N */
Nuint32_t Chip_Clock_GetUSARTNBaseClockRate(void);
N
N/**
N * @brief	Returns the main oscillator clock rate
N * @return	main oscillator clock rate
N */
NSTATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
Xstatic __inline uint32_t Chip_Clock_GetMainOscRate(void)
N{
N	return OscRateIn;
N}
N
N/**
N * @brief	Returns the internal oscillator (IRC) clock rate
N * @return	internal oscillator (IRC) clock rate
N */
NSTATIC INLINE uint32_t Chip_Clock_GetIntOscRate(void)
Xstatic __inline uint32_t Chip_Clock_GetIntOscRate(void)
N{
N	return SYSCTL_IRC_FREQ;
X	return (12000000);
N}
N
N/**
N * @brief	Returns the external clock input rate
N * @return	External clock input rate
N */
NSTATIC INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
Xstatic __inline uint32_t Chip_Clock_GetExtClockInRate(void)
N{
N	return ExtRateIn;
N}
N
N/**
N * @brief	Set System PLL clock source
N * @param	src	: Clock source for system PLL
N * @return	Nothing
N * @note	This function will also toggle the clock source update register
N * to update the clock source
N */
Nvoid Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src);
N
N/**
N * @brief	Bypass System Oscillator and set oscillator frequency range
N * @param	bypass	: Flag to bypass oscillator
N * @param	highfr	: Flag to set oscillator range from 15-25 MHz
N * @return	Nothing
N * @note	Sets the PLL input to bypass the oscillator. This would be
N * used if an external clock that is not an oscillator is attached
N * to the XTALIN pin.
N */
Nvoid Chip_Clock_SetPLLBypass(bool bypass, bool highfr);
Xvoid Chip_Clock_SetPLLBypass(_Bool bypass, _Bool highfr);
N
N/**
N * @brief	Set main system clock source
N * @param	src	: Clock source for main system
N * @return	Nothing
N * @note	This function will also toggle the clock source update register
N * to update the clock source
N */
Nvoid Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src);
N
N/**
N * @brief	Set CLKOUT clock source and divider
N * @param	src	: Clock source for CLKOUT
N * @param	div	: divider for CLKOUT clock
N * @return	Nothing
N * @note	Use 0 to disable, or a divider value of 1 to 255. The CLKOUT clock
N * rate is the clock source divided by the divider. This function will
N * also toggle the clock source update register to update the clock
N * source.
N */
Nvoid Chip_Clock_SetCLKOUTSource(CHIP_SYSCTL_CLKOUTSRC_T src, uint32_t div);
N
N/**
N * @brief	Return estimated watchdog oscillator rate
N * @return	Estimated watchdog oscillator rate
N * @note	This rate is accurate to plus or minus 40%.
N */
Nuint32_t Chip_Clock_GetWDTOSCRate(void);
N
N/**
N * @brief	Return System PLL input clock rate
N * @return	System PLL input clock rate
N */
Nuint32_t Chip_Clock_GetSystemPLLInClockRate(void);
N
N/**
N * @brief	Return System PLL output clock rate
N * @return	System PLL output clock rate
N */
Nuint32_t Chip_Clock_GetSystemPLLOutClockRate(void);
N
N/**
N * @brief	Return main clock rate
N * @return	main clock rate
N */
Nuint32_t Chip_Clock_GetMainClockRate(void);
N
N/**
N * @brief	Return system clock rate
N * @return	system clock rate
N */
Nuint32_t Chip_Clock_GetSystemClockRate(void);
N
N/**
N * @brief	Get IOCONCLKDIV clock rate
N * @param	reg	: Divider register to get
N * @return	The clock rate going to the IOCON glitch filter
N * @note	Use 0 to disable, or a divider value of 1 to 255.
N */
Nuint32_t Chip_Clock_GetIOCONCLKDIVClockRate(CHIP_PIN_CLKDIV_T reg);
N
N/**
N * @brief	Set IOCONCLKDIV divider
N * @param	reg	: divider register to set
N * @param	div	: divider value for IOCONCLKDIV[reg] clock
N * @return	Nothing
N * @note	Use 0 to disable, or a divider value of 1 to 255.
N */
Nvoid Chip_Clock_SetIOCONCLKDIV(CHIP_PIN_CLKDIV_T reg, uint8_t div);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CLOCK_8XX_H_ */
L 178 ".\lpc_chip_82x\inc\chip.h" 2
N#include "iocon_8xx.h"
L 1 ".\lpc_chip_82x\inc\iocon_8xx.h" 1
N/*
N * @brief LPC8xx IOCON register block and driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __IOCON_8XX_H_
N#define __IOCON_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup IOCON_8XX CHIP: LPC8xx IOCON register block and driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N#define NUM_IOCON_PIO  (29)
N
N/**
N * @brief Array of IOCON pin definitions passed to Chip_IOCON_SetPinMuxing() must be in this format
N */
Ntypedef struct {
N	uint32_t pin:8;			/* Pin number */
N	uint32_t modefunc:24;	/* Function and mode */
N} PINMUX_GRP_T;
N
N/**
N * @brief	IOCON register block structure
N * @note	When accessing this register structure, use the PIOn enumeration
N * as the array index as the pin assignments are not mapped 1-1 with the
N * IOCON structure.<br>
N * Incorrect: LPC_IOCON->PIO0[0] = 0x1; // Index 0 does not map to pin 0!<br>
N * Correct: LPC_IOCON->PIO0[IOCON_PIO0] = 0x1; // Enumeration PIO0 maps to pin 0
N */
Ntypedef struct {		/*!< (@ 0x40044000) IOCONFIG Structure     */
N	__IO uint32_t PIO0[NUM_IOCON_PIO + 2]; /* 2 added for reserved register */
X	volatile uint32_t PIO0[(29) + 2];  
N} LPC_IOCON_T;
N
N/**
N * @brief IOCON Register bit definitions
N */
N/* Pin Mode mask */
N#define PIN_MODE_MASK           (0x3 <<  3)
N#define PIN_MODE_BITNUM         (3)
N
N/* Pin Hysteresis mask */
N#define PIN_HYS_MASK            (0x1 <<  5)
N#define PIN_HYS_BITNUM          (5)
N
N/* Pin invert input mask */
N#define PIN_INV_MASK            (0x1 <<  6)
N#define PIN_INV_BITNUM          (6)
N
N/* Pin open drain mode mask */
N#define PIN_OD_MASK             (0x1 << 10)
N#define PIN_OD_BITNUM           (10)
N
N/* Pin digital filter sample mode mask */
N#define PIN_SMODE_MASK          (0x3 << 11)
N#define PIN_SMODE_BITNUM        (11)
N
N/* Pin clock divider mask */
N#define PIN_CLKDIV_MASK         (0x7 << 13)
N#define PIN_CLKDIV_BITNUM       (13)
N
N/* Pin I2C mode mask - valid for PIO10 & PIO11 only */
N#define PIN_I2CMODE_MASK        (0x3 <<  8)
N#define PIN_I2CMODE_BITNUM      (8)
N
N/**
N * @brief IOCON Pin Numbers enum
N * Maps a pin number to an IOCON (register) array index. IOCON indexes
N * are not mapped 1-1 with pin numbers. When access the PIO0 array in
N * the LPC_IOCON_T structure, the array should be indexed with one of
N * these enumerations based on the pin that will have it's settings
N * changed.<br>
N * Example: LPC_IOCON->PIO0[IOCON_PIO0] = 0x1; // Enumeration PIO0 maps to pin 0
N */
Ntypedef enum CHIP_PINx {
N	IOCON_PIO0  =  0x11,	/*!< PIN 0 */
N	IOCON_PIO1  =  0x0B,	/*!< PIN 1 */
N	IOCON_PIO2  =  0x06,	/*!< PIN 2 */
N	IOCON_PIO3  =  0x05,	/*!< PIN 3 */
N	IOCON_PIO4  =  0x04,	/*!< PIN 4 */
N	IOCON_PIO5  =  0x03,	/*!< PIN 5 */
N	/* The following pins are not present in DIP8 packages */
N	IOCON_PIO6  =  0x10,	/*!< PIN 6 */
N	IOCON_PIO7  =  0x0F,	/*!< PIN 7 */
N	IOCON_PIO8  =  0x0E,	/*!< PIN 8 */
N	IOCON_PIO9  =  0x0D,	/*!< PIN 9 */
N	IOCON_PIO10 =  0x08,	/*!< PIN 10 */
N	IOCON_PIO11 =  0x07,	/*!< PIN 11 */
N	IOCON_PIO12 =  0x02,	/*!< PIN 12 */
N	IOCON_PIO13 =  0x01,	/*!< PIN 13 */
N	/* The following pins are not present in DIP8 & TSSOP16 packages */
N	IOCON_PIO14 =  0x12,	/*!< PIN 14 */
N	IOCON_PIO15 =  0x0A,	/*!< PIN 15 */
N	IOCON_PIO16 =  0x09,	/*!< PIN 16 */
N	IOCON_PIO17 =  0x00,	/*!< PIN 17 */
N	IOCON_PIO_NUL0 = 0x0C,	/*!< PIN NULL */
N
N	/* The following pins are not present in DIP8, TSSOP16 & TSSOP20 packages */
N	IOCON_PIO18 =  0x1E,	/*!< PIN 18 */
N	IOCON_PIO19 =  0x1D,	/*!< PIN 19 */
N	IOCON_PIO20 =  0x1C,	/*!< PIN 20 */
N	IOCON_PIO21 =  0x1B,	/*!< PIN 21 */
N	IOCON_PIO22 =  0x1A,	/*!< PIN 22 */
N	IOCON_PIO23 =  0x19,	/*!< PIN 23 */
N	IOCON_PIO24 =  0x18,	/*!< PIN 24 */
N	IOCON_PIO25 =  0x17,	/*!< PIN 25 */
N	IOCON_PIO26 =  0x16,	/*!< PIN 26 */
N	IOCON_PIO27 =  0x15,	/*!< PIN 27 */
N	IOCON_PIO28 =  0x14,	/*!< PIN 28 */
N	IOCON_PIO_NUL1 = 0x13,	/*!< PIN NULL */
N} CHIP_PINx_T;
N
N/**
N * @brief IOCON Pin Modes enum
N */
Ntypedef enum CHIP_PIN_MODE {
N	PIN_MODE_INACTIVE = 0,	/*!< Inactive mode */
N	PIN_MODE_PULLDN = 1,	/*!< Pull Down mode */
N	PIN_MODE_PULLUP = 2,	/*!< Pull up mode */
N	PIN_MODE_REPEATER = 3	/*!< Repeater mode */
N} CHIP_PIN_MODE_T;
N
N/**
N * @brief IOCON Digital Filter Sample modes enum
N */
Ntypedef enum CHIP_PIN_SMODE {
N	PIN_SMODE_BYPASS = 0,	/*!< Bypass input filter */
N	PIN_SMODE_CYC1 = 1,		/*!< Input pulses shorter than 1 filter clock cycle are rejected */
N	PIN_SMODE_CYC2 = 2,		/*!< Input pulses shorter than 2 filter clock cycles are rejected */
N	PIN_SMODE_CYC3 = 3		/*!< Input pulses shorter than 3 filter clock cycles are rejected */
N} CHIP_PIN_SMODE_T;
N
N/**
N * @brief IOCON I2C Modes enum (Only for I2C pins PIO0_10 and PIO0_11)
N */
Ntypedef enum CHIP_PIN_I2CMODE {
N	PIN_I2CMODE_STDFAST = 0,	/*!< I2C standard mode/Fast mode */
N	PIN_I2CMODE_GPIO = 1,		/*!< Standard I/O functionality */
N	PIN_I2CMODE_FASTPLUS = 2	/*!< I2C Fast plus mode */
N} CHIP_PIN_I2CMODE_T;
N
N/**
N * @brief	Sets I/O Control pin mux
N * @param	pIOCON		: The base of IOCON peripheral on the chip
N * @param	pin			: GPIO pin to mux
N * @param	modefunc	: OR'ed values or type IOCON_*
N * @return	Nothing
N */
NSTATIC INLINE void Chip_IOCON_PinMuxSet(LPC_IOCON_T *pIOCON, uint8_t pin, uint32_t modefunc)
Xstatic __inline void Chip_IOCON_PinMuxSet(LPC_IOCON_T *pIOCON, uint8_t pin, uint32_t modefunc)
N{
N	pIOCON->PIO0[pin] = modefunc;
N}
N
N/**
N * @brief	Set all I/O Control pin muxing
N * @param	pIOCON	    : The base of IOCON peripheral on the chip
N * @param	pinArray    : Pointer to array of pin mux selections
N * @param	arrayLength : Number of entries in pinArray
N * @return	Nothing
N */
Nvoid Chip_IOCON_SetPinMuxing(LPC_IOCON_T *pIOCON, const PINMUX_GRP_T* pinArray, uint32_t arrayLength);
N
N/**
N * @brief	Sets pull-up or pull-down mode for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @param	mode	: Mode (Pull-up/Pull-down mode)
N * @return	Nothing
N * @note	Do not use with pins PIO10 and PIO11.
N */
Nvoid Chip_IOCON_PinSetMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, CHIP_PIN_MODE_T mode);
N
N/**
N * @brief	Enable or disable hysteresis for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @param	enable	: true to enable, false to disable
N * @return	Nothing
N * @note	Do not use with pins PIO10 and PIO11.
N */
Nvoid Chip_IOCON_PinSetHysteresis(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, bool enable);
Xvoid Chip_IOCON_PinSetHysteresis(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, _Bool enable);
N
N/**
N * @brief	Enable hysteresis for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @return	Nothing
N * @note	Do not use with pins PIO10 and PIO11.
N */
NSTATIC INLINE void Chip_IOCON_PinEnableHysteresis(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
Xstatic __inline void Chip_IOCON_PinEnableHysteresis(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
N{
N	pIOCON->PIO0[pin] |= PIN_HYS_MASK;
X	pIOCON->PIO0[pin] |= (0x1 << 5);
N}
N
N/**
N * @brief	Disable hysteresis for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @return	Nothing
N * @note	Do not use with pins PIO10 and PIO11.
N */
NSTATIC INLINE void Chip_IOCON_PinDisableHysteresis(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
Xstatic __inline void Chip_IOCON_PinDisableHysteresis(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
N{
N	pIOCON->PIO0[pin] &= ~PIN_HYS_MASK;
X	pIOCON->PIO0[pin] &= ~(0x1 << 5);
N}
N
N/**
N * @brief	Enable or disable invert input for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @param	invert	: true to invert, false to not to invert
N * @return	Nothing
N */
Nvoid Chip_IOCON_PinSetInputInverted(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, bool invert);
Xvoid Chip_IOCON_PinSetInputInverted(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, _Bool invert);
N
N/**
N * @brief	Enable invert input for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @return	Nothing
N */
NSTATIC INLINE void Chip_IOCON_PinEnableInputInverted(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
Xstatic __inline void Chip_IOCON_PinEnableInputInverted(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
N{
N	pIOCON->PIO0[pin] |= PIN_INV_MASK;
X	pIOCON->PIO0[pin] |= (0x1 << 6);
N}
N
N/**
N * @brief	Disable invert input for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @return	Nothing
N */
NSTATIC INLINE void Chip_IOCON_PinDisableInputInverted(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
Xstatic __inline void Chip_IOCON_PinDisableInputInverted(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
N{
N	pIOCON->PIO0[pin] &= ~PIN_INV_MASK;
X	pIOCON->PIO0[pin] &= ~(0x1 << 6);
N}
N
N/**
N * @brief	Enables or disables open-drain mode for a pin
N * @param	pIOCON		: The base of IOCON peripheral on the chip
N * @param	pin			: Pin number
N * @param	open_drain	: true to enable open-drain mode,
N *                        false to disable open-drain mode
N * @return	Nothing
N */
Nvoid Chip_IOCON_PinSetOpenDrainMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, bool open_drain);
Xvoid Chip_IOCON_PinSetOpenDrainMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, _Bool open_drain);
N
N/**
N * @brief	Enables open-drain mode for a pin
N * @param	pIOCON		: The base of IOCON peripheral on the chip
N * @param	pin			: Pin number
N * @return	Nothing
N */
NSTATIC INLINE void Chip_IOCON_PinEnableOpenDrainMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
Xstatic __inline void Chip_IOCON_PinEnableOpenDrainMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
N{
N	pIOCON->PIO0[pin] |= PIN_OD_MASK;
X	pIOCON->PIO0[pin] |= (0x1 << 10);
N}
N
N/**
N * @brief	Disables open-drain mode for a pin
N * @param	pIOCON		: The base of IOCON peripheral on the chip
N * @param	pin			: Pin number
N * @return	Nothing
N */
NSTATIC INLINE void Chip_IOCON_PinDisableOpenDrainMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
Xstatic __inline void Chip_IOCON_PinDisableOpenDrainMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin)
N{
N	pIOCON->PIO0[pin] &= ~PIN_OD_MASK;
X	pIOCON->PIO0[pin] &= ~(0x1 << 10);
N}
N
N/**
N * @brief	Sets the digital filter sampling mode for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @param	smode	: 0x0 = bypass, 0x[1..3] = 1 to 3 clock cycles.
N * @return	Nothing
N */
Nvoid Chip_IOCON_PinSetSampleMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, CHIP_PIN_SMODE_T smode);
N
N/**
N * @brief	Select peripheral clock divider for input filter sampling clock
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @param	clkdiv	: 0 = no divisor, 1...6 = PCLK/clkdiv
N * @return	Nothing
N */
Nvoid Chip_IOCON_PinSetClockDivisor(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, CHIP_PIN_CLKDIV_T clkdiv);
N
N/**
N * @brief	Set I2C mode for a pin
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	pin		: Pin number
N * @param	mode	: 0:Standard/Fast I2C 1: GPIO 2: Fast Plus
N * @return	Nothing
N * @note	Valid for pins PIO0_10 and PIO0_11 only.
N */
Nvoid Chip_IOCON_PinSetI2CMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, CHIP_PIN_I2CMODE_T mode);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __IOCON_8XX_H_ */
L 179 ".\lpc_chip_82x\inc\chip.h" 2
N#include "swm_8xx.h"
L 1 ".\lpc_chip_82x\inc\swm_8xx.h" 1
N/*
N * @brief LPC8xx Switch Matrix driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SWM_8XX_H_
N#define __SWM_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SWM_8XX CHIP: LPC8xx Switch Matrix Driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief LPC8XX Switch Matrix register block structure
N */
Ntypedef struct {
N#if defined(CHIP_LPC82X)
X#if 1L
N	__IO uint32_t PINASSIGN[12];	/*!< Pin Assign register array */
X	volatile uint32_t PINASSIGN[12];	 
N	__I  uint32_t RESERVED0[100];
X	volatile const  uint32_t RESERVED0[100];
N#else
S	__IO uint32_t PINASSIGN[9];		/*!< Pin Assign register array */
S	__I  uint32_t RESERVED0[103];
N#endif
N	__IO uint32_t PINENABLE0;		/*!< Pin Enable register */
X	volatile uint32_t PINENABLE0;		 
N} LPC_SWM_T;
N
N#if defined(CHIP_LPC82X)
X#if 1L
N#define SWM_PINENABLE0_RESERVED  (~0x1ffffff)
N#else
S#define SWM_PINENABLE0_RESERVED  (~0x1ff)
N#endif
N
N/**
N * @brief LPC8XX Switch Matrix Movable pins
N */
N#if defined(CHIP_LPC82X)
X#if 1L
Ntypedef enum CHIP_SWM_PIN_MOVABLE {
N	SWM_U0_TXD_O,                /*!< PINASSIGN0 - UART0 TXD Output */
N	SWM_U0_RXD_I,                /*!< PINASSIGN0 - UART0 RXD Input */
N	SWM_U0_RTS_O,                /*!< PINASSIGN0 - UART0 RTS Output */
N	SWM_U0_CTS_I,                /*!< PINASSIGN0 - UART0 CTS Input */
N
N	SWM_U0_SCLK_IO = 0x10,       /*!< PINASSIGN1 - UART0 SCLK I/O */
N	SWM_U1_TXD_O,                /*!< PINASSIGN1 - UART1 TXD Output */
N	SWM_U1_RXD_I,                /*!< PINASSIGN1 - UART1 RXD Input */
N	SWM_U1_RTS_O,                /*!< PINASSIGN1 - UART1 RTS Output */
N
N	SWM_U1_CTS_I = 0x20,         /*!< PINASSIGN2 - UART1 CTS Input */
N	SWM_U1_SCLK_IO,              /*!< PINASSIGN2 - UART1 SCLK I/O */
N	SWM_U2_TXD_O,                /*!< PINASSIGN2 - UART2 TXD Output */
N	SWM_U2_RXD_I,                /*!< PINASSIGN2 - UART2 RXD Input */
N
N	SWM_U2_RTS_O = 0x30,         /*!< PINASSIGN3 - UART2 RTS Output */
N	SWM_U2_CTS_I,                /*!< PINASSIGN3 - UART2 CTS Input */
N	SWM_U2_SCLK_IO,              /*!< PINASSIGN3 - UART2 SCLK I/O */
N	SWM_SPI0_SCK_IO,             /*!< PINASSIGN3 - SPI0 SCK I/O */
N
N	SWM_SPI0_MOSI_IO = 0x40,     /*!< PINASSIGN4 - SPI0 MOSI I/O */
N	SWM_SPI0_MISO_IO,            /*!< PINASSIGN4 - SPI0 MISO I/O */
N	SWM_SPI0_SSEL0_IO,           /*!< PINASSIGN4 - SPI0 SSEL0 I/O */
N	SWM_SPI0_SSEL1_IO,           /*!< PINASSIGN4 - SPI0 SSEL1 I/O */
N
N	SWM_SPI0_SSEL2_IO = 0x50,    /*!< PINASSIGN5 - SPI0 SSEL2 I/O */
N	SWM_SPI0_SSEL3_IO,           /*!< PINASSIGN5 - SPI0 SSEL3 I/O */
N	SWM_SPI1_SCK_IO,             /*!< PINASSIGN5 - SPI1 SCK I/O */
N	SWM_SPI1_MOSI_IO,            /*!< PINASSIGN5 - SPI1 MOSI I/O */
N
N	SWM_SPI1_MISO_IO = 0x60,     /*!< PINASSIGN6 - SPI1 MISO I/O */
N	SWM_SPI1_SSEL0_IO,           /*!< PINASSIGN6 - SPI1 SSEL0 I/O */
N	SWM_SPI1_SSEL1_IO,           /*!< PINASSIGN6 - SPI1 SSEL1 I/O */
N	SWM_SCT_IN0_I,               /*!< PINASSIGN6 - SCT INPUT_0 Input */
N
N	SWM_SCT_IN1_I = 0x70,        /*!< PINASSIGN7 - SCT INPUT_1 Input */
N	SWM_SCT_IN2_I,               /*!< PINASSIGN7 - SCT INPUT_2 Input */
N	SWM_SCT_IN3_I,               /*!< PINASSIGN7 - SCT INPUT_3 Input */
N	SWM_SCT_OUT0_O,              /*!< PINASSIGN7 - SCT OUTPUT_0 Output */
N
N	SWM_SCT_OUT1_O = 0x80,       /*!< PINASSIGN8 - SCT OUTPUT_1 Output */
N	SWM_SCT_OUT2_O,              /*!< PINASSIGN8 - SCT OUTPUT_2 Output */
N	SWM_SCT_OUT3_O,              /*!< PINASSIGN8 - SCT OUTPUT_3 Output */
N	SWM_SCT_OUT4_O,              /*!< PINASSIGN8 - SCT OUTPUT_4 Output */
N
N	SWM_SCT_OUT5_O = 0x90,       /*!< PINASSIGN9 - SCT OUTPUT_5 Output */
N	SWM_I2C1_SDA_IO,             /*!< PINASSIGN9 - I2C1 SDA I/O */
N	SWM_I2C1_SCL_IO,             /*!< PINASSIGN9 - I2C1 SCL I/O */
N	SWM_I2C2_SDA_IO,             /*!< PINASSIGN9 - I2C2 SDA I/O */
N
N	SWM_I2C2_SCL_IO = 0xA0,      /*!< PINASSIGN10 - I2C2 SCL I/O */
N	SWM_I2C3_SDA_IO,             /*!< PINASSIGN10 - I2C3 SDA I/O */
N	SWM_I2C3_SCL_IO,             /*!< PINASSIGN10 - I2C3 SCL I/O */
N	SWM_ADC_PINTRIG0_I,          /*!< PINASSIGN10 - ADC PIN TRIGGER-0 Input */
N
N	SWM_ADC_PINTRIG1_I = 0xB0,   /*!< PINASSIGN11 - ADC PIN TRIGGER-1 Input */
N	SWM_ACMP_O_O,                /*!< PINASSIGN11 - ACMP OUT Output */
N	SWM_CLKOUT_O,                /*!< PINASSIGN11 - CLKOUT Output */
N	SWM_GPIO_INT_BMAT_O,         /*!< PINASSIGN11 - GPIO INT BMAT Output */
N
N} CHIP_SWM_PIN_MOVABLE_T;
N#else
Stypedef enum CHIP_SWM_PIN_MOVABLE  {
S	SWM_U0_TXD_O        = 0x00,	/*!< PINASSIGN0 - UART0 TXD Output */
S	SWM_U0_RXD_I        = 0x01,	/*!< PINASSIGN0 - UART0 RXD Input */
S	SWM_U0_RTS_O        = 0x02,	/*!< PINASSIGN0 - UART0 RTS Output */
S	SWM_U0_CTS_I        = 0x03,	/*!< PINASSIGN0 - UART0 CTS Input */
S	SWM_U0_SCLK_IO      = 0x10,	/*!< PINASSIGN1 - UART0 SCLK I/O */
S	SWM_U1_TXD_O        = 0x11,	/*!< PINASSIGN1 - UART1 TXD Output */
S	SWM_U1_RXD_I        = 0x12,	/*!< PINASSIGN1 - UART1 RXD Input */
S	SWM_U1_RTS_O        = 0x13,	/*!< PINASSIGN1 - UART1 RTS Output */
S	SWM_U1_CTS_I        = 0x20,	/*!< PINASSIGN2 - UART1 CTS Input */
S	SWM_U1_SCLK_IO      = 0x21,	/*!< PINASSIGN2 - UART1 SCLK I/O */
S	SWM_U2_TXD_O        = 0x22,	/*!< PINASSIGN2 - UART2 TXD Output */
S	SWM_U2_RXD_I        = 0x23,	/*!< PINASSIGN2 - UART2 RXD Input */
S	SWM_U2_RTS_O        = 0x30,	/*!< PINASSIGN3 - UART2 RTS Output */
S	SWM_U2_CTS_I        = 0x31,	/*!< PINASSIGN3 - UART2 CTS Input */
S	SWM_U2_SCLK_IO      = 0x32,	/*!< PINASSIGN3 - UART2 SCLK I/O */
S	SWM_SPI0_SCK_IO     = 0x33,	/*!< PINASSIGN3 - SPI0 SCK I/O */
S	SWM_SPI0_MOSI_IO    = 0x40,	/*!< PINASSIGN4 - SPI0 MOSI I/O */
S	SWM_SPI0_MISO_IO    = 0x41,	/*!< PINASSIGN4 - SPI0 MISO I/O */
S	SWM_SPI0_SSEL_IO    = 0x42,	/*!< PINASSIGN4 - SPI0 SSEL I/O */
S	SWM_SPI1_SCK_IO     = 0x43,	/*!< PINASSIGN4 - SPI1 SCK I/O */
S	SWM_SPI1_MOSI_IO    = 0x50,	/*!< PINASSIGN5 - SPI1 MOSI I/O */
S	SWM_SPI1_MISO_IO    = 0x51,	/*!< PINASSIGN5 - SPI1 MISO I/O */
S	SWM_SPI1_SSEL_IO    = 0x52,	/*!< PINASSIGN5 - SPI1 SSEL I/O */
S	SWM_CTIN_0_I        = 0x53,	/*!< PINASSIGN5 - CTIN0 Input */
S	SWM_CTIN_1_I        = 0x60,	/*!< PINASSIGN6 - CTIN1 Input */
S	SWM_CTIN_2_I        = 0x61,	/*!< PINASSIGN6 - CTIN2 Input */
S	SWM_CTIN_3_I        = 0x62,	/*!< PINASSIGN6 - CTIN3 Input */
S	SWM_CTOUT_0_O       = 0x63,	/*!< PINASSIGN6 - CTOUT0 Output */
S	SWM_CTOUT_1_O       = 0x70,	/*!< PINASSIGN7 - CTOUT1 Output */
S	SWM_CTOUT_2_O       = 0x71,	/*!< PINASSIGN7 - CTOUT2 Output */
S	SWM_CTOUT_3_O       = 0x72,	/*!< PINASSIGN7 - CTOUT3 Output */
S	SWM_I2C_SDA_IO      = 0x73,	/*!< PINASSIGN7 - I2C SDA I/O */
S	SWM_I2C_SCL_IO      = 0x80,	/*!< PINASSIGN8 - I2C SCL I/O */
S	SWM_ACMP_O_O        = 0x81,	/*!< PINASSIGN8 - I2C ACMP Output */
S	SWM_CLKOUT_O        = 0x82,	/*!< PINASSIGN8 - I2C CLKOUT Output */
S	SWM_GPIO_INT_BMAT_O = 0x83,	/*!< PINASSIGN8 - I2C GPIO INT BMAT Output */
S} CHIP_SWM_PIN_MOVABLE_T;
N#endif
N
N/**
N * @brief LPC8XX Switch Matrix Fixed pins
N */
N#if defined(CHIP_LPC82X)
X#if 1L
Ntypedef enum CHIP_SWM_PIN_FIXED    {
N	SWM_FIXED_ACMP_I1 = 0,	/*!< ACMP I1 */
N	SWM_FIXED_ACMP_I2 = 1,	/*!< ACMP I2 */
N	SWM_FIXED_ACMP_I3 = 2,	/*!< ACMP I3 */
N	SWM_FIXED_ACMP_I4 = 3,	/*!< ACMP I4 */
N	SWM_FIXED_SWCLK   = 4,	/*!< SWCLK */
N	SWM_FIXED_SWDIO   = 5,	/*!< SWDIO */
N	SWM_FIXED_XTALIN  = 6,	/*!< XTALIN */
N	SWM_FIXED_XTALOUT = 7,	/*!< XTALOUT */
N	SWM_FIXED_RST     = 8,	/*!< Reset */
N	SWM_FIXED_CLKIN   = 9,	/*!< Clock Input */
N	SWM_FIXED_VDDCMP  = 10,	/*!< VDD */
N	SWM_FIXED_I2C0_SDA  = 11,	/*!< I2C0 SDA */
N	SWM_FIXED_I2C0_SCL  = 12,	/*!< I2C0 SCL */
N	SWM_FIXED_ADC0    = 13,	/*!< ADC0 */
N	SWM_FIXED_ADC1    = 14,	/*!< ADC1 */
N	SWM_FIXED_ADC2    = 15,	/*!< ADC2 */
N	SWM_FIXED_ADC3    = 16,	/*!< ADC3 */
N	SWM_FIXED_ADC4    = 17,	/*!< ADC4 */
N	SWM_FIXED_ADC5    = 18,	/*!< ADC5 */
N	SWM_FIXED_ADC6    = 19,	/*!< ADC6 */
N	SWM_FIXED_ADC7    = 20,	/*!< ADC7 */
N	SWM_FIXED_ADC8    = 21,	/*!< ADC8 */
N	SWM_FIXED_ADC9    = 22,	/*!< ADC9 */
N	SWM_FIXED_ADC10   = 23,	/*!< ADC10 */
N	SWM_FIXED_ADC11   = 24,	/*!< ADC11 */
N} CHIP_SWM_PIN_FIXED_T;
N#else
Stypedef enum CHIP_SWM_PIN_FIXED    {
S	SWM_FIXED_ACMP_I1 = 0,	/*!< ACMP I1 */
S	SWM_FIXED_ACMP_I2 = 1,	/*!< ACMP I2 */
S	SWM_FIXED_SWCLK   = 2,	/*!< SWCLK */
S	SWM_FIXED_SWDIO   = 3,	/*!< SWDIO */
S	SWM_FIXED_XTALIN  = 4,	/*!< XTALIN */
S	SWM_FIXED_XTALOUT = 5,	/*!< XTALOUT */
S	SWM_FIXED_RST     = 6,	/*!< Reset */
S	SWM_FIXED_CLKIN   = 7,	/*!< Clock Input */
S	SWM_FIXED_VDDCMP  = 8	/*!< VDD */
S} CHIP_SWM_PIN_FIXED_T;
N#endif
N
N/**
N * @brief	Initialise the SWM module
N * @return	Nothing
N * @note	This function only enables the SWM clock.
N */
NSTATIC INLINE void Chip_SWM_Init(void)
Xstatic __inline void Chip_SWM_Init(void)
N{
N	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);
N}
N
N/**
N * @brief	Deinitialise the SWM module
N * @return	Nothing
N * @note	This function only disables the SWM clock.
N */
NSTATIC INLINE void Chip_SWM_Deinit(void)
Xstatic __inline void Chip_SWM_Deinit(void)
N{
N	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);
N}
N
N/**
N * @brief	Assign movable pin function to physical pin in Switch Matrix
N * @param	movable	: Movable pin function
N * @param	assign	: Physical pin to be assigned
N * @return	Nothing
N */
Nvoid Chip_SWM_MovablePinAssign(CHIP_SWM_PIN_MOVABLE_T movable, uint8_t assign);
N
N/**
N * @brief	Enables or Disable Fixed Function Pin in the Switch Matrix
N * @param	pin		: Pin to be enabled or disabled
N * @param	enable	: True to enable the pin, False to disable the pin
N * @return	Nothing
N */
Nvoid Chip_SWM_FixedPinEnable(CHIP_SWM_PIN_FIXED_T pin, bool enable);
Xvoid Chip_SWM_FixedPinEnable(CHIP_SWM_PIN_FIXED_T pin, _Bool enable);
N
N/**
N * @brief	Enables a Fixed Function Pin in the Switch Matrix
N * @param	pin		: Pin to be enabled
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SWM_EnableFixedPin(CHIP_SWM_PIN_FIXED_T pin)
Xstatic __inline void Chip_SWM_EnableFixedPin(CHIP_SWM_PIN_FIXED_T pin)
N{
N	LPC_SWM->PINENABLE0 &= ~((1 << (uint32_t) pin) | SWM_PINENABLE0_RESERVED);
X	((LPC_SWM_T *) (0x4000C000UL))->PINENABLE0 &= ~((1 << (uint32_t) pin) | (~0x1ffffff));
N}
N
N/**
N * @brief	Disables a Fixed Function Pin in the Switch Matrix
N * @param	pin		: Pin to be disabled
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SWM_DisableFixedPin(CHIP_SWM_PIN_FIXED_T pin)
Xstatic __inline void Chip_SWM_DisableFixedPin(CHIP_SWM_PIN_FIXED_T pin)
N{
N	LPC_SWM->PINENABLE0 = (1 << (uint32_t) pin) | (LPC_SWM->PINENABLE0 & ~SWM_PINENABLE0_RESERVED);
X	((LPC_SWM_T *) (0x4000C000UL))->PINENABLE0 = (1 << (uint32_t) pin) | (((LPC_SWM_T *) (0x4000C000UL))->PINENABLE0 & ~(~0x1ffffff));
N}
N
N/**
N * @brief	Tests whether a fixed pin is enabled or disabled in the Switch Matrix
N * @param	pin		: The pin to test whether it is enabled or disabled
N * @return	True if the pin is enabled, False if disabled
N */
NSTATIC INLINE bool Chip_SWM_IsEnabled(CHIP_SWM_PIN_FIXED_T pin)
Xstatic __inline _Bool Chip_SWM_IsEnabled(CHIP_SWM_PIN_FIXED_T pin)
N{
N	return (bool) ((LPC_SWM->PINENABLE0 & (1 << (uint32_t) pin)) == 0);
X	return (_Bool) ((((LPC_SWM_T *) (0x4000C000UL))->PINENABLE0 & (1 << (uint32_t) pin)) == 0);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SWM_8XX_H_ */
L 180 ".\lpc_chip_82x\inc\chip.h" 2
N#include "fmc_8xx.h"
L 1 ".\lpc_chip_82x\inc\fmc_8xx.h" 1
N/*
N * @brief LPC8xx FLASH Memory Controller (FMC) driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __FMC_8XX_H_
N#define __FMC_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup FMC_8XX CHIP: LPC8xx FLASH Memory Controller driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief FLASH Memory Controller Unit register block structure
N */
Ntypedef struct {
N	__I  uint32_t  RESERVED1[4];
X	volatile const  uint32_t  RESERVED1[4];
N	__IO uint32_t  FLASHCFG;		/*!< Flash Configuration register */
X	volatile uint32_t  FLASHCFG;		 
N	__I  uint32_t  RESERVED2[3];
X	volatile const  uint32_t  RESERVED2[3];
N	__IO uint32_t  FMSSTART;		/*!< Signature start address register */
X	volatile uint32_t  FMSSTART;		 
N	__IO uint32_t  FMSSTOP;			/*!< Signature stop address register */
X	volatile uint32_t  FMSSTOP;			 
N	__I  uint32_t  RESERVED3;
X	volatile const  uint32_t  RESERVED3;
N	__I  uint32_t  FMSW[1];			/*!< Signature word regsiter */
X	volatile const  uint32_t  FMSW[1];			 
N} LPC_FMC_T;
N
N/* Reserved bits masks for registers */
N#define FMC_FLASHCFG_RESERVED       (~3)
N#define FMC_FMSSTART_RESERVED       0xfffe0000
N#define FMC_FMSSTOP_RESERVED        0x7ffe0000
N
N/**
N * @brief FLASH Access time definitions
N */
Ntypedef enum {
N	FLASHTIM_20MHZ_CPU = 0,		/*!< Flash accesses use 1 CPU clocks. Use for up to 20 MHz CPU clock*/
N	FLASHTIM_30MHZ_CPU = 1, 	/*!< Flash accesses use 2 CPU clocks. Use for up to 30 MHz CPU clock*/
N} FMC_FLASHTIM_T;
N
N/**
N * @brief	Set FLASH memory access time in clocks
N * @param	clks	: Clock cycles for FLASH access
N * @return	Nothing
N * @note	For CPU speed up to 20MHz, use a value of 0. For up to 30MHz, use
N *			a value of 1
N */
NSTATIC INLINE void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
Xstatic __inline void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
N{
N	uint32_t tmp = LPC_FMC->FLASHCFG & (~((0x3)|FMC_FLASHCFG_RESERVED));
X	uint32_t tmp = ((LPC_FMC_T *) (0x40040000UL))->FLASHCFG & (~((0x3)|(~3)));
N
N	/* Don't alter upper bits */
N	LPC_FMC->FLASHCFG = tmp | clks;
X	((LPC_FMC_T *) (0x40040000UL))->FLASHCFG = tmp | clks;
N}
N
N/* Flash signature start and busy status bit */
N#define FMC_FLASHSIG_BUSY	(1UL << 31)
N
N/**
N * @brief	Start computation of a signature for a FLASH memory range
N * @param	start	: Starting FLASH address for computation, must be aligned on 16 byte boundary
N * @param	stop	: Ending FLASH address for computation, must be aligned on 16 byte boundary
N * @return	Nothing
N * @note	Only bits 20..4 are used for the FLASH signature computation.
N *			Use the Chip_FMC_IsSignatureBusy() function to determine when the
N *			signature computation operation is complete and the
N *			Chip_FMC_GetSignature() function to get the computed signature.
N */
NSTATIC INLINE void Chip_FMC_ComputeSignature(uint32_t start, uint32_t stop)
Xstatic __inline void Chip_FMC_ComputeSignature(uint32_t start, uint32_t stop)
N{
N	LPC_FMC->FMSSTART = (start >> 4);
X	((LPC_FMC_T *) (0x40040000UL))->FMSSTART = (start >> 4);
N	LPC_FMC->FMSSTOP = (stop >> 4) | FMC_FLASHSIG_BUSY;
X	((LPC_FMC_T *) (0x40040000UL))->FMSSTOP = (stop >> 4) | (1UL << 31);
N}
N
N/**
N * @brief	Start computation of a signature for a FLASH memory address and block count
N * @param	start	: Starting FLASH address for computation, must be aligned on 16 byte boundary
N * @param	blocks	: Number of 16 byte blocks used for computation
N * @return	Nothing
N * @note	Only bits 20..4 are used for the FLASH signature computation.
N *			Use the Chip_FMC_IsSignatureBusy() function to determine when the
N *			signature computation operation is complete and the
N *			Chip_FMC_GetSignature() function to get the computed signature.
N */
NSTATIC INLINE void Chip_FMC_ComputeSignatureBlocks(uint32_t start, uint32_t blocks)
Xstatic __inline void Chip_FMC_ComputeSignatureBlocks(uint32_t start, uint32_t blocks)
N{
N	Chip_FMC_ComputeSignature(start, (start + (blocks * 16)));
N}
N
N/**
N * @brief	Check for signature geenration completion
N * @return	true if the signature computation is running, false if finished
N */
NSTATIC INLINE bool Chip_FMC_IsSignatureBusy(void)
Xstatic __inline _Bool Chip_FMC_IsSignatureBusy(void)
N{
N	return (bool) ((LPC_FMC->FMSSTOP & FMC_FLASHSIG_BUSY) != 0);
X	return (_Bool) ((((LPC_FMC_T *) (0x40040000UL))->FMSSTOP & (1UL << 31)) != 0);
N}
N
N/**
N * @brief	Returns the generated FLASH signature value
N * @param	index	: Signature index, must be 0
N * @return	the generated FLASH signature value
N */
NSTATIC INLINE uint32_t Chip_FMC_GetSignature(int index)
Xstatic __inline uint32_t Chip_FMC_GetSignature(int index)
N{
N	return LPC_FMC->FMSW[index];
X	return ((LPC_FMC_T *) (0x40040000UL))->FMSW[index];
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FMC_8XX_H_ */
L 181 ".\lpc_chip_82x\inc\chip.h" 2
N#include "pinint_8xx.h"
L 1 ".\lpc_chip_82x\inc\pinint_8xx.h" 1
N/*
N * @brief LPC8xx Pin Interrupt and Pattern Match Registers and driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __PININT_8XX_H_
N#define __PININT_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup PININT_8XX CHIP: LPC8xx Pin Interrupt and Pattern Match driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief LPC8xx Pin Interrupt and Pattern Match register block structure
N */
Ntypedef struct {			/*!< (@ 0xA0004000) PIN_INT Structure */
N	__IO uint32_t ISEL;		/*!< (@ 0xA0004000) Pin Interrupt Mode register */
X	volatile uint32_t ISEL;		 
N	__IO uint32_t IENR;		/*!< (@ 0xA0004004) Pin Interrupt Enable (Rising) register */
X	volatile uint32_t IENR;		 
N	__IO uint32_t SIENR;	/*!< (@ 0xA0004008) Set Pin Interrupt Enable (Rising) register */
X	volatile uint32_t SIENR;	 
N	__IO uint32_t CIENR;	/*!< (@ 0xA000400C) Clear Pin Interrupt Enable (Rising) register */
X	volatile uint32_t CIENR;	 
N	__IO uint32_t IENF;		/*!< (@ 0xA0004010) Pin Interrupt Enable Falling Edge / Active Level register */
X	volatile uint32_t IENF;		 
N	__IO uint32_t SIENF;	/*!< (@ 0xA0004014) Set Pin Interrupt Enable Falling Edge / Active Level register */
X	volatile uint32_t SIENF;	 
N	__IO uint32_t CIENF;	/*!< (@ 0xA0004018) Clear Pin Interrupt Enable Falling Edge / Active Level address */
X	volatile uint32_t CIENF;	 
N	__IO uint32_t RISE;		/*!< (@ 0xA000401C) Pin Interrupt Rising Edge register */
X	volatile uint32_t RISE;		 
N	__IO uint32_t FALL;		/*!< (@ 0xA0004020) Pin Interrupt Falling Edge register */
X	volatile uint32_t FALL;		 
N	__IO uint32_t IST;		/*!< (@ 0xA0004024) Pin Interrupt Status register */
X	volatile uint32_t IST;		 
N	__IO uint32_t PMCTRL;	/*!< (@ 0xA0004028) GPIO pattern match interrupt control register          */
X	volatile uint32_t PMCTRL;	 
N	__IO uint32_t PMSRC;	/*!< (@ 0xA000402C) GPIO pattern match interrupt bit-slice source register */
X	volatile uint32_t PMSRC;	 
N	__IO uint32_t PMCFG;	/*!< (@ 0xA0004030) GPIO pattern match interrupt bit slice configuration register */
X	volatile uint32_t PMCFG;	 
N} LPC_PIN_INT_T;
N
N/* Reserved bits masks for registers */
N#define PININT_ISEL_RESERVED    (~0xff)
N#define PININT_IENR_RESERVED    (~0xff)
N#define PININT_SIENR_RESERVED   (~0xff)
N#define PININT_CIENR_RESERVED   (~0xff)
N#define PININT_IENF_RESERVED    (~0xff)
N#define PININT_SIENF_RESERVED   (~0xff)
N#define PININT_CIENF_RESERVED   (~0xff)
N#define PININT_RISE_RESERVED    (~0xff)
N#define PININT_FALL_RESERVED    (~0xff)
N#define PININT_IST_RESERVED     (~0xff)
N#define PININT_PMCTRL_RESERVED  (~0xff000003)
N#define PININT_PMSRC_RESERVED   0xff
N#define PININT_PMCFG_RESERVED   (1<<7)
N
N/**
N * LPC8xx Pin Interrupt and Pattern match engine register
N * bit fields and macros
N */
N/* PININT interrupt control register */
N#define PININT_PMCTRL_PMATCH_SEL (1 << 0) 
N#define PININT_PMCTRL_RXEV_ENA   (1 << 1) 
N
N/* PININT Bit slice source register bits */
N#define PININT_SRC_BITSOURCE_START  8
N#define PININT_SRC_BITSOURCE_MASK   7
N
N/* PININT Bit slice configuration register bits */
N#define PININT_SRC_BITCFG_START  8
N#define PININT_SRC_BITCFG_MASK   7
N
N/**
N * LPC8xx Pin Interrupt channel values
N */
N#define PININTCH0         (1 << 0)
N#define PININTCH1         (1 << 1)
N#define PININTCH2         (1 << 2)
N#define PININTCH3         (1 << 3)
N#define PININTCH4         (1 << 4)
N#define PININTCH5         (1 << 5)
N#define PININTCH6         (1 << 6)
N#define PININTCH7         (1 << 7)
N#define PININTCH(ch)      (1 << (ch))
N
N/**
N * LPC8xx Pin Matching Interrupt bit slice enum values
N */
Ntypedef enum Chip_PININT_BITSLICE {
N	PININTBITSLICE0 = 0,	/*!< PININT Bit slice 0 */
N	PININTBITSLICE1 = 1,	/*!< PININT Bit slice 1 */
N	PININTBITSLICE2 = 2,	/*!< PININT Bit slice 2 */
N	PININTBITSLICE3 = 3,	/*!< PININT Bit slice 3 */
N	PININTBITSLICE4 = 4,	/*!< PININT Bit slice 4 */
N	PININTBITSLICE5 = 5,	/*!< PININT Bit slice 5 */
N	PININTBITSLICE6 = 6,	/*!< PININT Bit slice 6 */
N	PININTBITSLICE7 = 7	/*!< PININT Bit slice 7 */
N} Chip_PININT_BITSLICE_T;
N
N/**
N * LPC8xx Pin Matching Interrupt bit slice configuration enum values
N */
Ntypedef enum Chip_PININT_BITSLICE_CFG {
N    PININT_PATTERNCONST1           = 0x0,	/*!< Contributes to product term match */
N    PININT_PATTERNRISING           = 0x1,	/*!< Rising edge */    
N    PININT_PATTERNFALLING          = 0x2,	/*!< Falling edge */    
N    PININT_PATTERNRISINGRFALLING   = 0x3,	/*!< Rising or Falling edge */    
N    PININT_PATTERNHIGH             = 0x4,	/*!< High level */    
N    PININT_PATTERNLOW              = 0x5,	/*!< Low level */    
N    PININT_PATTERCONST0            = 0x6,	/*!< Never contributes for match */    
N    PININT_PATTEREVENT             = 0x7	/*!< Match occurs on event */    
N} Chip_PININT_BITSLICE_CFG_T;
N
N/**
N * @brief	Initialize Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N * @note	This function should be used after the Chip_GPIO_Init() function.
N */
NSTATIC INLINE void Chip_PININT_Init(LPC_PIN_INT_T *pPININT) {}
Xstatic __inline void Chip_PININT_Init(LPC_PIN_INT_T *pPININT) {}
N
N/**
N * @brief	De-Initialize Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_DeInit(LPC_PIN_INT_T *pPININT) {}
Xstatic __inline void Chip_PININT_DeInit(LPC_PIN_INT_T *pPININT) {}
N
N/**
N * @brief	Configure the pins as edge sensitive in Pin interrupt block 
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins (ORed value of PININTCH*)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N    pPININT->ISEL &= ~(pins | PININT_ISEL_RESERVED);
X    pPININT->ISEL &= ~(pins | (~0xff));
N}
N
N/**
N * @brief	Configure the pins as level sensitive in Pin interrupt block 
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins (ORed value of PININTCH*)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_SetPinModeLevel(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_SetPinModeLevel(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N    pPININT->ISEL = pins | (pPININT->ISEL & ~PININT_ISEL_RESERVED);
X    pPININT->ISEL = pins | (pPININT->ISEL & ~(~0xff));
N}
N
N/**
N * @brief	Return current PININT rising edge or high level interrupt enable state
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	A bifield containing the high edge/level interrupt enables for each
N * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
N * For each bit, a 0 means the high edge/level interrupt is disabled, while a 1
N * means it's enabled.
N */
NSTATIC INLINE uint32_t Chip_PININT_GetHighEnabled(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetHighEnabled(LPC_PIN_INT_T *pPININT)
N{
N    return pPININT->IENR & ~PININT_IENR_RESERVED;
X    return pPININT->IENR & ~(~0xff);
N}
N
N/**
N * @brief	Enable high edge/level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins to enable (ORed value of PININTCH*)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_EnableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_EnableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N    pPININT->SIENR = pins;
N}
N
N/**
N * @brief	Disable high edge/level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins to disable (ORed value of PININTCH*)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_DisableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_DisableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N    pPININT->CIENR = pins;
N}
N
N/**
N * @brief	Return current PININT falling edge or low level interrupt enable state
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	A bifield containing the low edge/level interrupt enables for each
N * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
N * For each bit, a 0 means the low edge/level interrupt is disabled, while a 1
N * means it's enabled.
N */
NSTATIC INLINE uint32_t Chip_PININT_GetLowEnabled(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetLowEnabled(LPC_PIN_INT_T *pPININT)
N{
N    return pPININT->IENF & ~PININT_IENF_RESERVED;
X    return pPININT->IENF & ~(~0xff);
N}
N
N/**
N * @brief	Enable low edge/level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins to enable (ORed value of PININTCH*)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N    pPININT->SIENF = pins;
N}
N
N/**
N * @brief	Disable low edge/level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins to disable (ORed value of PININTCH*)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_DisableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_DisableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N    pPININT->CIENF = pins;
N}
N
N/**
N * @brief	Return pin states that have a detected latched high edge (RISE) state
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	PININT states (bit n = high) with a latched rise state detected
N */
NSTATIC INLINE uint32_t Chip_PININT_GetRiseStates(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetRiseStates(LPC_PIN_INT_T *pPININT)
N{
N    return pPININT->RISE & ~PININT_RISE_RESERVED;
X    return pPININT->RISE & ~(~0xff);
N}
N
N/**
N * @brief	Clears pin states that had a latched high edge (RISE) state
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins with latched states to clear
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_ClearRiseStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_ClearRiseStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N		pPININT->RISE = pins;
N}
N
N/**
N * @brief	Return pin states that have a detected latched falling edge (FALL) state
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	PININT states (bit n = high) with a latched rise state detected
N */
NSTATIC INLINE uint32_t Chip_PININT_GetFallStates(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetFallStates(LPC_PIN_INT_T *pPININT)
N{
N    return pPININT->FALL & ~PININT_FALL_RESERVED;
X    return pPININT->FALL & ~(~0xff);
N}
N
N/**
N * @brief	Clears pin states that had a latched falling edge (FALL) state
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pins with latched states to clear
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_ClearFallStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_ClearFallStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N		pPININT->FALL = pins;
N}
N
N/**
N * @brief	Get interrupt status from Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	Interrupt status (bit n for PININTn = high means interrupt ie pending)
N */
NSTATIC INLINE uint32_t Chip_PININT_GetIntStatus(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetIntStatus(LPC_PIN_INT_T *pPININT)
N{
N    return pPININT->IST& ~PININT_IST_RESERVED;
X    return pPININT->IST& ~(~0xff);
N}
N
N/**
N * @brief	Clear interrupt status in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N    pPININT->IST = pins;
N}
N
N/**
N * @brief	Set source for pattern match in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block 
N * @param	chan	: PININT channel number (From 0 to 7)
N * @param	slice	: PININT slice number
N * @return	Nothing
N */
Nvoid Chip_PININT_SetPatternMatchSrc(LPC_PIN_INT_T *pPININT, uint8_t chan, Chip_PININT_BITSLICE_T slice);
N
N/**
N * @brief	Configure the pattern matcch in Pin interrupt block
N * @param	pPININT		: The base address of Pin interrupt block 
N * @param	slice		: PININT slice number
N * @param	slice_cfg	: PININT slice configuration value (enum Chip_PININT_BITSLICE_CFG_T)
N * @param	end_point	: If true, current slice is final component
N * @return	Nothing
N */
Nvoid Chip_PININT_SetPatternMatchConfig(LPC_PIN_INT_T *pPININT, Chip_PININT_BITSLICE_T slice, 
N        Chip_PININT_BITSLICE_CFG_T slice_cfg, bool end_point);
X        Chip_PININT_BITSLICE_CFG_T slice_cfg, _Bool end_point);
N
N/**
N * @brief	Enable pattern match interrupts in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_EnablePatternMatch(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_EnablePatternMatch(LPC_PIN_INT_T *pPININT)
N{
N    pPININT->PMCTRL = PININT_PMCTRL_PMATCH_SEL | (pPININT->PMCTRL & ~PININT_PMCTRL_RESERVED);
X    pPININT->PMCTRL = (1 << 0) | (pPININT->PMCTRL & ~(~0xff000003));
N}
N
N/**
N * @brief	Disable pattern match interrupts in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_DisablePatternMatch(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_DisablePatternMatch(LPC_PIN_INT_T *pPININT)
N{
N    pPININT->PMCTRL &= ~(PININT_PMCTRL_PMATCH_SEL | PININT_PMCTRL_RESERVED);
X    pPININT->PMCTRL &= ~((1 << 0) | (~0xff000003));
N}
N
N/**
N * @brief	Enable RXEV output in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_EnablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_EnablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
N{
N    pPININT->PMCTRL = PININT_PMCTRL_RXEV_ENA | (pPININT->PMCTRL & ~PININT_PMCTRL_RESERVED);
X    pPININT->PMCTRL = (1 << 1) | (pPININT->PMCTRL & ~(~0xff000003));
N}
N
N/**
N * @brief	Disable RXEV output in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block 
N * @return	Nothing
N */
NSTATIC INLINE void Chip_PININT_DisablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_DisablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
N{
N    pPININT->PMCTRL &= ~(PININT_PMCTRL_RXEV_ENA | PININT_PMCTRL_RESERVED);
X    pPININT->PMCTRL &= ~((1 << 1) | (~0xff000003));
N}
N    
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __PININT_8XX_H_ */
L 182 ".\lpc_chip_82x\inc\chip.h" 2
N#include "pmu_8xx.h"
L 1 ".\lpc_chip_82x\inc\pmu_8xx.h" 1
N/*
N * @brief LPC8xx PMU chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __PMU_8XX_H_
N#define __PMU_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup PMU_8XX CHIP: LPC8xx PMU driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief LPC8xx Power Management Unit register block structure
N */
Ntypedef struct {
N	__IO uint32_t PCON;		/*!< Offset: 0x000 Power control Register (R/W) */
X	volatile uint32_t PCON;		 
N	__IO uint32_t GPREG[4];	/*!< Offset: 0x004 General purpose Registers 0..3 (R/W) */
X	volatile uint32_t GPREG[4];	 
N	__IO uint32_t DPDCTRL;	/*!< Offset: 0x014 Deep power-down control register (R/W) */
X	volatile uint32_t DPDCTRL;	 
N} LPC_PMU_T;
N
N/* Reserved bits masks for registers */
N#define PMU_PCON_RESERVED      ((0xf<<4)|(0x6<<8)|0xfffff000)
N#define PMU_DPDCTRL_RESERVED   (~0xf)
N
N/**
N * @brief LPC8xx low power mode type definitions
N */
Ntypedef enum CHIP_PMU_MCUPOWER {
N	PMU_MCU_SLEEP = 0,		/*!< Sleep mode */
N	PMU_MCU_DEEP_SLEEP,		/*!< Deep Sleep mode */
N	PMU_MCU_POWER_DOWN,		/*!< Power down mode */
N	PMU_MCU_DEEP_PWRDOWN	/*!< Deep power down mode */
N} CHIP_PMU_MCUPOWER_T;
N
N/**
N * PMU PCON register bit fields & masks
N */
N#define PMU_PCON_PM_SLEEP			(0x0)		/*!< ARM WFI enter sleep mode */
N#define PMU_PCON_PM_DEEPSLEEP		(0x1)		/*!< ARM WFI enter Deep-sleep mode */
N#define PMU_PCON_PM_POWERDOWN		(0x2)		/*!< ARM WFI enter Power-down mode */
N#define PMU_PCON_PM_DEEPPOWERDOWN	(0x3)		/*!< ARM WFI enter Deep Power-down mode */
N#define PMU_PCON_NODPD				(1 << 3)	/*!< Disable deep power-down mode */
N#define PMU_PCON_SLEEPFLAG			(1 << 8)	/*!< Sleep mode flag */
N#define PMU_PCON_DPDFLAG			(1 << 11)	/*!< Deep power-down flag */
N
N/**
N * PMU DPDCTRL register bit fields & masks
N */
N#define PMU_DPDCTRL_WAKEUPPHYS      (1 << 0)	/** Enable wake-up pin hysteresis */
N#define PMU_DPDCTRL_WAKEPAD         (1 << 1)	/** Disable the Wake-up */
N#define PMU_DPDCTRL_LPOSCEN         (1 << 2)	/** Enable the low-power oscillator (10 khz self wk) */
N#define PMU_DPDCTRL_LPOSCDPDEN      (1 << 3)	/** Enable the low-power oscillator in deep power-down*/
N
N/**
N * @brief	Write a value to a GPREG register
N * @param	pPMU		: Pointer to PMU register block
N * @param	regIndex	: Register index to write to, must be 0..3
N * @param	value		: Value to write
N * @return	None
N */
NSTATIC INLINE void Chip_PMU_WriteGPREG(LPC_PMU_T *pPMU, uint8_t regIndex, uint32_t value)
Xstatic __inline void Chip_PMU_WriteGPREG(LPC_PMU_T *pPMU, uint8_t regIndex, uint32_t value)
N{
N	pPMU->GPREG[regIndex] = value;
N}
N
N/**
N * @brief	Read a value to a GPREG register
N * @param	pPMU		: Pointer to PMU register block
N * @param	regIndex	: Register index to read from, must be 0..3
N * @return	Value read from the GPREG register
N */
NSTATIC INLINE uint32_t Chip_PMU_ReadGPREG(LPC_PMU_T *pPMU, uint8_t regIndex)
Xstatic __inline uint32_t Chip_PMU_ReadGPREG(LPC_PMU_T *pPMU, uint8_t regIndex)
N{
N	return pPMU->GPREG[regIndex];
N}
N
N/**
N * @brief	Enter MCU Sleep mode
N * @param	pPMU	: Pointer to PMU register block
N * @return	None
N * @note	The sleep mode affects the ARM Cortex-M0+ core only. Peripherals
N * and memories are active. 
N */
Nvoid Chip_PMU_SleepState(LPC_PMU_T *pPMU);
N
N/**
N * @brief	Enter MCU Deep Sleep mode
N * @param	pPMU	: Pointer to PMU register block
N * @return	None
N * @note	In Deep-sleep mode, the peripherals receive no internal clocks.
N * The flash is in stand-by mode. The SRAM memory and all peripheral registers
N * as well as the processor maintain their internal states. The WWDT, WKT,
N * and BOD can remain active to wake up the system on an interrupt.
N */
Nvoid Chip_PMU_DeepSleepState(LPC_PMU_T *pPMU);
N
N/**
N * @brief	Enter MCU Power down mode
N * @param	pPMU	: Pointer to PMU register block
N * @return	None
N * @note	In Power-down mode, the peripherals receive no internal clocks.
N * The internal SRAM memory and all peripheral registers as well as the
N * processor maintain their internal states. The flash memory is powered
N * down. The WWDT, WKT, and BOD can remain active to wake up the system
N * on an interrupt.
N */
Nvoid Chip_PMU_PowerDownState(LPC_PMU_T *pPMU);
N
N/**
N * @brief	Enter MCU Deep Power down mode
N * @param	pPMU	: Pointer to PMU register block
N * @return	None
N * @note	For maximal power savings, the entire system is shut down
N * except for the general purpose registers in the PMU and the self
N * wake-up timer. Only the general purpose registers in the PMU maintain
N * their internal states. The part can wake up on a pulse on the WAKEUP
N * pin or when the self wake-up timer times out. On wake-up, the part
N * reboots.
N */
Nvoid Chip_PMU_DeepPowerDownState(LPC_PMU_T *pPMU);
N
N/**
N * @brief	Place the MCU in a low power state
N * @param	pPMU		: Pointer to PMU register block
N * @param	SleepMode	: Sleep mode
N * @return	None
N */
Nvoid Chip_PMU_Sleep(LPC_PMU_T *pPMU, CHIP_PMU_MCUPOWER_T SleepMode);
N
N/**
N * @brief	Disables deep power-down mode
N * @param	pPMU	: Pointer to PMU register block
N * @return	None
N * @note	Calling this functions prevents entry to Deep power-down
N * mode. Once set, this can only be cleared by power-on reset.
N */
NSTATIC INLINE void Chip_PMU_DisableDeepPowerDown(LPC_PMU_T *pPMU)
Xstatic __inline void Chip_PMU_DisableDeepPowerDown(LPC_PMU_T *pPMU)
N{
N	pPMU->PCON = PMU_PCON_NODPD | (pPMU->PCON & ~PMU_PCON_RESERVED);
X	pPMU->PCON = (1 << 3) | (pPMU->PCON & ~((0xf<<4)|(0x6<<8)|0xfffff000));
N}
N
N/**
N * @brief	Returns sleep/power-down flags
N * @param	pPMU	: Pointer to PMU register block
N * @return	Or'ed values of PMU_PCON_SLEEPFLAG and PMU_PCON_DPDFLAG
N * @note	These indicate that the PMU is setup for entry into a low
N * power state on the next WFI() instruction.
N */
NSTATIC INLINE uint32_t Chip_PMU_GetSleepFlags(LPC_PMU_T *pPMU)
Xstatic __inline uint32_t Chip_PMU_GetSleepFlags(LPC_PMU_T *pPMU)
N{
N	return (pPMU->PCON & (PMU_PCON_SLEEPFLAG | PMU_PCON_DPDFLAG));
X	return (pPMU->PCON & ((1 << 8) | (1 << 11)));
N}
N
N/**
N * @brief	Clears sleep/power-down flags
N * @param	pPMU	: Pointer to PMU register block
N * @param	flags	: Or'ed value of PMU_PCON_SLEEPFLAG and PMU_PCON_DPDFLAG
N * @return	Nothing
N * @note	Use this function to clear a low power state prior to calling
N * WFI().
N */
NSTATIC INLINE void Chip_PMU_ClearSleepFlags(LPC_PMU_T *pPMU, uint32_t flags)
Xstatic __inline void Chip_PMU_ClearSleepFlags(LPC_PMU_T *pPMU, uint32_t flags)
N{
N	pPMU->PCON |= (flags & (~PMU_PCON_RESERVED));
X	pPMU->PCON |= (flags & (~((0xf<<4)|(0x6<<8)|0xfffff000)));
N}
N
N/**
N * @brief	Sets deep power-down functions
N * @param	pPMU	: Pointer to PMU register block
N * @param	flags	: Or'ed value of PMU_DPDCTRL_* values
N * @return	Nothing
N * @note	Some of these functions may need to be set prior to going
N * into a low power mode. Note that some calls to this function enable
N * functions while others disable it based on the PMU_DPDCTRL_*
N * definitions.
N */
NSTATIC INLINE void Chip_PMU_SetPowerDownControl(LPC_PMU_T *pPMU, uint32_t flags)
Xstatic __inline void Chip_PMU_SetPowerDownControl(LPC_PMU_T *pPMU, uint32_t flags)
N{
N	pPMU->DPDCTRL = flags | (pPMU->DPDCTRL & ~PMU_DPDCTRL_RESERVED);
X	pPMU->DPDCTRL = flags | (pPMU->DPDCTRL & ~(~0xf));
N}
N
N/**
N * @brief	Cleats deep power-down functions
N * @param	pPMU	: Pointer to PMU register block
N * @param	flags	: Or'ed value of PMU_DPDCTRL_* values
N * @return	Nothing
N * @note	Some of these functions may need to be cleared prior to going
N * into a low power mode. Note that some calls to this function enable
N * functions while others disable it based on the PMU_DPDCTRL_*
N * definitions.
N */
NSTATIC INLINE void Chip_PMU_ClearPowerDownControl(LPC_PMU_T *pPMU, uint32_t flags)
Xstatic __inline void Chip_PMU_ClearPowerDownControl(LPC_PMU_T *pPMU, uint32_t flags)
N{
N	pPMU->DPDCTRL &= ~(flags | PMU_DPDCTRL_RESERVED);
X	pPMU->DPDCTRL &= ~(flags | (~0xf));
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __PMU_8XX_H_ */
L 183 ".\lpc_chip_82x\inc\chip.h" 2
N#include "acmp_8xx.h"
L 1 ".\lpc_chip_82x\inc\acmp_8xx.h" 1
N/*
N * @brief LPC8xx Analog comparator driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ACMP_8XX_H_
N#define __ACMP_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup ACMP_8XX CHIP: LPC8xx Analog Comparator driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief Analog Comparator register block structure
N */
Ntypedef struct {			/*!< ACMP Structure */
N	__IO uint32_t  CTRL;	/*!< Comparator control register */
X	volatile uint32_t  CTRL;	 
N	__IO uint32_t  LAD;		/*!< Voltage ladder register */
X	volatile uint32_t  LAD;		 
N} LPC_CMP_T;
N
N/* Reserved bits masks for registers */
N#define ACMP_CTRL_RESERVED   (7|(1<<5)|(1<<7)|(0x3f<<14)|(1<<22)|(1<<24)|(0x1fu<<27))
N#define ACMP_LAD_RESERVED    (~0x7f)
N
N#define ACMP_COMPSA_BIT      (1 << 6)	/* Comparator output control bit */
N#define ACMP_COMPSTAT_BIT    (1 << 21)	/* Comparator status, reflects the state of the comparator output */
N#define ACMP_COMPEDGE_BIT    (1 << 23)	/* Comparator edge-detect status */
N#define ACMP_LADENAB_BIT     (1 << 0)	/* Voltage ladder enable bit */
N
N/* EDGECLR interrupt clear bit, write 1, then 0 */
N#define ACMP_EDGECLR_BIT     (1 << 20)
N#define ACMP_EDGESEL_MASK    (0x3 << 3)
N#define ACMP_COMPVPSEL_MASK  (0x7 << 8)
N#define ACMP_COMPVMSEL_MASK  (0x7 << 11)
N#define ACMP_HYSTERESIS_MASK (0x3 << 25)
N#define ACMP_LADSEL_MASK     (0x1F << 1)
N#define ACMP_LADREF_MASK     (0x1 << 6)
N
N/** Edge selection for comparator */
Ntypedef enum {
N	ACMP_EDGESEL_FALLING = (0 << 3),	/* Set the COMPEDGE bit on falling edge */
N	ACMP_EDGESEL_RISING  = (1 << 3),	/* Set the COMPEDGE bit on rising edge */
N	ACMP_EDGESEL_BOTH    = (2 << 3)		/* Set the COMPEDGE bit on falling and rising edges */
N} ACMP_EDGESEL_T;
N
N/** Hysteresis selection for comparator */
Ntypedef enum {
N	ACMP_HYS_NONE = (0 << 25),	/* No hysteresis (the output will switch as the voltages cross) */
N	ACMP_HYS_5MV  = (1 << 25),	/* 5mV hysteresis */
N	ACMP_HYS_10MV = (2 << 25),	/* 10mV hysteresis */
N	ACMP_HYS_20MV = (3 << 25)	/* 20mV hysteresis */
N} ACMP_HYS_T;
N
N/**
N * Analog Comparator positive input values
N */
Ntypedef enum CHIP_ACMP_POS_INPUT {
N	ACMP_POSIN_VLO      = (0 << 8),	/*!< Voltage ladder output */
N	ACMP_POSIN_ACMP_I1  = (1 << 8),	/*!< ACMP_I1 pin */
N	ACMP_POSIN_ACMP_I2  = (2 << 8),	/*!< ACMP_I2 pin */
N	ACMP_POSIN_ACMP_I3  = (3 << 8),	/*!< ACMP_I3 pin */
N	ACMP_POSIN_ACMP_I4  = (4 << 8),	/*!< ACMP_I4 pin */
N#if defined(CHIP_LPC82X)
X#if 1L
N	ACMP_POSIN_INT_REF  = (5 << 8),	/*!< Internal reference voltage */
N	ACMP_POSIN_ADC_0    = (6 << 8),	/*!< ADC_0 Input */
N#else
S	ACMP_POSIN_INT_REF  = (6 << 8),	/*!< Internal reference voltage */
N#endif
N} ACMP_POS_INPUT_T;
N
N/**
N * Analog Comparator negative input values
N */
Ntypedef enum CHIP_ACMP_NEG_INPUT {
N	ACMP_NEGIN_VLO     = (0 << 11),	/*!< Voltage ladder output */
N	ACMP_NEGIN_ACMP_I1 = (1 << 11),	/*!< ACMP_I1 pin */
N	ACMP_NEGIN_ACMP_I2 = (2 << 11),	/*!< ACMP_I2 pin */
N	ACMP_NEGIN_ACMP_I3 = (3 << 11),	/*!< ACMP_I3 pin */
N	ACMP_NEGIN_ACMP_I4 = (4 << 11),	/*!< ACMP_I4 pin */
N#if defined(CHIP_LPC82X)
X#if 1L
N	ACMP_NEGIN_INT_REF = (5 << 11),	/*!< Internal reference voltage */
N	ACMP_NEGIN_ADC_0   = (6 << 11),	/*!< ADC_0 Input */
N#else
S	ACMP_NEGIN_INT_REF = (6 << 11)	/*!< Internal reference voltage */
N#endif
N} ACMP_NEG_INPUT_T;
N
N/**
N * @brief	Initializes the ACMP
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Nothing
N */
Nvoid Chip_ACMP_Init(LPC_CMP_T *pACMP);
N
N/**
N * @brief	Deinitializes the ACMP
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Nothing
N */
Nvoid Chip_ACMP_Deinit(LPC_CMP_T *pACMP);
N
N/**
N * @brief	Returns the current comparator status
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Status is an Or'ed value of ACMP_COMPSTAT_BIT or ACMP_COMPEDGE_BIT
N */
NSTATIC INLINE uint32_t Chip_ACMP_GetCompStatus(LPC_CMP_T *pACMP)
Xstatic __inline uint32_t Chip_ACMP_GetCompStatus(LPC_CMP_T *pACMP)
N{
N	return pACMP->CTRL & (ACMP_COMPSTAT_BIT | ACMP_COMPEDGE_BIT);
X	return pACMP->CTRL & ((1 << 21) | (1 << 23));
N}
N
N/**
N * @brief	Clears the ACMP interrupt (EDGECLR bit)
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Nothing
N */
Nvoid Chip_ACMP_EdgeClear(LPC_CMP_T *pACMP);
N
N/**
N * @brief	Sets up ACMP edge selection
N * @param	pACMP	: Pointer to Analog Comparator block
N * @param	edgeSel	: Edge selection value
N * @return	Nothing
N */
Nvoid Chip_ACMP_SetEdgeSelection(LPC_CMP_T *pACMP, ACMP_EDGESEL_T edgeSel);
N
N/**
N * @brief	Synchronizes Comparator output to bus clock
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Nothing
N */
NSTATIC INLINE void Chip_ACMP_EnableSyncCompOut(LPC_CMP_T *pACMP)
Xstatic __inline void Chip_ACMP_EnableSyncCompOut(LPC_CMP_T *pACMP)
N{
N	pACMP->CTRL = ACMP_COMPSA_BIT | (pACMP->CTRL & ~ACMP_CTRL_RESERVED);
X	pACMP->CTRL = (1 << 6) | (pACMP->CTRL & ~(7|(1<<5)|(1<<7)|(0x3f<<14)|(1<<22)|(1<<24)|(0x1fu<<27)));
N}
N
N/**
N * @brief	Sets comparator output to be used directly (no sync)
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Nothing
N */
NSTATIC INLINE void Chip_ACMP_DisableSyncCompOut(LPC_CMP_T *pACMP)
Xstatic __inline void Chip_ACMP_DisableSyncCompOut(LPC_CMP_T *pACMP)
N{
N	pACMP->CTRL &= ~(ACMP_COMPSA_BIT | ACMP_CTRL_RESERVED);
X	pACMP->CTRL &= ~((1 << 6) | (7|(1<<5)|(1<<7)|(0x3f<<14)|(1<<22)|(1<<24)|(0x1fu<<27)));
N}
N
N/**
N * @brief	Selects positive voltage input
N * @param	pACMP		: Pointer to Analog Comparator block
N * @param	Posinput	: one of the positive input voltage sources
N * @return	Nothing
N */
Nvoid Chip_ACMP_SetPosVoltRef(LPC_CMP_T *pACMP, ACMP_POS_INPUT_T Posinput);
N
N/**
N * @brief	Selects negative voltage input
N * @param	pACMP		: Pointer to Analog Comparator block
N * @param	Neginput	: one of the negative input voltage sources
N * @return	Nothing
N */
Nvoid Chip_ACMP_SetNegVoltRef(LPC_CMP_T *pACMP, ACMP_NEG_INPUT_T Neginput);
N
N/**
N * @brief	Selects hysteresis level
N * @param	pACMP	: Pointer to Analog Comparator block
N * @param   hys     : Selected Hysteresis level
N * @return	Nothing
N */
Nvoid Chip_ACMP_SetHysteresis(LPC_CMP_T *pACMP, ACMP_HYS_T hys);
N
N/**
N * @brief	Helper function for setting up ACMP control
N * @param	pACMP		: Pointer to Analog Comparator block
N * @param	edgeSel		: Edge selection value
N * @param	Posinput	: one of the positive input voltage sources
N * @param	Neginput	: one of the negative input voltage sources
N * @param	hys			: Selected Hysteresis level
N * @return	Nothing
N */
Nvoid Chip_ACMP_SetupAMCPRefs(LPC_CMP_T *pACMP, ACMP_EDGESEL_T edgeSel,
N							 ACMP_POS_INPUT_T Posinput, ACMP_NEG_INPUT_T Neginput,
N							 ACMP_HYS_T hys);
N
N/**
N * @brief	Sets up voltage ladder
N * @param	pACMP			: Pointer to Analog Comparator block
N * @param	ladsel			: Voltage ladder value (0 .. 31)
N * @param	ladrefVDDCMP	: Selects the reference voltage Vref for the voltage ladder
N *							: false for VDD, true for VDDCMP pin
N * @return	Nothing
N */
Nvoid Chip_ACMP_SetupVoltLadder(LPC_CMP_T *pACMP, uint32_t ladsel, bool ladrefVDDCMP);
Xvoid Chip_ACMP_SetupVoltLadder(LPC_CMP_T *pACMP, uint32_t ladsel, _Bool ladrefVDDCMP);
N
N/**
N * @brief	Enables voltage ladder
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Nothing
N */
NSTATIC INLINE void Chip_ACMP_EnableVoltLadder(LPC_CMP_T *pACMP)
Xstatic __inline void Chip_ACMP_EnableVoltLadder(LPC_CMP_T *pACMP)
N{
N	pACMP->LAD = ACMP_LADENAB_BIT | (pACMP->LAD & ~ACMP_LAD_RESERVED);
X	pACMP->LAD = (1 << 0) | (pACMP->LAD & ~(~0x7f));
N}
N
N/**
N * @brief	Disables voltage ladder
N * @param	pACMP	: Pointer to Analog Comparator block
N * @return	Nothing
N */
NSTATIC INLINE void Chip_ACMP_DisableVoltLadder(LPC_CMP_T *pACMP)
Xstatic __inline void Chip_ACMP_DisableVoltLadder(LPC_CMP_T *pACMP)
N{
N	pACMP->LAD &= ~(ACMP_LADENAB_BIT | ACMP_LAD_RESERVED);
X	pACMP->LAD &= ~((1 << 0) | (~0x7f));
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ACMP_8XX_H_ */
L 184 ".\lpc_chip_82x\inc\chip.h" 2
N#include "crc_8xx.h"
L 1 ".\lpc_chip_82x\inc\crc_8xx.h" 1
N/*
N * @brief LPC8xx Cyclic Redundancy Check (CRC) Engine driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CRC_8XX_H_
N#define __CRC_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CRC_8XX CHIP: LPC8xx Cyclic Redundancy Check Engine driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief CRC register block structure
N */
Ntypedef struct {					/*!< CRC Structure */
N	__IO    uint32_t    MODE;		/*!< CRC Mode Register */
X	volatile    uint32_t    MODE;		 
N	__IO    uint32_t    SEED;		/*!< CRC SEED Register */
X	volatile    uint32_t    SEED;		 
N	union {
N		__I     uint32_t    SUM;	/*!< CRC Checksum Register. */
X		volatile const     uint32_t    SUM;	 
N		__O     uint32_t    WRDATA32;	/*!< CRC Data Register: write size 32-bit*/
X		volatile     uint32_t    WRDATA32;	 
N		__O     uint16_t    WRDATA16;	/*!< CRC Data Register: write size 16-bit*/
X		volatile     uint16_t    WRDATA16;	 
N		__O     uint8_t     WRDATA8;	/*!< CRC Data Register: write size 8-bit*/
X		volatile     uint8_t     WRDATA8;	 
N	};
N
N} LPC_CRC_T;
N
N/*
N * @brief CRC MODE register description
N */
N#define CRC_MODE_POLY_BITMASK   ((0x03))	/** CRC polynomial Bit mask */
N#define CRC_MODE_POLY_CCITT     (0x00)		/** Select CRC-CCITT polynomial */
N#define CRC_MODE_POLY_CRC16     (0x01)		/** Select CRC-16 polynomial */
N#define CRC_MODE_POLY_CRC32     (0x02)		/** Select CRC-32 polynomial */
N#define CRC_MODE_WRDATA_BITMASK (0x03 << 2)	/** CRC WR_Data Config Bit mask */
N#define CRC_MODE_WRDATA_BIT_RVS (1 << 2)	/** Select Bit order reverse for WR_DATA (per byte) */
N#define CRC_MODE_WRDATA_CMPL    (1 << 3)	/** Select One's complement for WR_DATA */
N#define CRC_MODE_SUM_BITMASK    (0x03 << 4)	/** CRC Sum Config Bit mask */
N#define CRC_MODE_SUM_BIT_RVS    (1 << 4)	/** Select Bit order reverse for CRC_SUM */
N#define CRC_MODE_SUM_CMPL       (1 << 5)	/** Select One's complement for CRC_SUM */
N
N#define MODE_CFG_CCITT          (0x00)	/** Pre-defined mode word for default CCITT setup */
N#define MODE_CFG_CRC16          (0x15)	/** Pre-defined mode word for default CRC16 setup */
N#define MODE_CFG_CRC32          (0x36)	/** Pre-defined mode word for default CRC32 setup */
N
N#define CRC_SEED_CCITT          (0x0000FFFF)/** Initial seed value for CCITT mode */
N#define CRC_SEED_CRC16          (0x00000000)/** Initial seed value for CRC16 mode */
N#define CRC_SEED_CRC32          (0xFFFFFFFF)/** Initial seed value for CRC32 mode */
N
N/**
N * @brief CRC polynomial
N */
Ntypedef enum IP_CRC_001_POLY {
N	CRC_POLY_CCITT = CRC_MODE_POLY_CCITT,	/**< CRC-CCIT polynomial */
X	CRC_POLY_CCITT = (0x00),	 
N	CRC_POLY_CRC16 = CRC_MODE_POLY_CRC16,	/**< CRC-16 polynomial */
X	CRC_POLY_CRC16 = (0x01),	 
N	CRC_POLY_CRC32 = CRC_MODE_POLY_CRC32,	/**< CRC-32 polynomial */
X	CRC_POLY_CRC32 = (0x02),	 
N	CRC_POLY_LAST,
N} CRC_POLY_T;
N
N/**
N * @brief	Initializes the CRC Engine
N * @return	Nothing
N */
Nvoid Chip_CRC_Init(void);
N
N/**
N * @brief	Deinitializes the CRC Engine
N * @return	Nothing
N */
Nvoid Chip_CRC_Deinit(void);
N
N/**
N * @brief	Set the polynomial used for the CRC calculation
N * @param	poly	: The enumerated polynomial to be used
N * @param	flags	: An Or'ed value of flags that setup the mode
N * @return	Nothing
N * @note	Flags for setting up the mode word include CRC_MODE_WRDATA_BIT_RVS,
N * CRC_MODE_WRDATA_CMPL, CRC_MODE_SUM_BIT_RVS, and CRC_MODE_SUM_CMPL.
N */
NSTATIC INLINE void Chip_CRC_SetPoly(CRC_POLY_T poly, uint32_t flags)
Xstatic __inline void Chip_CRC_SetPoly(CRC_POLY_T poly, uint32_t flags)
N{
N	LPC_CRC->MODE = (uint32_t) poly | flags;
X	((LPC_CRC_T *) (0x50000000UL))->MODE = (uint32_t) poly | flags;
N}
N
N/**
N * @brief	Sets up the CRC engine for CRC16 mode
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_UseCRC16(void)
Xstatic __inline void Chip_CRC_UseCRC16(void)
N{
N	LPC_CRC->MODE = MODE_CFG_CRC16;
X	((LPC_CRC_T *) (0x50000000UL))->MODE = (0x15);
N	LPC_CRC->SEED = CRC_SEED_CRC16;
X	((LPC_CRC_T *) (0x50000000UL))->SEED = (0x00000000);
N}
N
N/**
N * @brief	Sets up the CRC engine for CRC32 mode
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_UseCRC32(void)
Xstatic __inline void Chip_CRC_UseCRC32(void)
N{
N	LPC_CRC->MODE = MODE_CFG_CRC32;
X	((LPC_CRC_T *) (0x50000000UL))->MODE = (0x36);
N	LPC_CRC->SEED = CRC_SEED_CRC32;
X	((LPC_CRC_T *) (0x50000000UL))->SEED = (0xFFFFFFFF);
N}
N
N/**
N * @brief	Sets up the CRC engine for CCITT mode
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_UseCCITT(void)
Xstatic __inline void Chip_CRC_UseCCITT(void)
N{
N	LPC_CRC->MODE = MODE_CFG_CCITT;
X	((LPC_CRC_T *) (0x50000000UL))->MODE = (0x00);
N	LPC_CRC->SEED = CRC_SEED_CCITT;
X	((LPC_CRC_T *) (0x50000000UL))->SEED = (0x0000FFFF);
N}
N
N/**
N * @brief	Engage the CRC engine with defaults based on the polynomial to be used
N * @param	poly	: The enumerated polynomial to be used
N * @return	Nothing
N */
Nvoid Chip_CRC_UseDefaultConfig(CRC_POLY_T poly);
N
N/**
N * @brief	Set the CRC Mode bits
N * @param	mode	: Mode value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_SetMode(uint32_t mode)
Xstatic __inline void Chip_CRC_SetMode(uint32_t mode)
N{
N	LPC_CRC->MODE = mode;
X	((LPC_CRC_T *) (0x50000000UL))->MODE = mode;
N}
N
N/**
N * @brief	Get the CRC Mode bits
N * @return	The current value of the CRC Mode bits
N */
NSTATIC INLINE uint32_t Chip_CRC_GetMode(void)
Xstatic __inline uint32_t Chip_CRC_GetMode(void)
N{
N	return LPC_CRC->MODE;
X	return ((LPC_CRC_T *) (0x50000000UL))->MODE;
N}
N
N/**
N * @brief	Set the seed bits used by the CRC_SUM register
N * @param	seed	: Seed value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_SetSeed(uint32_t seed)
Xstatic __inline void Chip_CRC_SetSeed(uint32_t seed)
N{
N	LPC_CRC->SEED = seed;
X	((LPC_CRC_T *) (0x50000000UL))->SEED = seed;
N}
N
N/**
N * @brief	Get the CRC seed value
N * @return	Seed value
N */
NSTATIC INLINE uint32_t Chip_CRC_GetSeed(void)
Xstatic __inline uint32_t Chip_CRC_GetSeed(void)
N{
N	return LPC_CRC->SEED;
X	return ((LPC_CRC_T *) (0x50000000UL))->SEED;
N}
N
N/**
N * @brief	Convenience function for writing 8-bit data to the CRC engine
N * @param	data	: 8-bit data to write
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_Write8(uint8_t data)
Xstatic __inline void Chip_CRC_Write8(uint8_t data)
N{
N	LPC_CRC->WRDATA8 = data;
X	((LPC_CRC_T *) (0x50000000UL))->WRDATA8 = data;
N}
N
N/**
N * @brief	Convenience function for writing 16-bit data to the CRC engine
N * @param	data	: 16-bit data to write
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_Write16(uint16_t data)
Xstatic __inline void Chip_CRC_Write16(uint16_t data)
N{
N	LPC_CRC->WRDATA16 = data;
X	((LPC_CRC_T *) (0x50000000UL))->WRDATA16 = data;
N}
N
N/**
N * @brief	Convenience function for writing 32-bit data to the CRC engine
N * @param	data	: 32-bit data to write
N * @return	Nothing
N */
NSTATIC INLINE void Chip_CRC_Write32(uint32_t data)
Xstatic __inline void Chip_CRC_Write32(uint32_t data)
N{
N	LPC_CRC->WRDATA32 = data;
X	((LPC_CRC_T *) (0x50000000UL))->WRDATA32 = data;
N}
N
N/**
N * @brief	Gets the CRC Sum based on the Mode and Seed as previously configured
N * @return	CRC Checksum value
N */
NSTATIC INLINE uint32_t Chip_CRC_Sum(void)
Xstatic __inline uint32_t Chip_CRC_Sum(void)
N{
N	return LPC_CRC->SUM;
X	return ((LPC_CRC_T *) (0x50000000UL))->SUM;
N}
N
N/**
N * @brief	Convenience function for computing a standard CCITT checksum from an 8-bit data block
N * @param	data	: Pointer to the block of 8-bit data
N * @param   bytes	: The number of bytes pointed to by data
N * @return	Check sum value
N */
Nuint32_t Chip_CRC_CRC8(const uint8_t *data, uint32_t bytes);
N
N/**
N * @brief	Convenience function for computing a standard CRC16 checksum from 16-bit data block
N * @param	data	: Pointer to the block of 16-bit data
N * @param   hwords	: The number of 16 byte entries pointed to by data
N * @return	Check sum value
N */
Nuint32_t Chip_CRC_CRC16(const uint16_t *data, uint32_t hwords);
N
N/**
N * @brief	Convenience function for computing a standard CRC32 checksum from 32-bit data block
N * @param	data	: Pointer to the block of 32-bit data
N * @param   words	: The number of 32-bit entries pointed to by data
N * @return	Check sum value
N */
Nuint32_t Chip_CRC_CRC32(const uint32_t *data, uint32_t words);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CRC_8XX_H_ */
L 185 ".\lpc_chip_82x\inc\chip.h" 2
N#include "gpio_8xx.h"
L 1 ".\lpc_chip_82x\inc\gpio_8xx.h" 1
N/*
N * @brief LPC8xx GPIO driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __GPIO_8XX_H_
N#define __GPIO_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup GPIO_8XX CHIP: LPC8xx GPIO driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief  GPIO port register block structure
N */
Ntypedef struct {				/*!< GPIO_PORT Structure */
N	__IO uint8_t B[128][32];	/*!< Offset 0x0000: Byte pin registers ports 0 to n; pins PIOn_0 to PIOn_31 */
X	volatile uint8_t B[128][32];	 
N	__IO uint32_t W[32][32];	/*!< Offset 0x1000: Word pin registers port 0 to n */
X	volatile uint32_t W[32][32];	 
N	__IO uint32_t DIR[32];		/*!< Offset 0x2000: Direction registers port n */
X	volatile uint32_t DIR[32];		 
N	__IO uint32_t MASK[32];		/*!< Offset 0x2080: Mask register port n */
X	volatile uint32_t MASK[32];		 
N	__IO uint32_t PIN[32];		/*!< Offset 0x2100: Portpin register port n */
X	volatile uint32_t PIN[32];		 
N	__IO uint32_t MPIN[32];		/*!< Offset 0x2180: Masked port register port n */
X	volatile uint32_t MPIN[32];		 
N	__IO uint32_t SET[32];		/*!< Offset 0x2200: Write: Set register for port n Read: output bits for port n */
X	volatile uint32_t SET[32];		 
N	__O  uint32_t CLR[32];		/*!< Offset 0x2280: Clear port n */
X	volatile  uint32_t CLR[32];		 
N	__O  uint32_t NOT[32];		/*!< Offset 0x2300: Toggle port n */
X	volatile  uint32_t NOT[32];		 
N	__O  uint32_t DIRSET[32];   /*!< Offset 0x2380: Set Direction */
X	volatile  uint32_t DIRSET[32];    
N	__O  uint32_t DIRCLR[32];   /*!< Offset 0x2400: Clear Direction */
X	volatile  uint32_t DIRCLR[32];    
N	__O  uint32_t DIRNOT[32];   /*!< Offset 0x2480: Toggle Dirction */
X	volatile  uint32_t DIRNOT[32];    
N} LPC_GPIO_T;
N
N/**
N * @brief	Initialize GPIO block
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_GPIO_Init(LPC_GPIO_T *pGPIO);
N
N/**
N * @brief	De-Initialize GPIO block
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO);
N
N/**
N * @brief	Set a GPIO port/pin state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set (supports port 0 only)
N * @param	pin		: GPIO pin to set
N * @param	setting	: true for high, false for low
N * @return	Nothing
N * @note	It is recommended to use the Chip_GPIO_SetPinState() function instead.
N */
NSTATIC INLINE void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
Xstatic __inline void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, _Bool setting)
N{
N	pGPIO->B[port][pin] = setting;
N}
N
N/**
N * @brief	Set a GPIO pin state via the GPIO byte register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set (supports port 0 only)
N * @param	pin		: GPIO pin to set
N * @param	setting	: true for high, false for low
N * @return	Nothing
N * @note	This function replaces Chip_GPIO_WritePortBit()
N */
NSTATIC INLINE void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool setting)
Xstatic __inline void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, _Bool setting)
N{
N	pGPIO->B[port][pin] = setting;
N}
N
N/**
N * @brief	Read a GPIO pin state via the GPIO byte register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read (supports port 0 only)
N * @param	pin		: GPIO pin to read
N * @return	true if the GPIO pin is high, false if low
N * @note	It is recommended to use the Chip_GPIO_GetPinState() function instead.
N */
NSTATIC INLINE bool Chip_GPIO_ReadPortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin)
Xstatic __inline _Bool Chip_GPIO_ReadPortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin)
N{
N	return (bool) pGPIO->B[port][pin];
X	return (_Bool) pGPIO->B[port][pin];
N}
N
N/**
N * @brief	Get a GPIO pin state via the GPIO byte register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read (supports port 0 only)
N * @param	pin		: GPIO pin to get state for
N * @return	true if the GPIO is high, false if low
N * @note	This function replaces Chip_GPIO_ReadPortBit()
N */
NSTATIC INLINE bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline _Bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	return (bool) pGPIO->B[port][pin];
X	return (_Bool) pGPIO->B[port][pin];
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set (supports port 0 only)
N * @param	pin		: GPIO pin to set
N * @param	setting	: true for output, false for input
N * @return	Nothing
N * @note	This function is obsolete, use the Chip_GPIO_SetPinDIROutput(),
N * Chip_GPIO_SetPinDIRInput() or Chip_GPIO_SetPinDIR() functions instead.
N */
NSTATIC INLINE void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
Xstatic __inline void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, _Bool setting)
N{
N	if (setting) {
N		pGPIO->DIR[port] |= 1UL << pin;
N	}
N	else {
N		pGPIO->DIR[port] &= ~(1UL << pin);
N	}
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin to an output
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set (supports port 0 only)
N * @param	pin		: GPIO pin to set direction on as output
N * @return	Nothing
N */
NSTATIC INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N#ifdef CHIP_LPC82X
N	pGPIO->DIRSET[port] = 1UL << pin;
N#else
S	pGPIO->DIR[port] |= 1UL << pin;
N#endif
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin to an input
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set (supports port 0 only)
N * @param	pin		: GPIO pin to set direction on as input
N * @return	Nothing
N */
NSTATIC INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N#ifdef CHIP_LPC82X
N	pGPIO->DIRCLR[port] = 1UL << pin;
N#else
S	pGPIO->DIR[port] &= ~(1UL << pin);
N#endif
N}
N
N/**
N * @brief	Toggle GPIO direction for a single GPIO pin
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set (supports port 0 only)
N * @param	pin		: GPIO pin to toggle direction
N * @return	Nothing
N */
NSTATIC INLINE void Chip_GPIO_TogglePinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_TogglePinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N#ifdef CHIP_LPC82X
N	pGPIO->DIRNOT[port] = 1UL << pin;
N#else
S	pGPIO->DIR[port] ^= 1UL << pin;
N#endif
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set (supports port 0 only)
N * @param	pin		: GPIO pin to set direction for
N * @param	output	: true for output, false for input
N * @return	Nothing
N */
NSTATIC INLINE void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool output)
Xstatic __inline void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, _Bool output)
N{
N	if (output) {
N		Chip_GPIO_SetPinDIROutput(pGPIO, port, pin);
N	}
N	else {
N		Chip_GPIO_SetPinDIRInput(pGPIO, port, pin);
N	}
N}
N
N/**
N * @brief	Read a GPIO direction (out or in)
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read (supports port 0 only)
N * @param	bit		: GPIO bit direction to read
N * @return	true if the GPIO is an output, false if input
N * @note	It is recommended to use the Chip_GPIO_GetPinDIR() function instead.
N */
NSTATIC INLINE bool Chip_GPIO_ReadDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit)
Xstatic __inline _Bool Chip_GPIO_ReadDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit)
N{
N	return (bool) (((pGPIO->DIR[port]) >> bit) & 1);
X	return (_Bool) (((pGPIO->DIR[port]) >> bit) & 1);
N}
N
N/**
N * @brief	Get GPIO direction for a single GPIO pin
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read (supports port 0 only)
N * @param	pin		: GPIO pin to get direction for
N * @return	true if the GPIO is an output, false if input
N */
NSTATIC INLINE bool Chip_GPIO_GetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline _Bool Chip_GPIO_GetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	return Chip_GPIO_ReadDirBit(pGPIO, port, pin);
N}
N
N/**
N * @brief	Set Direction for a GPIO port (Obsolete)
N * @param	pGPIO		: The base of GPIO peripheral on the chip
N * @param	portNum		: port Number (supports port 0 only)
N * @param	bitValue	: GPIO bit to set
N * @param	out			: Direction value, 0 = input, !0 = output
N * @return	None
N * @note	Bits set to '0' are not altered. Obsolete function use the
N * Chip_GPIO_SetPortDIR() function instead.
N */
NSTATIC INLINE void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
Xstatic __inline void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
N{
N	if (out) {
N		pGPIO->DIR[portNum] |= bitValue;
N	}
N	else {
N		pGPIO->DIR[portNum] &= ~bitValue;
N	}
N}
N
N/**
N * @brief	Set GPIO direction for a all selected GPIO pins to an output
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pinMask	: GPIO pin mask to set direction on as output (bits 0..b for pins 0..n)
N * @return	Nothing
N * @note	Sets multiple GPIO pins to the output direction, each bit's position that is
N * high sets the corresponding pin number for that bit to an output.
N */
NSTATIC INLINE void Chip_GPIO_SetPortDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask)
Xstatic __inline void Chip_GPIO_SetPortDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask)
N{
N#ifdef CHIP_LPC82X
N	pGPIO->DIRSET[port] = pinMask;
N#else
S	pGPIO->DIR[port] |= pinMask;
N#endif
N}
N
N/**
N * @brief	Set GPIO direction for a all selected GPIO pins to an input
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pinMask	: GPIO pin mask to set direction on as input (bits 0..b for pins 0..n)
N * @return	Nothing
N * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
N * high sets the corresponding pin number for that bit to an input.
N */
NSTATIC INLINE void Chip_GPIO_SetPortDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask)
Xstatic __inline void Chip_GPIO_SetPortDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask)
N{
N#ifdef CHIP_LPC82X
N	pGPIO->DIRCLR[port] = pinMask;
N#else
S	pGPIO->DIR[port] &= ~pinMask;
N#endif
N}
N
N/**
N * @brief	Toggle GPIO direction for a all selected GPIO pins
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pinMask	: GPIO pin mask Toggle direction (bits 0..n for pins 0..n)
N * @return	Nothing
N * @note	Toggles multiple GPIO pin's direction, each bit's position that is
N * high toggles direction of the corresponding pin number.
N */
NSTATIC INLINE void Chip_GPIO_TogglePortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask)
Xstatic __inline void Chip_GPIO_TogglePortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask)
N{
N#ifdef CHIP_LPC82X
N	pGPIO->DIRNOT[port] = pinMask;
N#else
S	pGPIO->DIR[port] ^= pinMask;
N#endif
N}
N
N/**
N * @brief	Set GPIO direction for a all selected GPIO pins to an input or output
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pinMask	: GPIO pin mask to set direction on (bits 0..b for pins 0..n)
N * @param	outSet	: Direction value, false = set as inputs, true = set as outputs
N * @return	Nothing
N * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
N * high sets the corresponding pin number for that bit to an input.
N */
NSTATIC INLINE void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask, bool outSet)
Xstatic __inline void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask, _Bool outSet)
N{
N	if (outSet) {
N		Chip_GPIO_SetPortDIROutput(pGPIO, port, pinMask);
N	}
N	else {
N		Chip_GPIO_SetPortDIRInput(pGPIO, port, pinMask);
N	}
N}
N
N/**
N * @brief	Set GPIO direction for set of pins as output and a set of pins as input
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pinMask	: GPIO pin mask to set direction on (bits 0..b for pins 0..n)
N * @param	outMask	: GPIO IN/OUT mask to set pin n as output set bit-n (see note for more info)
N * @return	Nothing
N * @note	Sets multiple GPIO pins to the input or output, to change the direction of PIN0_1,
N * PIN_05, PIN0_10 and PIN0_18, set the @a pinMask to ((1 << 1) | (1 << 5) | (1 << 10) | (1 << 18))
N * to set PIN0_5 and PIN0_18 to output and PIN0_1 and PIN0_10 as input set @a outMask to
N * ((1 << 5) | (1 << 18)).
N */
NSTATIC INLINE void Chip_GPIO_SetPortDIRMask(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask, bool outMask)
Xstatic __inline void Chip_GPIO_SetPortDIRMask(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pinMask, _Bool outMask)
N{
N	Chip_GPIO_SetPortDIRInput(pGPIO, port, pinMask & ~outMask);
N	Chip_GPIO_SetPortDIROutput(pGPIO, port, pinMask & outMask);
N}
N
N/**
N * @brief	Get GPIO direction for a all GPIO pins
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @return	a bitfield containing the input and output states for each pin
N * @note	For pins 0..n, a high state in a bit corresponds to an output state for the
N * same pin, while a low  state corresponds to an input state.
N */
NSTATIC INLINE uint32_t Chip_GPIO_GetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->DIR[port];
N}
N
N/**
N * @brief	Set GPIO port mask value for GPIO masked read and write
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	mask	: Mask value for read and write (only low bits are enabled)
N * @return	Nothing
N * @note	Controls which bits are set or unset when using the masked
N * GPIO read and write functions. A low state indicates the pin is settable
N * and readable via the masked write and read functions.
N */
NSTATIC INLINE void Chip_GPIO_SetPortMask(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t mask)
Xstatic __inline void Chip_GPIO_SetPortMask(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t mask)
N{
N	pGPIO->MASK[port] = mask;
N}
N
N/**
N * @brief	Get GPIO port mask value used for GPIO masked read and write
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @return	Returns value set with the Chip_GPIO_SetPortMask() function.
N * @note	A high bit in the return value indicates that that GPIO pin for the
N * port cannot be set using the masked write function.
N */
NSTATIC INLINE uint32_t Chip_GPIO_GetPortMask(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetPortMask(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->MASK[port];
N}
N
N/**
N * @brief	Set all GPIO raw pin states (regardless of masking)
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	value	: Value to set all GPIO pin states (0..n) to
N * @return	Nothing
N */
NSTATIC INLINE void Chip_GPIO_SetPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
Xstatic __inline void Chip_GPIO_SetPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
N{
N	pGPIO->PIN[port] = value;
N}
N
N/**
N * @brief	Get all GPIO raw pin states (regardless of masking)
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @return	Current (raw) state of all GPIO pins
N */
NSTATIC INLINE uint32_t Chip_GPIO_GetPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->PIN[port];
N}
N
N/**
N * @brief	Set all GPIO pin states, but mask via the MASKP0 register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	value	: Value to set all GPIO pin states (0..n) to
N * @return	Nothing
N */
NSTATIC INLINE void Chip_GPIO_SetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
Xstatic __inline void Chip_GPIO_SetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
N{
N	pGPIO->MPIN[port] = value;
N}
N
N/**
N * @brief	Get all GPIO pin statesm but mask via the MASKP0 register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @return	Current (masked) state of all GPIO pins
N */
NSTATIC INLINE uint32_t Chip_GPIO_GetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->MPIN[port];
N}
N
N/**
N * @brief	Set a GPIO port/bit to the high state
N * @param	pGPIO		: The base of GPIO peripheral on the chip
N * @param	portNum		: port number (supports port 0 only)
N * @param	bitValue	: bit(s) in the port to set high
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output. It is recommended to use the
N * Chip_GPIO_SetPortOutHigh() function instead.
N */
NSTATIC INLINE void Chip_GPIO_SetValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
Xstatic __inline void Chip_GPIO_SetValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
N{
N	pGPIO->SET[portNum] = bitValue;
N}
N
N/**
N * @brief	Set selected GPIO output pins to the high state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pins	: pins (0..n) to set high
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
NSTATIC INLINE void Chip_GPIO_SetPortOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
Xstatic __inline void Chip_GPIO_SetPortOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
N{
N	pGPIO->SET[port] = pins;
N}
N
N/**
N * @brief	Set an individual GPIO output pin to the high state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pin		: pin number (0..n) to set high
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
NSTATIC INLINE void Chip_GPIO_SetPinOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->SET[port] = (1 << pin);
N}
N
N/**
N * @brief	Set a GPIO port/bit to the low state
N * @param	pGPIO		: The base of GPIO peripheral on the chip
N * @param	portNum		: port number (support port 0 only)
N * @param	bitValue	: bit(s) in the port to set low
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output. It is recommended to use the
N * Chip_GPIO_SetPortOutLow() function instead.
N */
NSTATIC INLINE void Chip_GPIO_ClearValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
Xstatic __inline void Chip_GPIO_ClearValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
N{
N	pGPIO->CLR[portNum] = bitValue;
N}
N
N/**
N * @brief	Set selected GPIO output pins to the low state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pins	: pins (0..n) to set low
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
NSTATIC INLINE void Chip_GPIO_SetPortOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
Xstatic __inline void Chip_GPIO_SetPortOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
N{
N	pGPIO->CLR[port] = pins;
N}
N
N/**
N * @brief	Set an individual GPIO output pin to the low state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pin		: pin number (0..n) to set low
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
NSTATIC INLINE void Chip_GPIO_SetPinOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->CLR[port] = (1 << pin);
N}
N
N/**
N * @brief	Toggle selected GPIO output pins to the opposite state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pins	: pins (0..n) to toggle
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
NSTATIC INLINE void Chip_GPIO_PortToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
Xstatic __inline void Chip_GPIO_PortToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
N{
N	pGPIO->NOT[port] = pins;
N}
N
N/**
N * @brief	Toggle an individual GPIO output pin to the opposite state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pin		: pin number (0..n) to toggle
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
NSTATIC INLINE void Chip_GPIO_SetPinToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->NOT[port] = (1 << pin);
N}
N
N/**
N * @brief	Read current bit states for the selected port
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	portNum	: port number to read (supports port 0 only)
N * @return	Current value of GPIO port
N * @note	The current states of the bits for the port are read, regardless of
N * whether the GPIO port bits are input or output. It is recommended to use the
N * Chip_GPIO_GetPortValue() function instead.
N */
NSTATIC INLINE uint32_t Chip_GPIO_ReadValue(LPC_GPIO_T *pGPIO, uint8_t portNum)
Xstatic __inline uint32_t Chip_GPIO_ReadValue(LPC_GPIO_T *pGPIO, uint8_t portNum)
N{
N	return pGPIO->PIN[portNum];
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __GPIO_8XX_H_ */
L 186 ".\lpc_chip_82x\inc\chip.h" 2
N#include "mrt_8xx.h"
L 1 ".\lpc_chip_82x\inc\mrt_8xx.h" 1
N/*
N * @brief LPC8xx Multi-Rate Timer (MRT) registers and driver functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __MRT_8XX_H_
N#define __MRT_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup MRT_8XX CHIP: LPC8xx Multi-Rate Timer driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief LPC8xx MRT chip configuration
N */
N#define MRT_CHANNELS_NUM      (4)
N#define MRT_NO_IDLE_CHANNEL   (0x40)
N
N/**
N * @brief MRT register block structure
N */
Ntypedef struct {
N	__IO uint32_t INTVAL;	/*!< Timer interval register */
X	volatile uint32_t INTVAL;	 
N	__O  uint32_t TIMER;	/*!< Timer register */
X	volatile  uint32_t TIMER;	 
N	__IO uint32_t CTRL;		/*!< Timer control register */
X	volatile uint32_t CTRL;		 
N	__IO uint32_t STAT;		/*!< Timer status register */
X	volatile uint32_t STAT;		 
N} LPC_MRT_CH_T;
N
N/**
N * @brief MRT register block structure
N */
Ntypedef struct {
N	LPC_MRT_CH_T CHANNEL[MRT_CHANNELS_NUM];
X	LPC_MRT_CH_T CHANNEL[(4)];
N	uint32_t unused[45];
N	__O  uint32_t IDLE_CH;
X	volatile  uint32_t IDLE_CH;
N	__IO uint32_t IRQ_FLAG;
X	volatile uint32_t IRQ_FLAG;
N} LPC_MRT_T;
N
N/* Reserved bits masks for registers */
N#define MRT_CTRL_RESERVED   (~7)
N#define MRT_STAT_RESERVED   (~3)
N
N/**
N * @brief MRT Interrupt Modes enum
N */
Ntypedef enum MRT_MODE {
N	MRT_MODE_REPEAT =  (0 << 1),	/*!< MRT Repeat interrupt mode */
N	MRT_MODE_ONESHOT = (1 << 1)		/*!< MRT One-shot interrupt mode */
N} MRT_MODE_T;
N
N/**
N * @brief MRT register bit fields & masks
N */
N/* MRT Time interval register bit fields */
N#define MRT_INTVAL_IVALUE        (0x7FFFFFFFUL)	/* Maximum interval load value and mask */
N#define MRT_INTVAL_LOAD          (0x80000000UL)	/* Force immediate load of timer interval register bit */
N
N/* MRT Control register bit fields & masks */
N#define MRT_CTRL_INTEN_MASK      (0x01)
N#define MRT_CTRL_MODE_MASK       (0x06)
N
N/* MRT Status register bit fields & masks */
N#define MRT_STAT_INTFLAG         (0x01)
N#define MRT_STAT_RUNNING         (0x02)
N
N/* Pointer to individual MR register blocks */
N#define LPC_MRT_CH0         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[0])
N#define LPC_MRT_CH1         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[1])
N#define LPC_MRT_CH2         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[2])
N#define LPC_MRT_CH3         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[3])
N#define LPC_MRT_CH(ch)      ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[(ch)])
N
N/* Global interrupt flag register interrupt mask/clear values */
N#define MRT0_INTFLAG        (1)
N#define MRT1_INTFLAG        (2)
N#define MRT2_INTFLAG        (4)
N#define MRT3_INTFLAG        (8)
N#define MRTn_INTFLAG(ch)    (1 << (ch))
N
N/**
N * @brief	Initializes the MRT
N * @return	Nothing
N */
NSTATIC INLINE void Chip_MRT_Init(void)
Xstatic __inline void Chip_MRT_Init(void)
N{
N	/* Enable the clock to the register interface */
N	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_MRT);
N
N	/* Reset MRT */
N	Chip_SYSCTL_PeriphReset(RESET_MRT);
N}
N
N/**
N * @brief	De-initializes the MRT Channel
N * @return	Nothing
N */
NSTATIC INLINE void Chip_MRT_DeInit(void)
Xstatic __inline void Chip_MRT_DeInit(void)
N{
N	/* Disable the clock to the MRT */
N	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_MRT);
N}
N
N/**
N * @brief	Returns a pointer to the register block for a MRT channel
N * @param	ch	: MRT channel tog et register block for (0..3)
N * @return	Pointer to the MRT register block for the channel
N */
NSTATIC INLINE LPC_MRT_CH_T *Chip_MRT_GetRegPtr(uint8_t ch)
Xstatic __inline LPC_MRT_CH_T *Chip_MRT_GetRegPtr(uint8_t ch)
N{
N	return LPC_MRT_CH(ch);
X	return ((LPC_MRT_CH_T *) &((LPC_MRT_T *) (0x40004000UL))->CHANNEL[(ch)]);
N}
N
N/**
N * @brief	Returns the timer time interval value
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Timer time interval value (IVALUE)
N */
NSTATIC INLINE uint32_t Chip_MRT_GetInterval(LPC_MRT_CH_T *pMRT)
Xstatic __inline uint32_t Chip_MRT_GetInterval(LPC_MRT_CH_T *pMRT)
N{
N	return pMRT->INTVAL;
N}
N
N/**
N * @brief	Sets the timer time interval value
N * @param	pMRT	 : Pointer to selected MRT Channel
N * @param   interval : The interval timeout (31-bits)
N * @return	Nothing
N * @note	Setting bit 31 in timer time interval register causes the time interval value
N * to load immediately, otherwise the time interval value will be loaded in
N * next timer cycle.<br>
N * Example: Chip_MRT_SetInterval(pMRT, 0x500 | MRT_INTVAL_LOAD); // Will load timer interval immediately<br>
N * Example: Chip_MRT_SetInterval(pMRT, 0x500); // Will load timer interval after internal expires
N */
NSTATIC INLINE void Chip_MRT_SetInterval(LPC_MRT_CH_T *pMRT, uint32_t interval)
Xstatic __inline void Chip_MRT_SetInterval(LPC_MRT_CH_T *pMRT, uint32_t interval)
N{
N	pMRT->INTVAL = interval;
N}
N
N/**
N * @brief	Returns the current timer value
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	The current timer value
N */
NSTATIC INLINE uint32_t Chip_MRT_GetTimer(LPC_MRT_CH_T *pMRT)
Xstatic __inline uint32_t Chip_MRT_GetTimer(LPC_MRT_CH_T *pMRT)
N{
N	return pMRT->TIMER;
N}
N
N/**
N * @brief	Returns true if the timer is enabled
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if enabled, Flase if not enabled
N */
NSTATIC INLINE bool Chip_MRT_GetEnabled(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_GetEnabled(LPC_MRT_CH_T *pMRT)
N{
N	return (bool) ((pMRT->CTRL & MRT_CTRL_INTEN_MASK) != 0);
X	return (_Bool) ((pMRT->CTRL & (0x01)) != 0);
N}
N
N/**
N * @brief	Enables the timer
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Nothing
N */
NSTATIC INLINE void Chip_MRT_SetEnabled(LPC_MRT_CH_T *pMRT)
Xstatic __inline void Chip_MRT_SetEnabled(LPC_MRT_CH_T *pMRT)
N{
N	pMRT->CTRL = MRT_CTRL_INTEN_MASK | (pMRT->CTRL & ~MRT_CTRL_RESERVED);
X	pMRT->CTRL = (0x01) | (pMRT->CTRL & ~(~7));
N}
N
N/**
N * @brief	Disables the timer
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Nothing
N */
NSTATIC INLINE void Chip_MRT_SetDisabled(LPC_MRT_CH_T *pMRT)
Xstatic __inline void Chip_MRT_SetDisabled(LPC_MRT_CH_T *pMRT)
N{
N	pMRT->CTRL &= ~(MRT_CTRL_INTEN_MASK | MRT_CTRL_RESERVED);
X	pMRT->CTRL &= ~((0x01) | (~7));
N}
N
N/**
N * @brief	Returns the timer mode (repeat or one-shot)
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	The current timer mode
N */
NSTATIC INLINE MRT_MODE_T Chip_MRT_GetMode(LPC_MRT_CH_T *pMRT)
Xstatic __inline MRT_MODE_T Chip_MRT_GetMode(LPC_MRT_CH_T *pMRT)
N{
N	return (MRT_MODE_T) (pMRT->CTRL & MRT_CTRL_MODE_MASK);
X	return (MRT_MODE_T) (pMRT->CTRL & (0x06));
N}
N
N/**
N * @brief	Sets the timer mode (repeat or one-shot)
N * @param	pMRT	: Pointer to selected MRT Channel
N * @param   mode    : Timer mode
N * @return	Nothing
N */
NSTATIC INLINE void Chip_MRT_SetMode(LPC_MRT_CH_T *pMRT, MRT_MODE_T mode)
Xstatic __inline void Chip_MRT_SetMode(LPC_MRT_CH_T *pMRT, MRT_MODE_T mode)
N{
N	uint32_t reg;
N
N	reg = pMRT->CTRL & ~(MRT_CTRL_MODE_MASK | MRT_CTRL_RESERVED);
X	reg = pMRT->CTRL & ~((0x06) | (~7));
N	pMRT->CTRL = reg | (uint32_t) mode;
N}
N
N/**
N * @brief	Check if the timer is configured in repeat mode
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if in repeat mode, False if in one-shot mode
N */
NSTATIC INLINE bool Chip_MRT_IsRepeatMode(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_IsRepeatMode(LPC_MRT_CH_T *pMRT)
N{
N	return ((pMRT->CTRL & MRT_CTRL_MODE_MASK) != 0) ? false : true;
X	return ((pMRT->CTRL & (0x06)) != 0) ? 0 : 1;
N}
N
N/**
N * @brief	Check if the timer is configured in one-shot mode
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if in one-shot mode, False if in repeat mode
N */
NSTATIC INLINE bool Chip_MRT_IsOneShotMode(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_IsOneShotMode(LPC_MRT_CH_T *pMRT)
N{
N	return ((pMRT->CTRL & MRT_CTRL_MODE_MASK) != 0) ? true : false;
X	return ((pMRT->CTRL & (0x06)) != 0) ? 1 : 0;
N}
N
N/**
N * @brief	Check if the timer has an interrupt pending
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if interrupt is pending, False if no interrupt is pending
N */
NSTATIC INLINE bool Chip_MRT_IntPending(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_IntPending(LPC_MRT_CH_T *pMRT)
N{
N	return (bool) ((pMRT->STAT & MRT_STAT_INTFLAG) != 0);
X	return (_Bool) ((pMRT->STAT & (0x01)) != 0);
N}
N
N/**
N * @brief	Clears the pending interrupt (if any)
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Nothing
N */
NSTATIC INLINE void Chip_MRT_IntClear(LPC_MRT_CH_T *pMRT)
Xstatic __inline void Chip_MRT_IntClear(LPC_MRT_CH_T *pMRT)
N{
N	pMRT->STAT = MRT_STAT_INTFLAG | (pMRT->STAT & ~MRT_STAT_RESERVED);
X	pMRT->STAT = (0x01) | (pMRT->STAT & ~(~3));
N}
N
N/**
N * @brief	Check if the timer is running
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if running, False if stopped
N */
NSTATIC INLINE bool Chip_MRT_Running(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_Running(LPC_MRT_CH_T *pMRT)
N{
N	return (bool) ((pMRT->STAT & MRT_STAT_RUNNING) != 0);
X	return (_Bool) ((pMRT->STAT & (0x02)) != 0);
N}
N
N/**
N * @brief	Returns the IDLE channel value
N * @return	IDLE channel value (unshifted in bits 7..4)
N */
NSTATIC INLINE uint8_t Chip_MRT_GetIdleChannel(void)
Xstatic __inline uint8_t Chip_MRT_GetIdleChannel(void)
N{
N	return (uint8_t) (LPC_MRT->IDLE_CH);
X	return (uint8_t) (((LPC_MRT_T *) (0x40004000UL))->IDLE_CH);
N}
N
N/**
N * @brief	Returns the IDLE channel value
N * @return	IDLE channel value (shifted in bits 3..0)
N */
NSTATIC INLINE uint8_t Chip_MRT_GetIdleChannelShifted(void)
Xstatic __inline uint8_t Chip_MRT_GetIdleChannelShifted(void)
N{
N	return (uint8_t) (Chip_MRT_GetIdleChannel() >> 4);
N}
N
N/**
N * @brief	Returns the interrupt pending status for all MRT channels
N * @return	IRQ pending channel bitfield(bit 0 = MRT0, bit 1 = MRT1, etc.)
N */
NSTATIC INLINE uint32_t Chip_MRT_GetIntPending(void)
Xstatic __inline uint32_t Chip_MRT_GetIntPending(void)
N{
N	return LPC_MRT->IRQ_FLAG;
X	return ((LPC_MRT_T *) (0x40004000UL))->IRQ_FLAG;
N}
N
N/**
N * @brief	Returns the interrupt pending status for a singel MRT channel
N * @param	ch	: Channel to check pending interrupt status for
N * @return	IRQ pending channel number
N */
NSTATIC INLINE bool Chip_MRT_GetIntPendingByChannel(uint8_t ch)
Xstatic __inline _Bool Chip_MRT_GetIntPendingByChannel(uint8_t ch)
N{
N	return (bool) (((LPC_MRT->IRQ_FLAG >> ch) & 1) != 0);
X	return (_Bool) (((((LPC_MRT_T *) (0x40004000UL))->IRQ_FLAG >> ch) & 1) != 0);
N}
N
N/**
N * @brief	Clears the interrupt pending status for one or more MRT channels
N * @param	mask	: Channels to clear (bit 0 = MRT0, bit 1 = MRT1, etc.)
N * @return	Nothing
N * @note	Use this function to clear multiple interrupt pending states in
N * a single call via the IRQ_FLAG register. Performs the same function for
N * all MRT channels in a single call as the Chip_MRT_IntClear() does for a
N * single channel.
N */
NSTATIC INLINE void Chip_MRT_ClearIntPending(uint32_t mask)
Xstatic __inline void Chip_MRT_ClearIntPending(uint32_t mask)
N{
N	LPC_MRT->IRQ_FLAG = mask;
X	((LPC_MRT_T *) (0x40004000UL))->IRQ_FLAG = mask;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MRT_8XX_H_ */
L 187 ".\lpc_chip_82x\inc\chip.h" 2
N#include "uart_8xx.h"
L 1 ".\lpc_chip_82x\inc\uart_8xx.h" 1
N/*
N * @brief LPC8xx UART driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __UART_8XX_H_
N#define __UART_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "ring_buffer.h"
L 1 ".\lpc_chip_82x\inc\ring_buffer.h" 1
N/*
N * @brief Common ring buffer support functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __RING_BUFFER_H_
N#define __RING_BUFFER_H_
N
N#include "lpc_types.h"
N
N/** @defgroup Ring_Buffer CHIP: Simple ring buffer implementation
N * @ingroup CHIP_Common
N * @{
N */
N
N/**
N * @brief Ring buffer structure
N */
Ntypedef struct {
N	void *data;
N	int count;
N	int itemSz;
N	uint32_t head;
N	uint32_t tail;
N} RINGBUFF_T;
N
N/**
N * @def		RB_VHEAD(rb)
N * volatile typecasted head index
N */
N#define RB_VHEAD(rb)              (*(volatile uint32_t *) &(rb)->head)
N
N/**
N * @def		RB_VTAIL(rb)
N * volatile typecasted tail index
N */
N#define RB_VTAIL(rb)              (*(volatile uint32_t *) &(rb)->tail)
N
N/**
N * @brief	Initialize ring buffer
N * @param	RingBuff	: Pointer to ring buffer to initialize
N * @param	buffer		: Pointer to buffer to associate with RingBuff
N * @param	itemSize	: Size of each buffer item size
N * @param	count		: Size of ring buffer
N * @note	Memory pointed by @a buffer must have correct alignment of
N * 			@a itemSize, and @a count must be a power of 2 and must at
N * 			least be 2 or greater.
N * @return	Nothing
N */
Nint RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count);
N
N/**
N * @brief	Resets the ring buffer to empty
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Nothing
N */
NSTATIC INLINE void RingBuffer_Flush(RINGBUFF_T *RingBuff)
Xstatic __inline void RingBuffer_Flush(RINGBUFF_T *RingBuff)
N{
N	RingBuff->head = RingBuff->tail = 0;
N}
N
N/**
N * @brief	Return size the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Size of the ring buffer in bytes
N */
NSTATIC INLINE int RingBuffer_GetSize(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_GetSize(RINGBUFF_T *RingBuff)
N{
N	return RingBuff->count;
N}
N
N/**
N * @brief	Return number of items in the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Number of items in the ring buffer
N */
NSTATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
N{
N	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
X	return (*(volatile uint32_t *) &(RingBuff)->head) - (*(volatile uint32_t *) &(RingBuff)->tail);
N}
N
N/**
N * @brief	Return number of free items in the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Number of free items in the ring buffer
N */
NSTATIC INLINE int RingBuffer_GetFree(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_GetFree(RINGBUFF_T *RingBuff)
N{
N	return RingBuff->count - RingBuffer_GetCount(RingBuff);
N}
N
N/**
N * @brief	Return number of items in the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	1 if the ring buffer is full, otherwise 0
N */
NSTATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
N{
N	return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
N}
N
N/**
N * @brief	Return empty status of ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	1 if the ring buffer is empty, otherwise 0
N */
NSTATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
N{
N	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
X	return (*(volatile uint32_t *) &(RingBuff)->head) == (*(volatile uint32_t *) &(RingBuff)->tail);
N}
N
N/**
N * @brief	Insert a single item into ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: pointer to item
N * @return	1 when successfully inserted,
N *			0 on error (Buffer not initialized using
N *			RingBuffer_Init() or attempted to insert
N *			when buffer is full)
N */
Nint RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data);
N
N/**
N * @brief	Insert an array of items into ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: Pointer to first element of the item array
N * @param	num			: Number of items in the array
N * @return	number of items successfully inserted,
N *			0 on error (Buffer not initialized using
N *			RingBuffer_Init() or attempted to insert
N *			when buffer is full)
N */
Nint RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num);
N
N/**
N * @brief	Pop an item from the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: Pointer to memory where popped item be stored
N * @return	1 when item popped successfuly onto @a data,
N * 			0 When error (Buffer not initialized using
N * 			RingBuffer_Init() or attempted to pop item when
N * 			the buffer is empty)
N */
Nint RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data);
N
N/**
N * @brief	Pop an array of items from the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: Pointer to memory where popped items be stored
N * @param	num			: Max number of items array @a data can hold
N * @return	Number of items popped onto @a data,
N * 			0 on error (Buffer not initialized using RingBuffer_Init()
N * 			or attempted to pop when the buffer is empty)
N */
Nint RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num);
N
N
N/**
N * @}
N */
N
N#endif /* __RING_BUFFER_H_ */
L 40 ".\lpc_chip_82x\inc\uart_8xx.h" 2
N
N/** @defgroup UART_8XX CHIP: LPC8xx UART Driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief UART register block structure
N */
Ntypedef struct {
N	__IO uint32_t  CFG;				/*!< Configuration register */
X	volatile uint32_t  CFG;				 
N	__IO uint32_t  CTRL;			/*!< Control register */
X	volatile uint32_t  CTRL;			 
N	__IO uint32_t  STAT;			/*!< Status register */
X	volatile uint32_t  STAT;			 
N	__IO uint32_t  INTENSET;		/*!< Interrupt Enable read and set register */
X	volatile uint32_t  INTENSET;		 
N	__O  uint32_t  INTENCLR;		/*!< Interrupt Enable clear register */
X	volatile  uint32_t  INTENCLR;		 
N	__I  uint32_t  RXDATA;			/*!< Receive Data register */
X	volatile const  uint32_t  RXDATA;			 
N	__I  uint32_t  RXDATA_STAT;		/*!< Receive Data with status register */
X	volatile const  uint32_t  RXDATA_STAT;		 
N	__IO uint32_t  TXDATA;			/*!< Transmit data register */
X	volatile uint32_t  TXDATA;			 
N	__IO uint32_t  BRG;				/*!< Baud Rate Generator register */
X	volatile uint32_t  BRG;				 
N	__IO uint32_t  INTSTAT;			/*!< Interrupt status register */
X	volatile uint32_t  INTSTAT;			 
N	__IO uint32_t  OSR;             /*!< Oversampling Selection regiser */
X	volatile uint32_t  OSR;              
N	__IO uint32_t  ADDR;            /*!< Address register for automatic address matching */
X	volatile uint32_t  ADDR;             
N} LPC_USART_T;
N
N/**
N * @brief UART CFG register definitions
N */
N#define UART_CFG_ENABLE         (0x01 << 0)
N#define UART_CFG_DATALEN_7      (0x00 << 2)		/*!< UART 7 bit length mode */
N#define UART_CFG_DATALEN_8      (0x01 << 2)		/*!< UART 8 bit length mode */
N#define UART_CFG_DATALEN_9      (0x02 << 2)		/*!< UART 9 bit length mode */
N#define UART_CFG_PARITY_NONE    (0x00 << 4)		/*!< No parity */
N#define UART_CFG_PARITY_EVEN    (0x02 << 4)		/*!< Even parity */
N#define UART_CFG_PARITY_ODD     (0x03 << 4)		/*!< Odd parity */
N#define UART_CFG_STOPLEN_1      (0x00 << 6)		/*!< UART One Stop Bit Select */
N#define UART_CFG_STOPLEN_2      (0x01 << 6)		/*!< UART Two Stop Bits Select */
N#define UART_CFG_CTSEN          (0x01 << 9)		/*!< CTS enable bit */
N#define UART_CFG_SYNCEN         (0x01 << 11)	/*!< Synchronous mode enable bit */
N#define UART_CFG_CLKPOL         (0x01 << 12)	/*!< Un_RXD rising edge sample enable bit */
N#define UART_CFG_SYNCMST        (0x01 << 14)	/*!< Select master mode (synchronous mode) enable bit */
N#define UART_CFG_LOOP           (0x01 << 15)	/*!< Loopback mode enable bit */
N
N#ifdef CHIP_LPC82X /* LPC82X specific bits */
N#define UART_CFG_OETA           (0x01 << 18)    /*!< Output Enable Turnaround time for RS485 */
N#define UART_CFG_AUTOADDR       (0x01 << 19)    /*!< Automatic address matching enable */
N#define UART_CFG_OESEL          (0x01 << 20)    /*!< Output enable select */
N#define UART_CFG_OEPOL          (0x01 << 21)    /*!< Output enable polarity */
N#define UART_CFG_RXPOL          (0x01 << 22)    /*!< Receive data polarity */
N#define UART_CFG_TXPOL          (0x01 << 22)    /*!< Transmit data polarity */
N#define UART_CFG_RESERVED       ((1<<1)|(1<<7)|(1<<8)|(1<<10)|(1<<13)|(3 << 16)|(0xffu<<24))
N#else
S#define UART_CFG_RESERVED       ((1<<1)|(1<<7)|(1<<8)|(1<<10)|(1<<13)|(0xffffu<<16))
N#endif
N
N/**
N * @brief UART CTRL register definitions
N */
N#define UART_CTRL_TXBRKEN       (0x01 << 1)		/*!< Continuous break enable bit */
N#define UART_CTRL_ADDRDET       (0x01 << 2)		/*!< Address detect mode enable bit */
N#define UART_CTRL_TXDIS         (0x01 << 6)		/*!< Transmit disable bit */
N#define UART_CTRL_CC            (0x01 << 8)		/*!< Continuous Clock mode enable bit */
N#define UART_CTRL_CLRCC         (0x01 << 9)		/*!< Clear Continuous Clock bit */
N#ifdef CHIP_LPC82X
N#define UART_CTRL_AUTOBAUD      (1 << 16)       /*!< Enable UART Autobaud */
N#define UART_CTRL_RESERVED      (0xFFFEFCB9U)
N#else
S#define UART_CTRL_RESERVED      (1|(7<<3)|(1<<7)|0xfffffc00u)
N#endif
N
N/**
N * @brief UART STAT register definitions
N */
N#define UART_STAT_RXRDY         (0x01 << 0)			/*!< Receiver ready */
N#define UART_STAT_RXIDLE        (0x01 << 1)			/*!< Receiver idle */
N#define UART_STAT_TXRDY         (0x01 << 2)			/*!< Transmitter ready for data */
N#define UART_STAT_TXIDLE        (0x01 << 3)			/*!< Transmitter idle */
N#define UART_STAT_CTS           (0x01 << 4)			/*!< Status of CTS signal */
N#define UART_STAT_DELTACTS      (0x01 << 5)			/*!< Change in CTS state */
N#define UART_STAT_TXDISINT      (0x01 << 6)			/*!< Transmitter disabled */
N#define UART_STAT_OVERRUNINT    (0x01 << 8)			/*!< Overrun Error interrupt flag. */
N#define UART_STAT_RXBRK         (0x01 << 10)		/*!< Received break */
N#define UART_STAT_DELTARXBRK    (0x01 << 11)		/*!< Change in receive break detection */
N#define UART_STAT_START         (0x01 << 12)		/*!< Start detected */
N#define UART_STAT_FRM_ERRINT    (0x01 << 13)		/*!< Framing Error interrupt flag */
N#define UART_STAT_PAR_ERRINT    (0x01 << 14)		/*!< Parity Error interrupt flag */
N#define UART_STAT_RXNOISEINT    (0x01 << 15)		/*!< Received Noise interrupt flag */
N#ifdef CHIP_LPC82X
N#define UART_STAT_ABERR         (0x01 << 16)        /*!< Auto baud error */
N#define UART_STAT_RESERVED      ((1<<7)|(1<<9)|(0xFFFEU<<16))
N#else
S#define UART_STAT_RESERVED      ((1<<7)|(1<<9)|(0xffffu<<16))
N#endif
N
N/**
N * @brief UART INTENSET/INTENCLR register definitions
N */
N#define UART_INTEN_RXRDY        (0x01 << 0)			/*!< Receive Ready interrupt */
N#define UART_INTEN_TXRDY        (0x01 << 2)			/*!< Transmit Ready interrupt */
N#define UART_INTEN_DELTACTS     (0x01 << 5)			/*!< Change in CTS state interrupt */
N#define UART_INTEN_TXDIS        (0x01 << 6)			/*!< Transmitter disable interrupt */
N#define UART_INTEN_OVERRUN      (0x01 << 8)			/*!< Overrun error interrupt */
N#define UART_INTEN_DELTARXBRK   (0x01 << 11)		/*!< Change in receiver break detection interrupt */
N#define UART_INTEN_START        (0x01 << 12)		/*!< Start detect interrupt */
N#define UART_INTEN_FRAMERR      (0x01 << 13)		/*!< Frame error interrupt */
N#define UART_INTEN_PARITYERR    (0x01 << 14)		/*!< Parity error interrupt */
N#define UART_INTEN_RXNOISE      (0x01 << 15)		/*!< Received noise interrupt */
N#ifdef CHIP_LPC82X
N#define UART_INTEN_TXIDLE       (0x01 << 3)         /*!< TX Idle enable/clear */
N#define UART_INTEN_ABERR        (0x01 << 16)        /*!< Auto baud error */
N#define UART_INTEN_RESERVED     ((1<<1)|(1<<4)|(1<<7)|(3<<9)|(0xfffeu<<16))
N#define UART_INTSTAT_RESERVED   ((1<<1)|(1<<4)|(1<<7)|(3<<9)|(0xfffeu<<16))
N#else
S#define UART_INTEN_RESERVED     ((1<<1)|(3<<3)|(1<<7)|(3<<9)|(0xffffu<<16))
S#define UART_INTSTAT_RESERVED   ((1<<1)|(3<<3)|(1<<7)|(3<<9)|(0xffffu<<16))
N#endif
N
N/**
N * @brief	Enable the UART
N * @param	pUART		: Pointer to selected UARTx peripheral
N * @return	Nothing
N */
NSTATIC INLINE void Chip_UART_Enable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_Enable(LPC_USART_T *pUART)
N{
N	pUART->CFG = UART_CFG_ENABLE | (pUART->CFG & ~UART_CFG_RESERVED);
X	pUART->CFG = (0x01 << 0) | (pUART->CFG & ~((1<<1)|(1<<7)|(1<<8)|(1<<10)|(1<<13)|(3 << 16)|(0xffu<<24)));
N}
N
N/**
N * @brief	Disable the UART
N * @param	pUART	: Pointer to selected UARTx peripheral
N * @return	Nothing
N */
NSTATIC INLINE void Chip_UART_Disable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_Disable(LPC_USART_T *pUART)
N{
N	pUART->CFG &= ~(UART_CFG_RESERVED | UART_CFG_ENABLE);
X	pUART->CFG &= ~(((1<<1)|(1<<7)|(1<<8)|(1<<10)|(1<<13)|(3 << 16)|(0xffu<<24)) | (0x01 << 0));
N}
N
N/**
N * @brief	Enable transmission on UART TxD pin
N * @param	pUART	: Pointer to selected pUART peripheral
N * @return Nothing
N */
NSTATIC INLINE void Chip_UART_TXEnable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_TXEnable(LPC_USART_T *pUART)
N{
N	pUART->CTRL &= ~(UART_CTRL_RESERVED | UART_CTRL_TXDIS);
X	pUART->CTRL &= ~((0xFFFEFCB9U) | (0x01 << 6));
N}
N
N/**
N * @brief	Disable transmission on UART TxD pin
N * @param	pUART	: Pointer to selected pUART peripheral
N * @return Nothing
N */
NSTATIC INLINE void Chip_UART_TXDisable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_TXDisable(LPC_USART_T *pUART)
N{
N	pUART->CTRL = UART_CTRL_TXDIS | (pUART->CTRL & ~UART_CTRL_RESERVED);
X	pUART->CTRL = (0x01 << 6) | (pUART->CTRL & ~(0xFFFEFCB9U));
N}
N
N/**
N * @brief	Transmit a single data byte through the UART peripheral
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	data	: Byte to transmit
N * @return	Nothing
N * @note	This function attempts to place a byte into the UART transmit
N *			holding register regard regardless of UART state.
N */
NSTATIC INLINE void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
Xstatic __inline void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
N{
N	pUART->TXDATA = (uint32_t) data;
N}
N
N/**
N * @brief	Read a single byte data from the UART peripheral
N * @param	pUART	: Pointer to selected UART peripheral
N * @return	A single byte of data read
N * @note	This function reads a byte from the UART receive FIFO or
N *			receive hold register regard regardless of UART state. The
N *			FIFO status should be read first prior to using this function
N */
NSTATIC INLINE uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
N{
N	/* Strip off undefined reserved bits, keep 9 lower bits */
N	return (uint32_t) (pUART->RXDATA & 0x000001FF);
N}
N
N/**
N * @brief	Enable UART interrupts
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	intMask	: OR'ed Interrupts to enable
N * @return	Nothing
N * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
N *			to enable specific UART interrupts.
N */
NSTATIC INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
Xstatic __inline void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
N{
N	pUART->INTENSET = intMask;
N}
N
N/**
N * @brief	Disable UART interrupts
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	intMask	: OR'ed Interrupts to disable
N * @return	Nothing
N * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
N *			to disable specific UART interrupts.
N */
NSTATIC INLINE void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
Xstatic __inline void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
N{
N	pUART->INTENCLR = intMask;
N}
N
N/**
N * @brief	Returns UART interrupts that are enabled
N * @param	pUART	: Pointer to selected UART peripheral
N * @return	Returns the enabled UART interrupts
N * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
N *			to determine which interrupts are enabled. You can check
N *			for multiple enabled bits if needed.
N */
NSTATIC INLINE uint32_t Chip_UART_GetIntsEnabled(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetIntsEnabled(LPC_USART_T *pUART)
N{
N	return (pUART->INTENSET & ~UART_INTEN_RESERVED);
X	return (pUART->INTENSET & ~((1<<1)|(1<<4)|(1<<7)|(3<<9)|(0xfffeu<<16)));
N}
N
N/**
N * @brief	Get UART interrupt status
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	The Interrupt status register of UART
N * @note	Multiple interrupts may be pending. Mask the return value
N *			with one or more UART_INTEN_* definitions to determine
N *			pending interrupts.
N */
NSTATIC INLINE uint32_t Chip_UART_GetIntStatus(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetIntStatus(LPC_USART_T *pUART)
N{
N	return (pUART->INTSTAT & ~UART_INTSTAT_RESERVED);
X	return (pUART->INTSTAT & ~((1<<1)|(1<<4)|(1<<7)|(3<<9)|(0xfffeu<<16)));
N}
N
N/**
N * @brief	Configure data width, parity and stop bits
N * @param	pUART	: Pointer to selected pUART peripheral
N * @param	config	: UART configuration, OR'ed values of select UART_CFG_* defines
N * @return	Nothing
N * @note	Select OR'ed config options for the UART from the UART_CFG_PARITY_*,
N *			UART_CFG_STOPLEN_*, and UART_CFG_DATALEN_* definitions. For example,
N *			a configuration of 8 data bits, 1 stop bit, and even (enabled) parity would be
N *			(UART_CFG_DATALEN_8 | UART_CFG_STOPLEN_1 | UART_CFG_PARITY_EVEN). Will not
N *			alter other bits in the CFG register.
N */
NSTATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
Xstatic __inline void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
N{
N	uint32_t reg;
N
N	reg = pUART->CFG & ~((0x3 << 2) | (0x3 << 4) | (0x1 << 6) | UART_CFG_RESERVED);
X	reg = pUART->CFG & ~((0x3 << 2) | (0x3 << 4) | (0x1 << 6) | ((1<<1)|(1<<7)|(1<<8)|(1<<10)|(1<<13)|(3 << 16)|(0xffu<<24)));
N	pUART->CFG = reg | config;
N}
N
N/**
N * @brief	Get the UART status register
N * @param	pUART	: Pointer to selected UARTx peripheral
N * @return	UART status register
N * @note	Multiple statuses may be pending. Mask the return value
N *			with one or more UART_STAT_* definitions to determine
N *			statuses.
N */
NSTATIC INLINE uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
N{
N	return (pUART->STAT & ~UART_STAT_RESERVED);
X	return (pUART->STAT & ~((1<<7)|(1<<9)|(0xFFFEU<<16)));
N}
N
N/**
N * @brief	Clear the UART status register
N * @param	pUART	: Pointer to selected UARTx peripheral
N * @param	stsMask	: OR'ed statuses to disable
N * @return	Nothing
N * @note	Multiple interrupts may be pending. Mask the return value
N *			with one or more UART_INTEN_* definitions to determine
N *			pending interrupts.
N */
NSTATIC INLINE void Chip_UART_ClearStatus(LPC_USART_T *pUART, uint32_t stsMask)
Xstatic __inline void Chip_UART_ClearStatus(LPC_USART_T *pUART, uint32_t stsMask)
N{
N	pUART->STAT = stsMask;
N}
N
N/**
N * @brief	Set oversample value
N * @param	pUART		: Pointer to selected UARTx peripheral
N * @param	ovrVal		: Oversample value (can be from 5 to 16)
N * @return	Nothing
N * @note	The valid values for ovrVal is 5 to 16 (samples per bit)
N */
NSTATIC INLINE void Chip_UART_SetOSR(LPC_USART_T *pUART, uint32_t ovrVal)
Xstatic __inline void Chip_UART_SetOSR(LPC_USART_T *pUART, uint32_t ovrVal)
N{
N	pUART->OSR = ovrVal - 1;
N}
N
N/**
N * @brief	Set address for hardware address matching
N * @param	pUART		: Pointer to selected UARTx peripheral
N * @param	addr		: Address to compare (0x00 to 0xFF)
N * @return	Nothing
N * @note	The valid values for addr is 0x00 to 0xFF
N */
NSTATIC INLINE void Chip_UART_SetAddr(LPC_USART_T *pUART, uint32_t addr)
Xstatic __inline void Chip_UART_SetAddr(LPC_USART_T *pUART, uint32_t addr)
N{
N	pUART->ADDR = addr;
N}
N
N/**
N * @brief	Initialize the UART peripheral
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_UART_Init(LPC_USART_T *pUART);
N
N/**
N * @brief	Deinitialize the UART peripheral
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_UART_DeInit(LPC_USART_T *pUART);
N
N/**
N * @brief	Transmit a byte array through the UART peripheral (non-blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to bytes to transmit
N * @param	numBytes	: Number of bytes to transmit
N * @return	The actual number of bytes placed into the FIFO
N * @note	This function places data into the transmit FIFO until either
N *			all the data is in the FIFO or the FIFO is full. This function
N *			will not block in the FIFO is full. The actual number of bytes
N *			placed into the FIFO is returned. This function ignores errors.
N */
Nint Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes);
N
N/**
N * @brief	Read data through the UART peripheral (non-blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to bytes array to fill
N * @param	numBytes	: Size of the passed data array
N * @return	The actual number of bytes read
N * @note	This function reads data from the receive FIFO until either
N *			all the data has been read or the passed buffer is completely full.
N *			This function will not block. This function ignores errors.
N */
Nint Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes);
N
N/**
N * @brief	Set baud rate for UART
N * @param	pUART	: The base of UART peripheral on the chip
N * @param	baudrate: Baud rate to be set
N * @return	Nothing
N */
Nvoid Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate);
N
N/**
N * @brief	Transmit a byte array through the UART peripheral (blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to data to transmit
N * @param	numBytes	: Number of bytes to transmit
N * @return	The number of bytes transmitted
N * @note	This function will send or place all bytes into the transmit
N *			FIFO. This function will block until the last bytes are in the FIFO.
N */
Nint Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes);
N
N/**
N * @brief	Read data through the UART peripheral (blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to data array to fill
N * @param	numBytes	: Size of the passed data array
N * @return	The size of the dat array
N * @note	This function reads data from the receive FIFO until the passed
N *			buffer is completely full. The function will block until full.
N *			This function ignores errors.
N */
Nint Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes);
N
N/**
N * @brief	UART receive-only interrupt handler for ring buffers
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @return	Nothing
N * @note	If ring buffer support is desired for the receive side
N *			of data transfer, the UART interrupt should call this
N *			function for a receive based interrupt status.
N */
Nvoid Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
N
N/**
N * @brief	UART transmit-only interrupt handler for ring buffers
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @return	Nothing
N * @note	If ring buffer support is desired for the transmit side
N *			of data transfer, the UART interrupt should call this
N *			function for a transmit based interrupt status.
N */
Nvoid Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
N
N/**
N * @brief	Populate a transmit ring buffer and start UART transmit
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @param	data	: Pointer to buffer to move to ring buffer
N * @param	count	: Number of bytes to move
N * @return	The number of bytes placed into the ring buffer
N * @note	Will move the data into the TX ring buffer and start the
N *			transfer. If the number of bytes returned is less than the
N *			number of bytes to send, the ring buffer is considered full.
N */
Nuint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int count);
N
N/**
N * @brief	Copy data from a receive ring buffer
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @param	data	: Pointer to buffer to fill from ring buffer
N * @param	bytes	: Size of the passed buffer in bytes
N * @return	The number of bytes placed into the ring buffer
N * @note	Will move the data from the RX ring buffer up to the
N *			the maximum passed buffer size. Returns 0 if there is
N *			no data in the ring buffer.
N */
Nint Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes);
N
N/**
N * @brief	UART receive/transmit interrupt handler for ring buffers
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRXRB	: Pointer to transmit ring buffer
N * @param	pTXRB	: Pointer to receive ring buffer
N * @return	Nothing
N * @note	This provides a basic implementation of the UART IRQ
N *			handler for support of a ring buffer implementation for
N *			transmit and receive.
N */
Nvoid Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __UART_8XX_H_ */
L 188 ".\lpc_chip_82x\inc\chip.h" 2
N#include "wkt_8xx.h"
L 1 ".\lpc_chip_82x\inc\wkt_8xx.h" 1
N/*
N * @brief LPC8xx Self Wakeup Timer (WKT) chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __WKT_8XX_H_
N#define __WKT_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup WKT_8XX CHIP: LPC8xx Self Wakeup Timer driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief Self wake-up timer register block structure
N */
Ntypedef struct {
N	__IO uint32_t  CTRL;	/*!< Offset: 0x000 Alarm/Wakeup Timer Control register */
X	volatile uint32_t  CTRL;	 
N	uint32_t  Reserved[2];
N	__IO uint32_t  COUNT;	/*!< Offset: 0x000C Alarm/Wakeup Timer Counter register */
X	volatile uint32_t  COUNT;	 
N} LPC_WKT_T;
N
N#define WKT_CTRL_RESERVED (~7)
N
N/**
N * WKT Control register bit fields & masks
N */
N#define WKT_CTRL_CLKSEL        ((uint32_t) (1 << 0))	/*!< Select the self wake-up timer clock source */
N#define WKT_CTRL_ALARMFLAG     ((uint32_t) (1 << 1))	/*!< Wake-up or alarm timer flag */
N#define WKT_CTRL_CLEARCTR      ((uint32_t) (1 << 2))	/*!< Clears the self wake-up timer */
N
N/**
N * WKT Clock source values enum
N */
Ntypedef enum  {
N	WKT_CLKSRC_DIVIRC = 0,	/*!< Divided IRC clock - runs at 750kHz */
N	WKT_CLKSRC_10KHZ = 1	/*!< Low power clock - runs at 10kHz */
N} WKT_CLKSRC_T;
N
N/**
N * @brief	Get clock source for WKT
N * @param	pWKT	: Pointer to WKT register block
N * @return	Clock source for the WKT
N */
NSTATIC INLINE WKT_CLKSRC_T Chip_WKT_GetClockSource(LPC_WKT_T *pWKT)
Xstatic __inline WKT_CLKSRC_T Chip_WKT_GetClockSource(LPC_WKT_T *pWKT)
N{
N	return (WKT_CLKSRC_T) (pWKT->CTRL & WKT_CTRL_CLKSEL);
X	return (WKT_CLKSRC_T) (pWKT->CTRL & ((uint32_t) (1 << 0)));
N}
N
N/**
N * @brief	Set clock source for WKT
N * @param	pWKT	: Pointer to WKT register block
N * @param	clkSrc	: Clock source for the WKT
N * @return	Nothing
N */
Nvoid Chip_WKT_SetClockSource(LPC_WKT_T *pWKT, WKT_CLKSRC_T clkSrc);
N
N/**
N * @brief	Return approximate rate for the selected clock source
N * @param	pWKT	: Pointer to WKT register block
N * @return	Clock rate of the selected clock source for WKT
N */
Nuint32_t Chip_WKT_GetClockRate(LPC_WKT_T *pWKT);
N
N/**
N * @brief	Get WKT interrupt pending status (ALARMFLAG)
N * @param	pWKT	: Pointer to WKT register block
N * @return	True if the interrupt is pending, otherwise false
N */
NSTATIC INLINE bool Chip_WKT_GetIntStatus(LPC_WKT_T *pWKT)
Xstatic __inline _Bool Chip_WKT_GetIntStatus(LPC_WKT_T *pWKT)
N{
N	return (bool) ((pWKT->CTRL & WKT_CTRL_ALARMFLAG) != 0);
X	return (_Bool) ((pWKT->CTRL & ((uint32_t) (1 << 1))) != 0);
N}
N
N/**
N * @brief	Clear WKT interrupt status (ALARMFLAG)
N * @param	pWKT	: Pointer to WKT register block
N * @return	Nothing
N */
NSTATIC INLINE void Chip_WKT_ClearIntStatus(LPC_WKT_T *pWKT)
Xstatic __inline void Chip_WKT_ClearIntStatus(LPC_WKT_T *pWKT)
N{
N	pWKT->CTRL = WKT_CTRL_ALARMFLAG | (pWKT->CTRL & ~WKT_CTRL_RESERVED);
X	pWKT->CTRL = ((uint32_t) (1 << 1)) | (pWKT->CTRL & ~(~7));
N}
N
N/**
N * @brief	Clear and stop WKT counter
N * @param	pWKT	: Pointer to WKT register block
N * @return	Nothing
N */
NSTATIC INLINE void Chip_WKT_Stop(LPC_WKT_T *pWKT)
Xstatic __inline void Chip_WKT_Stop(LPC_WKT_T *pWKT)
N{
N	pWKT->CTRL = WKT_CTRL_CLEARCTR | (pWKT->CTRL & ~WKT_CTRL_RESERVED);
X	pWKT->CTRL = ((uint32_t) (1 << 2)) | (pWKT->CTRL & ~(~7));
N}
N
N/**
N * @brief	Load count register and start count-down sequence
N * @param	pWKT	: Pointer to WKT register block
N * @param	count	: Count to load in the WKT
N * @return	Nothing
N * @note	This function should not be called if the WKT is already counting.
N */
NSTATIC INLINE void Chip_WKT_LoadCount(LPC_WKT_T *pWKT, uint32_t count)
Xstatic __inline void Chip_WKT_LoadCount(LPC_WKT_T *pWKT, uint32_t count)
N{
N	pWKT->COUNT = count;
N}
N
N/**
N * @brief	Start wake-up timer interrupt, set clock source, set timer interval
N * @param	pWKT	: Pointer to WKT register block
N * @param	clkSrc	: Clock source
N * @param	cntVal	: Timer interval
N * @return	None
N * @note	This function should not be called if the WKT is already counting.
N */
Nvoid Chip_WKT_Start(LPC_WKT_T *pWKT, WKT_CLKSRC_T clkSrc, uint32_t cntVal);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __WKT_8XX_H_ */
L 189 ".\lpc_chip_82x\inc\chip.h" 2
N#include "wwdt_8xx.h"
L 1 ".\lpc_chip_82x\inc\wwdt_8xx.h" 1
N/*
N * @brief LPC8xx WWDT chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __WWDT_8XX_H_
N#define __WWDT_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup LPC_WWDT CHIP: LPC8xx Windowed Watchdog driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/*!< WDT oscillator frequency value */
N#define WDT_OSC     (LPC8XX_IRC_FREQ)
N
N/**
N * @brief Windowed Watchdog register block structure
N */
Ntypedef struct {				/*!< WWDT Structure         */
N	__IO uint32_t  MOD;			/*!< Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer. */
X	volatile uint32_t  MOD;			 
N	__IO uint32_t  TC;			/*!< Watchdog timer constant register. This register determines the time-out value. */
X	volatile uint32_t  TC;			 
N	__O  uint32_t  FEED;		/*!< Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC. */
X	volatile  uint32_t  FEED;		 
N	__I  uint32_t  TV;			/*!< Watchdog timer value register. This register reads out the current value of the Watchdog timer. */
X	volatile const  uint32_t  TV;			 
N	__I  uint32_t  RESERVED0;
X	volatile const  uint32_t  RESERVED0;
N	__IO uint32_t  WARNINT;		/*!< Watchdog warning interrupt register. This register contains the Watchdog warning interrupt compare value. */
X	volatile uint32_t  WARNINT;		 
N	__IO uint32_t  WINDOW;		/*!< Watchdog timer window register. This register contains the Watchdog window value. */
X	volatile uint32_t  WINDOW;		 
N} LPC_WWDT_T;
N
N/* Reserved bits masks for registers */
N#define WWDT_MOD_RESERVED       (~0x3f)
N#define WWDT_TC_RESERVED        0xff000000
N#define WWDT_FEED_RESERVED      (~0xff)
N#define WWDT_TV_RESERVED        0xff000000
N#define WWDT_WARNINT_RESERVED   (~0x3ff)
N#define WWDT_WINDOW_RESERVED    0xff000000
N
N/**
N * @brief Watchdog Mode register definitions
N */
N/** Watchdog Mode Bitmask */
N#define WWDT_WDMOD_BITMASK          ((uint32_t) 0x1F)
N/** WWDT interrupt enable bit */
N#define WWDT_WDMOD_WDEN             ((uint32_t) (1 << 0))
N/** WWDT interrupt enable bit */
N#define WWDT_WDMOD_WDRESET          ((uint32_t) (1 << 1))
N/** WWDT time out flag bit */
N#define WWDT_WDMOD_WDTOF            ((uint32_t) (1 << 2))
N/** WDT Time Out flag bit */
N#define WWDT_WDMOD_WDINT            ((uint32_t) (1 << 3))
N
N/**
N * @brief	Initialize the Watchdog timer
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N */
Nvoid Chip_WWDT_Init(LPC_WWDT_T *pWWDT);
N
N/**
N * @brief	Shutdown the Watchdog timer
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N */
Nvoid Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT);
N
N/**
N * @brief	Set WDT timeout constant value used for feed
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
N * @return	none
N */
NSTATIC INLINE void Chip_WWDT_SetTimeOut(LPC_WWDT_T *pWWDT, uint32_t timeout)
Xstatic __inline void Chip_WWDT_SetTimeOut(LPC_WWDT_T *pWWDT, uint32_t timeout)
N{
N	pWWDT->TC = timeout;
N}
N
N/**
N * @brief	Feed watchdog timer
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N * @note	If this function isn't called, a watchdog timer warning will occur.
N * After the warning, a timeout will occur if a feed has happened.
N */
NSTATIC INLINE void Chip_WWDT_Feed(LPC_WWDT_T *pWWDT)
Xstatic __inline void Chip_WWDT_Feed(LPC_WWDT_T *pWWDT)
N{
N	pWWDT->FEED = 0xAA;
N	pWWDT->FEED = 0x55;
N}
N
N/**
N * @brief	Set WWDT warning interrupt
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	timeout	: WDT warning in ticks, between 0 and 1023
N * @return	None
N * @note	This is the number of ticks after the watchdog interrupt that the
N * warning interrupt will be generated.
N */
NSTATIC INLINE void Chip_WWDT_SetWarning(LPC_WWDT_T *pWWDT, uint32_t timeout)
Xstatic __inline void Chip_WWDT_SetWarning(LPC_WWDT_T *pWWDT, uint32_t timeout)
N{
N	pWWDT->WARNINT = timeout;
N}
N
N/**
N * @brief	Set WWDT window time
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
N * @return	None
N * @note	The watchdog timer must be fed between the timeout from the Chip_WWDT_SetTimeOut()
N * function and this function, with this function defining the last tick before the
N * watchdog window interrupt occurs.
N */
NSTATIC INLINE void Chip_WWDT_SetWindow(LPC_WWDT_T *pWWDT, uint32_t timeout)
Xstatic __inline void Chip_WWDT_SetWindow(LPC_WWDT_T *pWWDT, uint32_t timeout)
N{
N	pWWDT->WINDOW = timeout;
N}
N
N/**
N * @brief	Enable watchdog timer options
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	options	: An or'ed set of options of values
N *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
N * @return	None
N * @note	You can enable more than one option at once (ie, WWDT_WDMOD_WDRESET |
N * WWDT_WDMOD_WDPROTECT), but use the WWDT_WDMOD_WDEN after all other options
N * are set (or unset) with no other options. If WWDT_WDMOD_LOCK is used, it cannot
N * be unset.
N */
NSTATIC INLINE void Chip_WWDT_SetOption(LPC_WWDT_T *pWWDT, uint32_t options)
Xstatic __inline void Chip_WWDT_SetOption(LPC_WWDT_T *pWWDT, uint32_t options)
N{
N	pWWDT->MOD = options | (pWWDT->MOD & ~WWDT_MOD_RESERVED);
X	pWWDT->MOD = options | (pWWDT->MOD & ~(~0x3f));
N}
N
N/**
N * @brief	Disable/clear watchdog timer options
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	options	: An or'ed set of options of values
N *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
N * @return	None
N * @note	You can disable more than one option at once (ie, WWDT_WDMOD_WDRESET |
N * WWDT_WDMOD_WDTOF).
N */
NSTATIC INLINE void Chip_WWDT_UnsetOption(LPC_WWDT_T *pWWDT, uint32_t options)
Xstatic __inline void Chip_WWDT_UnsetOption(LPC_WWDT_T *pWWDT, uint32_t options)
N{
N	pWWDT->MOD &= (~options) & WWDT_WDMOD_BITMASK;
X	pWWDT->MOD &= (~options) & ((uint32_t) 0x1F);
N}
N
N/**
N * @brief	Enable WWDT activity
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N */
NSTATIC INLINE void Chip_WWDT_Start(LPC_WWDT_T *pWWDT)
Xstatic __inline void Chip_WWDT_Start(LPC_WWDT_T *pWWDT)
N{
N	Chip_WWDT_SetOption(pWWDT, WWDT_WDMOD_WDEN);
X	Chip_WWDT_SetOption(pWWDT, ((uint32_t) (1 << 0)));
N	Chip_WWDT_Feed(pWWDT);
N}
N
N/**
N * @brief	Read WWDT status flag
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	Watchdog status, an Or'ed value of WWDT_WDMOD_*
N */
NSTATIC INLINE uint32_t Chip_WWDT_GetStatus(LPC_WWDT_T *pWWDT)
Xstatic __inline uint32_t Chip_WWDT_GetStatus(LPC_WWDT_T *pWWDT)
N{
N	return pWWDT->MOD;
N}
N
N/**
N * @brief	Clear WWDT interrupt status flags
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	status	: Or'ed value of status flag(s) that you want to clear, should be:
N *              - WWDT_WDMOD_WDTOF: Clear watchdog timeout flag
N *              - WWDT_WDMOD_WDINT: Clear watchdog warning flag
N * @return	None
N */
Nvoid Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status);
N
N/**
N * @brief	Get the current value of WDT
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	current value of WDT
N */
NSTATIC INLINE uint32_t Chip_WWDT_GetCurrentCount(LPC_WWDT_T *pWWDT)
Xstatic __inline uint32_t Chip_WWDT_GetCurrentCount(LPC_WWDT_T *pWWDT)
N{
N	return pWWDT->TV;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __WWDT_8XX_H_ */
L 190 ".\lpc_chip_82x\inc\chip.h" 2
N#include "sct_8xx.h"
L 1 ".\lpc_chip_82x\inc\sct_8xx.h" 1
N/*
N * @brief LPC8xx State Configurable Timer (SCT) Chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SCT_8XX_H_
N#define __SCT_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SCT_8XX CHIP: LPC8xx State Configurable Timer driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/*
N * @brief SCT Module configuration
N */
N#define CONFIG_SCT_nEV   (8)			/*!< Number of events */
N#define CONFIG_SCT_nRG   (8)			/*!< Number of match/compare registers */
N#define CONFIG_SCT_nOU   (6)			/*!< Number of outputs */
N
N/**
N * @brief State Configurable Timer register block structure
N */
Ntypedef struct {
N	__IO  uint32_t CONFIG;				/*!< configuration Register (offset (0x000) */
X	volatile  uint32_t CONFIG;				 
N	union {
N		__IO uint32_t CTRL_U;			/*!< control Register */
X		volatile uint32_t CTRL_U;			 
N		struct {
N			__IO uint16_t CTRL_L;		/*!< low control register */
X			volatile uint16_t CTRL_L;		 
N			__IO uint16_t CTRL_H;		/*!< high control register */
X			volatile uint16_t CTRL_H;		 
N		};
N	};
N	union {
N		__IO uint32_t LIMIT_U;			/*!< limit Register */
X		volatile uint32_t LIMIT_U;			 
N		struct {
N			__IO uint16_t LIMIT_L;		/*!< limit register for counter L */
X			volatile uint16_t LIMIT_L;		 
N			__IO uint16_t LIMIT_H;		/*!< limit register for counter H */
X			volatile uint16_t LIMIT_H;		 
N		};
N	};
N
N	union {
N		__IO uint32_t HALT_U;			/*!< halt Register */
X		volatile uint32_t HALT_U;			 
N		struct {
N			__IO uint16_t HALT_L;		/*!< halt register for counter L */
X			volatile uint16_t HALT_L;		 
N			__IO uint16_t HALT_H;		/*!< halt register for counter H */
X			volatile uint16_t HALT_H;		 
N		};
N	};
N
N	union {
N		__IO uint32_t STOP_U;			/*!< stop Register */
X		volatile uint32_t STOP_U;			 
N		struct {
N			__IO uint16_t STOP_L;		/*!< stop register for counter L */
X			volatile uint16_t STOP_L;		 
N			__IO uint16_t STOP_H;		/*!< stop register for counter H */
X			volatile uint16_t STOP_H;		 
N		};
N
N	};
N
N	union {
N		__IO uint32_t START_U;			/*!< start Register */
X		volatile uint32_t START_U;			 
N		struct {
N			__IO uint16_t START_L;		/*!< start register for counter L */
X			volatile uint16_t START_L;		 
N			__IO uint16_t START_H;		/*!< start register for counter H */
X			volatile uint16_t START_H;		 
N		};
N
N	};
N
N	uint32_t RESERVED1[10];				/*!< 0x018 - 0x03C reserved */
N
N	union {
N		__IO uint32_t COUNT_U;			/*!< counter register (offset 0x040)*/
X		volatile uint32_t COUNT_U;			 
N		struct {
N			__IO uint16_t COUNT_L;		/*!< counter register for counter L */
X			volatile uint16_t COUNT_L;		 
N			__IO uint16_t COUNT_H;		/*!< counter register for counter H */
X			volatile uint16_t COUNT_H;		 
N		};
N	};
N
N	union {
N		__IO uint32_t STATE_U;			/*!< State register */
X		volatile uint32_t STATE_U;			 
N		struct {
N			__IO uint16_t STATE_L;		/*!< state register for counter L */
X			volatile uint16_t STATE_L;		 
N			__IO uint16_t STATE_H;		/*!< state register for counter H */
X			volatile uint16_t STATE_H;		 
N		};
N	};
N
N	__I  uint32_t INPUT;				/*!< input register */
X	volatile const  uint32_t INPUT;				 
N	union {
N		__IO uint32_t REGMODE_U;		/*!< RegMode register */
X		volatile uint32_t REGMODE_U;		 
N		struct {
N			__IO uint16_t REGMODE_L;	/*!< match - capture registers mode register L */
X			volatile uint16_t REGMODE_L;	 
N			__IO uint16_t REGMODE_H;	/*!< match - capture registers mode register H */
X			volatile uint16_t REGMODE_H;	 
N		};
N	};
N
N	__IO uint32_t OUTPUT;				/*!< output register */
X	volatile uint32_t OUTPUT;				 
N	__IO uint32_t OUTPUTDIRCTRL;		/*!< output counter direction Control Register */
X	volatile uint32_t OUTPUTDIRCTRL;		 
N	__IO uint32_t RES;					/*!< conflict resolution register */
X	volatile uint32_t RES;					 
N	__IO uint32_t DMAREQ0;				/*!< DMA0 Request Register */
X	volatile uint32_t DMAREQ0;				 
N	__IO uint32_t DMAREQ1;				/*!< DMA1 Request Register */
X	volatile uint32_t DMAREQ1;				 
N
N	uint32_t RESERVED2[35];				/*!< 0x064 - 0x0EC reserved */
N
N	__IO uint32_t EVEN;					/*!< event enable register (offset 0x0F0)*/
X	volatile uint32_t EVEN;					 
N	__IO uint32_t EVFLAG;				/*!< event flag register */
X	volatile uint32_t EVFLAG;				 
N	__IO uint32_t CONEN;				/*!< conflict enable register */
X	volatile uint32_t CONEN;				 
N	__IO uint32_t CONFLAG;				/*!< conflict flag register */
X	volatile uint32_t CONFLAG;				 
N	union {
N		__IO union {					/*!< ... Match / Capture value */
X		volatile union {					 
N			uint32_t U;					/*!<  MATCH[i].U  Unified 32-bit register */
N			struct {
N				uint16_t L;				/*!<  MATCH[i].L  Access to L value */
N				uint16_t H;				/*!<  MATCH[i].H  Access to H value */
N			};
N		} MATCH[CONFIG_SCT_nRG];
X		} MATCH[(8)];
N
N		__I union {
X		volatile const union {
N			uint32_t U;					/*!<  CAP[i].U  Unified 32-bit register */
N			struct {
N				uint16_t L;				/*!<  CAP[i].L  Access to L value */
N				uint16_t H;				/*!<  CAP[i].H  Access to H value */
N			};
N		} CAP[CONFIG_SCT_nRG];
X		} CAP[(8)];
N	};
N
N	uint32_t RESERVED3[56];				/*!< 0x120 - 0x1FC reserved */
N
N	union {
N		__IO union {					/*!< ...Match Reload / Capture Control value (offset 0x200) */
X		volatile union {					 
N			uint32_t U;					/*!<  MATCHREL[i].U  Unified 32-bit register */
N			struct {
N				uint16_t L;				/*!<  MATCHREL[i].L  Access to L value */
N				uint16_t H;				/*!<  MATCHREL[i].H  Access to H value */
N			};
N		} MATCHREL[CONFIG_SCT_nRG];
X		} MATCHREL[(8)];
N
N		__IO union {
X		volatile union {
N			uint32_t U;					/*!<  CAPCTRL[i].U  Unified 32-bit register */
N			struct {
N				uint16_t L;				/*!<  CAPCTRL[i].L  Access to L value */
N				uint16_t H;				/*!<  CAPCTRL[i].H  Access to H value */
N			};
N		} CAPCTRL[CONFIG_SCT_nRG];
X		} CAPCTRL[(8)];
N	};
N
N	uint32_t RESERVED4[56];				/*!< 0x220 - 0x2FC reserved */
N
N	__IO struct {						/*!< EV[i].STATE / EV[i].CTRL (offset 0x300) */
X	volatile struct {						 
N		uint32_t STATE;					/*!< Event State Register */
N		uint32_t CTRL;					/*!< Event Control Register */
N	} EV[CONFIG_SCT_nEV];
X	} EV[(8)];
N
N	uint32_t RESERVED5[112];			/*!< 0x340 - 0x4FC reserved */
N
N	__IO struct {						/*!< OUT[i].SET / OUT[i].CLR  (offset 0x500) */
X	volatile struct {						 
N		uint32_t SET;					/*!< Output n Set Register */
N		uint32_t CLR;					/*!< Output n Clear Register */
N	} OUT[CONFIG_SCT_nOU];
X	} OUT[(6)];
N
N} LPC_SCT_T;
N
N/* Reserved bits masks for registers */
N#define SCT_CONFIG_RESERVED             0xfff80000
N#define SCT_CTRL_RESERVED               ((7<<13)|(7u<<29))
N#define SCT_LIMIT_RESERVED              (~(0x3f|(0x3f<<16))
N#define SCT_HALT_RESERVED               (~(0x3f|(0x3f<<16))
N#define SCT_STOP_RESERVED               (~(0x3f|(0x3f<<16))
N#define SCT_START_RESERVED              (~(0x3f|(0x3f<<16))
N#define SCT_STATE_RESERVED              (~(0x1f|(0x1f<<16))
N#define SCT_INPUT_RESERVED              (~(0xf|(0xf<<16))
N#define SCT_REGMODE_RESERVED            (~(0x1f|(0x1f<<16))
N#define SCT_OUTPUT_RESERVED             (~0xf)
N#define SCT_OUTPUTDIRCTRL_RESERVED      (~0xff)
N#define SCT_RES_RESERVED                (~0xff)
N#define SCT_EVEN_RESERVED               (~0x3f)
N#define SCT_EVFLAG_RESERVED             (~0x3f)
N#define SCT_CONEN_RESERVED              (~0xf)
N#define SCT_CONFLAG_RESERVED            (~(0xf|(3u<<30)))
N#define SCT_CAPCTRL_RESERVED            (~(0x3f|(0x3f<<16)))
N#define SCT_EVn_STATE_RESERVED          (~3)
N#define SCT_EVn_CTRL_RESERVED           (0xff800000)
N#define SCT_OUTn_SET_RESERVED           (~0x3f)
N#define SCT_OUTn_CLR_RESERVED           (~0x3f)
N
N/*
N * @brief Macro defines for SCT configuration register
N */
N#define SCT_CONFIG_16BIT_COUNTER        0x00000000				/*!< Operate as 2 16-bit counters */
N#define SCT_CONFIG_32BIT_COUNTER        0x00000001				/*!< Operate as 1 32-bit counter */
N
N#define SCT_CONFIG_CLKMODE_BUSCLK       (0x0 << 1)				/*!< Bus clock */
N#define SCT_CONFIG_CLKMODE_SCTCLK       (0x1 << 1)				/*!< SCT clock */
N#define SCT_CONFIG_CLKMODE_INCLK        (0x2 << 1)				/*!< Input clock selected in CLKSEL field */
N#define SCT_CONFIG_CLKMODE_INEDGECLK    (0x3 << 1)				/*!< Input clock edge selected in CLKSEL field */
N
N#define SCT_CONFIG_NORELOAD_U           (0x1 << 7)				/*!< Prevent match register reload */
N#define SCT_CONFIG_NORELOAD_L           (0x1 << 7)				/*!< Prevent lower match register reload */
N#define SCT_CONFIG_NORELOAD_H           (0x1 << 8)				/*!< Prevent upper match register reload */
N
N#define SCT_CONFIG_AUTOLIMIT_U          (0x1 << 17)				/*!< Limits counter(unified) based on MATCH0 */
N#define SCT_CONFIG_AUTOLIMIT_L          (0x1 << 17)				/*!< Limits counter(L) based on MATCH0 */
N#define SCT_CONFIG_AUTOLIMIT_H          (0x1 << 18)				/*!< Limits counter(L) based on MATCH0 */
N
N/*
N * @brief Macro defines for SCT control register
N */
N#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0				/*!< Direction for low or unified counter */
N#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
N
N#define SCT_CTRL_STOP_L                 (1 << 1)				/*!< Stop low counter */
N#define SCT_CTRL_HALT_L                 (1 << 2)				/*!< Halt low counter */
N#define SCT_CTRL_CLRCTR_L               (1 << 3)				/*!< Clear low or unified counter */
N#define SCT_CTRL_BIDIR_L(x)             (((x) & 0x01) << 4)		/*!< Bidirectional bit */
N#define SCT_CTRL_PRE_L(x)               (((x) & 0xFF) << 5)		/*!< Prescale clock for low or unified counter */
N
N#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0				/*!< Direction for high counter */
N#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
N#define SCT_CTRL_STOP_H                 (1 << 17)				/*!< Stop high counter */
N#define SCT_CTRL_HALT_H                 (1 << 18)				/*!< Halt high counter */
N#define SCT_CTRL_CLRCTR_H               (1 << 19)				/*!< Clear high counter */
N#define SCT_CTRL_BIDIR_H(x)             (((x) & 0x01) << 20)
N#define SCT_CTRL_PRE_H(x)               (((x) & 0xFF) << 21)	/*!< Prescale clock for high counter */
N
N/*
N * @brief Macro defines for SCT Conflict resolution register
N */
N#define SCT_RES_NOCHANGE                (0)
N#define SCT_RES_SET_OUTPUT              (1)
N#define SCT_RES_CLEAR_OUTPUT            (2)
N#define SCT_RES_TOGGLE_OUTPUT           (3)
N
N/**
N * SCT Match register values enum
N */
Ntypedef enum CHIP_SCT_MATCH_REG {
N	SCT_MATCH_0 = 0,	/*!< SCT Match register 0 */
N	SCT_MATCH_1 = 1,	/*!< SCT Match register 1 */
N	SCT_MATCH_2 = 2,	/*!< SCT Match register 2 */
N	SCT_MATCH_3 = 3,	/*!< SCT Match register 3 */
N	SCT_MATCH_4 = 4		/*!< SCT Match register 4 */
N} CHIP_SCT_MATCH_REG_T;
N
N/**
N * SCT Event values enum
N */
Ntypedef enum CHIP_SCT_EVENT {
N	SCT_EVT_0  = (1 << 0),	/*!< Event 0 */
N	SCT_EVT_1  = (1 << 1),	/*!< Event 1 */
N	SCT_EVT_2  = (1 << 2),	/*!< Event 2 */
N	SCT_EVT_3  = (1 << 3),	/*!< Event 3 */
N	SCT_EVT_4  = (1 << 4)	/*!< Event 4 */
N} CHIP_SCT_EVENT_T;
N
N/**
N * @brief	Configures the State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	value	: The 32-bit CONFIG register value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_Config(LPC_SCT_T *pSCT, uint32_t value)
Xstatic __inline void Chip_SCT_Config(LPC_SCT_T *pSCT, uint32_t value)
N{
N	pSCT->CONFIG = value;
N}
N
N/**
N * @brief	Set or Clear the Control register
N * @param	pSCT			: Pointer to SCT register block
N * @param	value			: SCT Control register value
N * @param	ena             : ENABLE - To set the fields specified by value
N *                          : DISABLE - To clear the field specified by value
N * @return	Nothing
N * Set or clear the control register bits as specified by the \a value
N * parameter. If \a ena is set to ENABLE, the mentioned register fields
N * will be set. If \a ena is set to DISABLE, the mentioned register
N * fields will be cleared
N */
Nvoid Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena);
N
N/**
N * @brief	Set the conflict resolution
N * @param	pSCT			: Pointer to SCT register block
N * @param	outnum			: Output number
N * @param	value           : Output value
N *                          - SCT_RES_NOCHANGE		:No change
N *					        - SCT_RES_SET_OUTPUT	:Set output
N *					        - SCT_RES_CLEAR_OUTPUT	:Clear output
N *					        - SCT_RES_TOGGLE_OUTPUT :Toggle output
N *                          : SCT_RES_NOCHANGE
N *                          : DISABLE - To clear the field specified by value
N * @return	Nothing
N * Set conflict resolution for the output \a outnum
N */
Nvoid Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value);
N
N/**
N * @brief	Set unified count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	count	: The 32-bit count value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_SetCount(LPC_SCT_T *pSCT, uint32_t count)
Xstatic __inline void Chip_SCT_SetCount(LPC_SCT_T *pSCT, uint32_t count)
N{
N	pSCT->COUNT_U = count;
N}
N
N/**
N * @brief	Set lower count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	count	: The 16-bit count value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_SetCountL(LPC_SCT_T *pSCT, uint16_t count)
Xstatic __inline void Chip_SCT_SetCountL(LPC_SCT_T *pSCT, uint16_t count)
N{
N	pSCT->COUNT_L = count;
N}
N
N/**
N * @brief	Set higher count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	count	: The 16-bit count value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_SetCountH(LPC_SCT_T *pSCT, uint16_t count)
Xstatic __inline void Chip_SCT_SetCountH(LPC_SCT_T *pSCT, uint16_t count)
N{
N	pSCT->COUNT_H = count;
N}
N
N/**
N * @brief	Set unified match count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	n		: Match register value
N * @param	value	: The 32-bit match count value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_SetMatchCount(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
Xstatic __inline void Chip_SCT_SetMatchCount(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
N{
N	pSCT->MATCH[n].U = value;
N}
N
N/**
N * @brief	Set unified match reload count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	n		: Match register value
N * @param	value	: The 32-bit match count reload value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_SetMatchReload(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
Xstatic __inline void Chip_SCT_SetMatchReload(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value)
N{
N	pSCT->MATCHREL[n].U = value;
N}
N
N/**
N * @brief	Enable the interrupt for the specified event in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	evt		: Event value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
Xstatic __inline void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
N{
N	pSCT->EVEN = evt | (pSCT->EVEN & ~SCT_EVEN_RESERVED);
X	pSCT->EVEN = evt | (pSCT->EVEN & ~(~0x3f));
N}
N
N/**
N * @brief	Disable the interrupt for the specified event in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	evt		: Event value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_DisableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
Xstatic __inline void Chip_SCT_DisableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
N{
N	pSCT->EVEN &= ~(evt | SCT_EVEN_RESERVED);
X	pSCT->EVEN &= ~(evt | (~0x3f));
N}
N
N/**
N * @brief	Clear the specified event flag in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	evt		: Event value
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
Xstatic __inline void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
N{
N	pSCT->EVFLAG = evt | (pSCT->EVFLAG & ~SCT_EVFLAG_RESERVED);
X	pSCT->EVFLAG = evt | (pSCT->EVFLAG & ~(~0x3f));
N}
N
N/**
N * @brief	Set control register in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	value	: Value (ORed value of SCT_CTRL_* bits)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_SetControl(LPC_SCT_T *pSCT, uint32_t value)
Xstatic __inline void Chip_SCT_SetControl(LPC_SCT_T *pSCT, uint32_t value)
N{
N	pSCT->CTRL_U = value | (pSCT->CTRL_U & ~SCT_CTRL_RESERVED);
X	pSCT->CTRL_U = value | (pSCT->CTRL_U & ~((7<<13)|(7u<<29)));
N}
N
N/**
N * @brief	Clear control register in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	value	: Value (ORed value of SCT_CTRL_* bits)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SCT_ClearControl(LPC_SCT_T *pSCT, uint32_t value)
Xstatic __inline void Chip_SCT_ClearControl(LPC_SCT_T *pSCT, uint32_t value)
N{
N	pSCT->CTRL_U &= ~(value | SCT_CTRL_RESERVED);
X	pSCT->CTRL_U &= ~(value | ((7<<13)|(7u<<29)));
N}
N
N/**
N * @brief	Initializes the State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_SCT_Init(LPC_SCT_T *pSCT);
N
N/**
N * @brief	Deinitializes the State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_SCT_DeInit(LPC_SCT_T *pSCT);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
S
N#endif
N
N#endif /* __SCT_8XX_H_ */
L 191 ".\lpc_chip_82x\inc\chip.h" 2
N#include "sct_pwm_8xx.h"
L 1 ".\lpc_chip_82x\inc\sct_pwm_8xx.h" 1
N/*
N * @brief LPC8xx State Configurable Timer (SCT/PWM) Chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SCT_PWM_8XX_H_
N#define __SCT_PWM_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SCT_PWM_8XX CHIP: LPC15XX State Configurable Timer PWM driver
N *
N * For more information on how to use the driver please visit the FAQ page at
N * <a href="http://www.lpcware.com/content/faq/how-use-sct-standard-pwm-using-lpcopen">
N * www.lpcware.com</a>
N *
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief	Get number of ticks per PWM cycle
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	Number ot ticks that will be counted per cycle
N * @note	Return value of this function will be vaild only
N *          after calling Chip_SCTPWM_SetRate()
N */
NSTATIC INLINE uint32_t Chip_SCTPWM_GetTicksPerCycle(LPC_SCT_T *pSCT)
Xstatic __inline uint32_t Chip_SCTPWM_GetTicksPerCycle(LPC_SCT_T *pSCT)
N{
N	return pSCT->MATCHREL[0].U;
N}
N
N/**
N * @brief	Converts a percentage to ticks
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	percent	: Percentage to convert (0 - 100)
N * @return	Number ot ticks corresponding to given percentage
N * @note	Do not use this function when using very low
N *          pwm rate (like 100Hz or less), on a chip that has
N *          very high frequency as the calculation might
N *          cause integer overflow
N */
NSTATIC INLINE uint32_t Chip_SCTPWM_PercentageToTicks(LPC_SCT_T *pSCT, uint8_t percent)
Xstatic __inline uint32_t Chip_SCTPWM_PercentageToTicks(LPC_SCT_T *pSCT, uint8_t percent)
N{
N	return (Chip_SCTPWM_GetTicksPerCycle(pSCT) * percent) / 100;
N}
N
N/**
N * @brief	Get number of ticks on per PWM cycle
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	index	: Index of the PWM 1 to N (see notes)
N * @return	Number ot ticks for which the output will be ON per cycle
N * @note	@a index will be 1 to N where N is the "Number of
N *          match registers available in the SCT - 1" or
N *          "Number of OUTPUT pins available in the SCT" whichever
N *          is minimum.
N */
NSTATIC INLINE uint32_t Chip_SCTPWM_GetDutyCycle(LPC_SCT_T *pSCT, uint8_t index)
Xstatic __inline uint32_t Chip_SCTPWM_GetDutyCycle(LPC_SCT_T *pSCT, uint8_t index)
N{
N	return pSCT->MATCHREL[index].U;
N}
N
N/**
N * @brief	Get number of ticks on per PWM cycle
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	index	: Index of the PWM 1 to N (see notes)
N * @param	ticks	: Number of ticks the output should say ON
N * @return	None
N * @note	@a index will be 1 to N where N is the "Number of
N *          match registers available in the SCT - 1" or
N *          "Number of OUTPUT pins available in the SCT" whichever
N *          is minimum. The new duty cycle will be effective only
N *          after completion of current PWM cycle.
N */
NSTATIC INLINE void Chip_SCTPWM_SetDutyCycle(LPC_SCT_T *pSCT, uint8_t index, uint32_t ticks)
Xstatic __inline void Chip_SCTPWM_SetDutyCycle(LPC_SCT_T *pSCT, uint8_t index, uint32_t ticks)
N{
N	Chip_SCT_SetMatchReload(pSCT, (CHIP_SCT_MATCH_REG_T)index, ticks);
N}
N
N/**
N * @brief	Initialize the SCT/PWM clock and reset
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	None
N */
NSTATIC INLINE void Chip_SCTPWM_Init(LPC_SCT_T *pSCT)
Xstatic __inline void Chip_SCTPWM_Init(LPC_SCT_T *pSCT)
N{
N	Chip_SCT_Init(pSCT);
N}
N
N/**
N * @brief	Start the SCT PWM
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	None
N * @note	This function must be called after all the
N * 			configuration is completed. Do not call Chip_SCTPWM_SetRate()
N * 			or Chip_SCTPWM_SetOutPin() after the SCT/PWM is started. Use
N * 			Chip_SCTPWM_Stop() to stop the SCT/PWM before reconfiguring,
N * 			Chip_SCTPWM_SetDutyCycle() can be called when the SCT/PWM is
N * 			running to change the DutyCycle.
N */
NSTATIC INLINE void Chip_SCTPWM_Start(LPC_SCT_T *pSCT)
Xstatic __inline void Chip_SCTPWM_Start(LPC_SCT_T *pSCT)
N{
N	Chip_SCT_ClearControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
X	Chip_SCT_ClearControl(pSCT, (1 << 2) | (1 << 18));
N}
N
N/**
N * @brief	Stop the SCT PWM
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	None
N */
NSTATIC INLINE void Chip_SCTPWM_Stop(LPC_SCT_T *pSCT)
Xstatic __inline void Chip_SCTPWM_Stop(LPC_SCT_T *pSCT)
N{
N	/* Stop SCT */
N	Chip_SCT_SetControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
X	Chip_SCT_SetControl(pSCT, (1 << 2) | (1 << 18));
N
N	/* Clear the counter */
N	Chip_SCT_SetControl(pSCT, SCT_CTRL_CLRCTR_L | SCT_CTRL_CLRCTR_H);
X	Chip_SCT_SetControl(pSCT, (1 << 3) | (1 << 19));
N}
N
N/**
N * @brief	Sets the frequency of the generated PWM wave
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	freq	: Frequency in Hz
N * @return	None
N */
Nvoid Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq);
N
N/**
N * @brief	Setup the OUTPUT pin and associate it with an index
N * @param	pSCT	: The base of the SCT peripheral on the chip
N * @param	index	: Index of PWM 1 to N (see notes)
N * @param	pin		: COUT pin to be associated with the index
N * @return	None
N * @note	@a index will be 1 to N where N is the "Number of
N *          match registers available in the SCT - 1" or
N *          "Number of OUTPUT pins available in the SCT" whichever
N *          is minimum.
N */
Nvoid Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
S
N#endif
N
N#endif /* __SCT_PWM_8XX_H_ */
L 192 ".\lpc_chip_82x\inc\chip.h" 2
N#include "spi_8xx.h"
L 1 ".\lpc_chip_82x\inc\spi_8xx.h" 1
N/*
N * @brief LPC8xx SPI driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SPI_8XX_H_
N#define __SPI_8XX_H_
N
N#include "spi_common_8xx.h"
L 1 ".\lpc_chip_82x\inc\spi_common_8xx.h" 1
N/*
N * @brief LPC8XX SPI common functions and definitions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SPI_COMMON_8XX_H_
N#define __SPI_COMMON_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SPI_COMMON_8XX CHIP: LPC8XX SPI common functions and definitions
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N/**
N * @brief SPI register block structure
N */
Ntypedef struct {					/*!< SPI Structure */
N	__IO uint32_t  CFG;				/*!< SPI Configuration register */
X	volatile uint32_t  CFG;				 
N	__IO uint32_t  DLY;				/*!< SPI Delay register */
X	volatile uint32_t  DLY;				 
N	__IO uint32_t  STAT;			/*!< SPI Status register */
X	volatile uint32_t  STAT;			 
N	__IO uint32_t  INTENSET;		/*!< SPI Interrupt Enable Set register */
X	volatile uint32_t  INTENSET;		 
N	__O  uint32_t  INTENCLR;		/*!< SPI Interrupt Enable Clear register */
X	volatile  uint32_t  INTENCLR;		 
N	__I  uint32_t  RXDAT;			/*!< SPI Receive Data register */
X	volatile const  uint32_t  RXDAT;			 
N	__IO uint32_t  TXDATCTL;		/*!< SPI Transmit Data with Control register */
X	volatile uint32_t  TXDATCTL;		 
N	__IO uint32_t  TXDAT;			/*!< SPI Transmit Data register */
X	volatile uint32_t  TXDAT;			 
N	__IO uint32_t  TXCTRL;			/*!< SPI Transmit Control register */
X	volatile uint32_t  TXCTRL;			 
N	__IO uint32_t  DIV;				/*!< SPI clock Divider register */
X	volatile uint32_t  DIV;				 
N	__I  uint32_t  INTSTAT;			/*!< SPI Interrupt Status register */
X	volatile const  uint32_t  INTSTAT;			 
N} LPC_SPI_T;
N
N/* Reserved bits masks for registers */
N#define SPI_CFG_RESERVED            ((1<<1)|(1<<6)|0xfffffe00)
N#define SPI_DLY_RESERVED            0xffff0000
N#define SPI_STAT_RESERVED           (~0x1ff)
N#define SPI_INTENSET_RESERVED       (~0x3f)
N#define SPI_INTENCLR_RESERVED       (~0x3f)
N#define SPI_RXDAT_RESERVED          ((7<<17)|(0x7ffu<<21))
N#define SPI_TXDATCTL_RESERVED       ((7<<17)|(1<<23)|(0xfu<<28))
N#define SPI_TXDAT_RESERVED          0xffff0000
N#define SPI_TXCTRL_RESERVED         (0xffff|(7<<17)|(1<<23)|(0xfu<<28))
N#define SPI_DIV_RESERVED            0xffff0000
N#define SPI_INTSTAT_RESERVED        (~0x3f)
N
N/**
N * Macro defines for SPI Configuration register
N */
N#define SPI_CFG_BITMASK         (0x1BD)						/** SPI register bit mask */
N#define SPI_CFG_SPI_EN          (1 << 0)					/** SPI Slave Mode Select */
N#define SPI_CFG_SLAVE_EN        (0 << 0)					/** SPI Master Mode Select */
N#define SPI_CFG_MASTER_EN       (1 << 2)					/** SPI MSB First mode enable */
N#define SPI_CFG_MSB_FIRST_EN    (0 << 3)					/** SPI LSB First mode enable */
N#define SPI_CFG_LSB_FIRST_EN    (1 << 3)					/** SPI Clock Phase Select */
N#define SPI_CFG_CPHA_FIRST      (0 << 4)					/** Capture data on the first edge, Change data on the following edge */
N#define SPI_CFG_CPHA_SECOND     (1 << 4)					/** SPI Clock Polarity Select */
N#define SPI_CFG_CPOL_LO         (0 << 5)					/** The rest state of the clock (between frames) is low. */
N#define SPI_CFG_CPOL_HI         (1 << 5)					/** The rest state of the clock (between frames) is high. */
N#define SPI_CFG_LBM_EN          (1 << 7)					/** SPI control 1 loopback mode enable */
N#define SPI_CFG_SPOL_LO         (0 << 8)					/** SPI SSEL0 Polarity Select */
N#define SPI_CFG_SPOL_HI         (1 << 8)					/** SSEL0 is active High */
N#define SPI_CFG_SPOLNUM_HI(n)   (1 << ((n) + 8))			/** SSELN is active High, selects 0 - 3 */
N
N/**
N * Macro defines for SPI Delay register
N */
N#define  SPI_DLY_BITMASK            (0xFFFF)				/** SPI DLY Register Mask */
N#define  SPI_DLY_PRE_DELAY(n)       (((n) & 0x0F) << 0)		/** Time in SPI clocks between SSEL assertion and the beginning of a data frame */
N#define  SPI_DLY_POST_DELAY(n)      (((n) & 0x0F) << 4)		/** Time in SPI clocks between the end of a data frame and SSEL deassertion. */
N#define  SPI_DLY_FRAME_DELAY(n)     (((n) & 0x0F) << 8)		/** Minimum time in SPI clocks between adjacent data frames. */
N#define  SPI_DLY_TRANSFER_DELAY(n)  (((n) & 0x0F) << 12)	/** Minimum time in SPI clocks that the SSEL is deasserted between transfers. */
N
N/**
N * Macro defines for SPI Status register
N */
N#define SPI_STAT_BITMASK            (0x1FF)					/** SPI STAT Register BitMask */
N#define SPI_STAT_RXRDY              (1 << 0)				/** Receiver Ready Flag */
N#define SPI_STAT_TXRDY              (1 << 1)				/** Transmitter Ready Flag */
N#define SPI_STAT_RXOV               (1 << 2)				/** Receiver Overrun interrupt flag */
N#define SPI_STAT_TXUR               (1 << 3)				/** Transmitter Underrun interrupt flag (In Slave Mode only) */
N#define SPI_STAT_SSA                (1 << 4)				/** Slave Select Assert */
N#define SPI_STAT_SSD                (1 << 5)				/** Slave Select Deassert */
N#define SPI_STAT_STALLED            (1 << 6)				/** Stalled status flag */
N#define SPI_STAT_EOT                (1 << 7)				/** End Transfer flag */
N#define SPI_STAT_MSTIDLE            (1 << 8)				/** Idle status flag */
N
N/**
N * Macro defines for SPI Interrupt Enable read and Set register
N */
N#define SPI_INTENSET_BITMASK        (0x3F)					/** SPI INTENSET Register BitMask */
N#define SPI_INTENSET_RXDYEN         (1 << 0)				/** Enable Interrupt when receiver data is available */
N#define SPI_INTENSET_TXDYEN         (1 << 1)				/** Enable Interrupt when the transmitter holding register is available. */
N#define SPI_INTENSET_RXOVEN         (1 << 2)				/**  Enable Interrupt when a receiver overrun occurs */
N#define SPI_INTENSET_TXUREN         (1 << 3)				/**  Enable Interrupt when a transmitter underrun occurs (In Slave Mode Only)*/
N#define SPI_INTENSET_SSAEN          (1 << 4)				/**  Enable Interrupt when the Slave Select is asserted.*/
N#define SPI_INTENSET_SSDEN          (1 << 5)				/**  Enable Interrupt when the Slave Select is deasserted..*/
N
N/**
N * Macro defines for SPI Interrupt Enable Clear register
N */
N#define SPI_INTENCLR_BITMASK        (0x3F)					/** SPI INTENCLR Register BitMask */
N#define SPI_INTENCLR_RXDYEN         (1 << 0)				/** Disable Interrupt when receiver data is available */
N#define SPI_INTENCLR_TXDYEN         (1 << 1)				/** Disable Interrupt when the transmitter holding register is available. */
N#define SPI_INTENCLR_RXOVEN         (1 << 2)				/** Disable Interrupt when a receiver overrun occurs */
N#define SPI_INTENCLR_TXUREN         (1 << 3)				/** Disable Interrupt when a transmitter underrun occurs (In Slave Mode Only) */
N#define SPI_INTENCLR_SSAEN          (1 << 4)				/** Disable Interrupt when the Slave Select is asserted. */
N#define SPI_INTENCLR_SSDEN          (1 << 5)				/** Disable Interrupt when the Slave Select is deasserted.. */
N
N/**
N * Macro defines for SPI Receiver Data register
N */
N#define SPI_RXDAT_BITMASK           (0x1FFFFF)				/** SPI RXDAT Register BitMask */
N#define SPI_RXDAT_DATA(n)           ((n) & 0xFFFF)			/** Receiver Data  */
N#define SPI_RXDAT_RXSSELN_ACTIVE    (0 << 16)				/** The state of SSEL pin is active */
N#define SPI_RXDAT_RXSSELN_INACTIVE  ((1 << 16)				/** The state of SSEL pin is inactive */
N#define SPI_RXDAT_RXSSELNUM_INACTIVE(n) (1 << ((n) + 16))	/** The state of SSELN pin is inactive */
N#define SPI_RXDAT_SOT               (1 << 20)				/** Start of Transfer flag  */
N
N/**
N * Macro defines for SPI Transmitter Data and Control register
N */
N#define SPI_TXDATCTL_BITMASK        (0xF71FFFF)				/** SPI TXDATCTL Register BitMask */
N#define SPI_TXDATCTL_DATA(n)        ((n) & 0xFFFF)			/** SPI Transmit Data */
N#define SPI_TXDATCTL_CTRLMASK       (0xF710000)				/** SPI TXDATCTL Register BitMask for control bits only */
N#define SPI_TXDATCTL_ASSERT_SSEL    (0 << 16)				/** Assert SSEL0 pin */
N#define SPI_TXDATCTL_DEASSERT_SSEL  (1 << 16)				/** Deassert SSEL0 pin */
N#define SPI_TXDATCTL_DEASSERTNUM_SSEL(n)    (1 << ((n) + 16))	/** Deassert SSELN pin */
N#define SPI_TXDATCTL_DEASSERT_ALL   (0xF << 16)				/** Deassert all SSEL pins */
N#define SPI_TXDATCTL_EOT            (1 << 20)				/** End of Transfer flag (TRANSFER_DELAY is applied after sending the current frame) */
N#define SPI_TXDATCTL_EOF            (1 << 21)				/** End of Frame flag (FRAME_DELAY is applied after sending the current part) */
N#define SPI_TXDATCTL_RXIGNORE       (1 << 22)				/** Receive Ignore Flag */
N#define SPI_TXDATCTL_FLEN(n)        (((n) & 0x0F) << 24)	/** Frame length - 1 */
N
N/**
N * Macro defines for SPI Transmitter Data Register
N */
N#define SPI_TXDAT_DATA(n)           ((n) & 0xFFFF)			/** SPI Transmit Data */
N
N/**
N * Macro defines for SPI Transmitter Control register
N */
N#define SPI_TXCTL_BITMASK           (0xF7F0000)				/** SPI TXDATCTL Register BitMask */
N#define SPI_TXCTL_ASSERT_SSEL       (0 << 16)				/** Assert SSEL0 pin */
N#define SPI_TXCTL_DEASSERT_SSEL     (1 << 16)				/** Deassert SSEL0 pin */
N#define SPI_TXCTL_DEASSERTNUM_SSEL(n)   (1 << ((n) + 16))	/** Deassert SSELN pin */
N#define SPI_TXDATCTL_DEASSERT_ALL   (0xF << 16)				/** Deassert all SSEL pins */
N#define SPI_TXCTL_EOT               (1 << 20)				/** End of Transfer flag (TRANSFER_DELAY is applied after sending the current frame) */
N#define SPI_TXCTL_EOF               (1 << 21)				/** End of Frame flag (FRAME_DELAY is applied after sending the current part) */
N#define SPI_TXCTL_RXIGNORE          (1 << 22)				/** Receive Ignore Flag */
N#define SPI_TXCTL_FLEN(n)           ((((n) - 1) & 0x0F) << 24)	/** Frame length, 0 - 16 */
N#define SPI_TXCTL_FLENMASK          (0xF << 24)				/** Frame length mask */
N
N/**
N * Macro defines for SPI Divider register
N */
N#define SPI_DIV_VAL(n)          ((n) & 0xFFFF)				/** Rate divider value mask (In Master Mode only)*/
N
N/**
N * Macro defines for SPI Interrupt Status register
N */
N#define SPI_INTSTAT_BITMASK         (0x3F)					/** SPI INTSTAT Register Bitmask */
N#define SPI_INTSTAT_RXRDY           (1 << 0)				/** Receiver Ready Flag */
N#define SPI_INTSTAT_TXRDY           (1 << 1)				/** Transmitter Ready Flag */
N#define SPI_INTSTAT_RXOV            (1 << 2)				/** Receiver Overrun interrupt flag */
N#define SPI_INTSTAT_TXUR            (1 << 3)				/** Transmitter Underrun interrupt flag (In Slave Mode only) */
N#define SPI_INTSTAT_SSA             (1 << 4)				/** Slave Select Assert */
N#define SPI_INTSTAT_SSD             (1 << 5)				/** Slave Select Deassert */
N
N/** @brief SPI Clock Mode*/
N#define SPI_CLOCK_CPHA0_CPOL0 (SPI_CFG_CPOL_LO | SPI_CFG_CPHA_FIRST)	/**< CPHA = 0, CPOL = 0 */
N#define SPI_CLOCK_MODE0 SPI_CLOCK_CPHA0_CPOL0							/**< Alias for CPHA = 0, CPOL = 0 */
N#define SPI_CLOCK_CPHA1_CPOL0 SPI_CFG_CPOL_LO | SPI_CFG_CPHA_SECOND		/**< CPHA = 0, CPOL = 1 */
N#define SPI_CLOCK_MODE1 SPI_CLOCK_CPHA1_CPOL0							/**< Alias for CPHA = 0, CPOL = 1 */
N#define SPI_CLOCK_CPHA0_CPOL1 SPI_CFG_CPOL_HI | SPI_CFG_CPHA_FIRST		/**< CPHA = 1, CPOL = 0 */
N#define SPI_CLOCK_MODE2 SPI_CLOCK_CPHA0_CPOL1							/**< Alias for CPHA = 1, CPOL = 0 */
N#define SPI_CLOCK_CPHA1_CPOL1 SPI_CFG_CPOL_HI | SPI_CFG_CPHA_SECOND		/**< CPHA = 1, CPOL = 1 */
N#define SPI_CLOCK_MODE3 SPI_CLOCK_CPHA1_CPOL1							/**< Alias for CPHA = 1, CPOL = 1 */
N
N/**
N * @brief	Set SPI CFG register values
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	bits	: CFG register bits to set, amd OR'ed value of SPI_CFG_* definitions
N * @return	Nothing
N * @note	This function safely sets only the selected bits in the SPI CFG register.
N * It can be used to enable multiple bits at once.
N */
NSTATIC INLINE void Chip_SPI_SetCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
Xstatic __inline void Chip_SPI_SetCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
N{
N	/* Update CFG register with only selected bits disabled */
N	pSPI->CFG = bits | (pSPI->CFG & SPI_CFG_BITMASK);
X	pSPI->CFG = bits | (pSPI->CFG & (0x1BD));
N}
N
N/**
N * @brief	Clear SPI CFG register values
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	bits	: CFG register bits to clear, amd OR'ed value of SPI_CFG_* definitions
N * @return	Nothing
N * @note	This function safely clears only the selected bits in the SPI CFG register.
N * It can be used to disable multiple bits at once.
N */
NSTATIC INLINE void Chip_SPI_ClearCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
Xstatic __inline void Chip_SPI_ClearCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
N{
N	/* Update CFG register with only selected bits disabled */
N	pSPI->CFG = ~bits & (pSPI->CFG & SPI_CFG_BITMASK);
X	pSPI->CFG = ~bits & (pSPI->CFG & (0x1BD));
N}
N
N/**
N * @brief   Initialize the SPI
N * @param	pSPI	: The base SPI peripheral on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_Init(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_Init(LPC_SPI_T *pSPI)
N{
N	/* Enable SPI clock and reset IP */
N	if (pSPI == LPC_SPI1) {
X	if (pSPI == ((LPC_SPI_T *) (0x4005C000UL))) {
N		Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SPI1);
N		Chip_SYSCTL_PeriphReset(RESET_SPI1);
N	} else {
N		Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SPI0);
N		Chip_SYSCTL_PeriphReset(RESET_SPI0);
N	}
N}
N
N/**
N * @brief	Disable SPI peripheral
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_Disable(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_Disable(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_SPI_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 0));
N}
N
N/**
N * @brief	Disable SPI operation
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note	The SPI controller is disabled.
N */
NSTATIC INLINE void Chip_SPI_DeInit(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_DeInit(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_Disable(pSPI);
N	if (pSPI == LPC_SPI1) {
X	if (pSPI == ((LPC_SPI_T *) (0x4005C000UL))) {
N		Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SPI1);
N	} else {
N		Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SPI0);
N	}
N}
N
N/**
N * @brief	Enable SPI peripheral
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_Enable(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_SPI_EN);
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << 0));
N}
N
N/**
N * @brief	Enable SPI master mode
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note SPI slave mode will be disabled with this call. All SPI SSEL
N * lines will also be deasserted.
N */
NSTATIC INLINE void Chip_SPI_EnableMasterMode(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableMasterMode(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_MASTER_EN);
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << 2));
N
N	/* Deassert all chip selects, only in master mode */
N	pSPI->TXCTRL = SPI_TXDATCTL_DEASSERT_ALL;
X	pSPI->TXCTRL = (0xF << 16);
N}
N
N/**
N * @brief	Enable SPI slave mode
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note SPI master mode will be disabled with this call.
N */
NSTATIC INLINE void Chip_SPI_EnableSlaveMode(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableSlaveMode(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_MASTER_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 2));
N}
N
N/**
N * @brief	Enable LSB First transfers
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_EnableLSBFirst(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableLSBFirst(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_LSB_FIRST_EN);
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << 3));
N}
N
N/**
N * @brief	Enable MSB First transfers
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_EnableMSBFirst(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableMSBFirst(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_LSB_FIRST_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 3));
N}
N
N
N/**
N * @brief	Set SPI mode
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	mode	: SPI mode to set the SPI interface to
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SetSPIMode(LPC_SPI_T *pSPI, uint32_t mode)
Xstatic __inline void Chip_SPI_SetSPIMode(LPC_SPI_T *pSPI, uint32_t mode)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, (SPI_CFG_CPOL_HI | SPI_CFG_CPHA_SECOND));
X	Chip_SPI_ClearCFGRegBits(pSPI, ((1 << 5) | (1 << 4)));
N	Chip_SPI_SetCFGRegBits(pSPI, (uint32_t) mode);
N}
N
N/**
N * @brief	Set polarity on the SPI chip select high
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	csNum	: Chip select number, 0 - 3
N * @return	Nothing
N * @note	SPI chip select polarity is active high.
N */
NSTATIC INLINE void Chip_SPI_SetCSPolHigh(LPC_SPI_T *pSPI, uint8_t csNum)
Xstatic __inline void Chip_SPI_SetCSPolHigh(LPC_SPI_T *pSPI, uint8_t csNum)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_SPOLNUM_HI(csNum));
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << ((csNum) + 8)));
N}
N
N/**
N * @brief	Set polarity on the SPI chip select low
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	csNum	: Chip select number, 0 - 3
N * @return	Nothing
N * @note	SPI chip select polarity is active low.
N */
NSTATIC INLINE void Chip_SPI_SetCSPolLow(LPC_SPI_T *pSPI, uint8_t csNum)
Xstatic __inline void Chip_SPI_SetCSPolLow(LPC_SPI_T *pSPI, uint8_t csNum)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_SPOLNUM_HI(csNum));
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << ((csNum) + 8)));
N}
N
N/**
N * @brief	Setup SPI configuration
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	config	: ORed spi configuration flags
N * @return	Nothing
N * @note	Possible values that can be ORed in @a config are
N * SPI_CLOCK_* (example: #SPI_CLOCK_CPHA0_CPOL0) along with
N * SPI_CFG_* (example: #SPI_CFG_SPI_EN).
N */
NSTATIC INLINE void Chip_SPI_ConfigureSPI(LPC_SPI_T *pSPI, uint32_t config)
Xstatic __inline void Chip_SPI_ConfigureSPI(LPC_SPI_T *pSPI, uint32_t config)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_MASTER_EN | SPI_CFG_LSB_FIRST_EN |
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 2) | (1 << 3) |
N			SPI_CFG_CPHA_SECOND | SPI_CFG_CPOL_HI);
X			(1 << 4) | (1 << 5));
N	Chip_SPI_SetCFGRegBits(pSPI, config);
N
N	/* Deassert all chip selects, only in master mode */
N	pSPI->TXCTRL = SPI_TXDATCTL_DEASSERT_ALL;
X	pSPI->TXCTRL = (0xF << 16);
N}
N
N/**
N * @brief	Get the current status of SPI controller
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
N * @note	Mask the return value with a value of type SPI_STAT_* to determine
N * if that status is active.
N */
NSTATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
N{
N	return pSPI->STAT & ~SPI_STAT_RESERVED;
X	return pSPI->STAT & ~(~0x1ff);
N}
N
N/**
N * @brief	Clear SPI status
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_*)
N * @return	Nothing
N * @note	Only SPI_STAT_RXOV, SPI_STAT_TXUR, SPI_STAT_SSA, and
N * SPI_STAT_SSD statuses can be cleared.
N */
NSTATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
Xstatic __inline void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
N{
N	pSPI->STAT = Flag;
N}
N
N/**
N * @brief	Enable a SPI interrupt
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	Flag	: Or'ed value of SPI_INTENSET_* values to enable
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_EnableInts(LPC_SPI_T *pSPI, uint32_t Flag)
Xstatic __inline void Chip_SPI_EnableInts(LPC_SPI_T *pSPI, uint32_t Flag)
N{
N	pSPI->INTENSET = Flag;
N}
N
N/**
N * @brief	Disable a SPI interrupt
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	Flag	: Or'ed value of SPI_INTENCLR_* values to disable
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_DisableInts(LPC_SPI_T *pSPI, uint32_t Flag)
Xstatic __inline void Chip_SPI_DisableInts(LPC_SPI_T *pSPI, uint32_t Flag)
N{
N	pSPI->INTENCLR = Flag;
N}
N
N/**
N * @brief	Return enabled SPI interrupts
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	An Or'ed value of SPI_INTENSET_* values
N * @note	Mask the return value with a SPI_INTENSET_* value to determine
N * if the interrupt is enabled.
N */
NSTATIC INLINE uint32_t Chip_SPI_GetEnabledInts(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetEnabledInts(LPC_SPI_T *pSPI)
N{
N	return pSPI->INTENSET & ~SPI_INTENSET_RESERVED;
X	return pSPI->INTENSET & ~(~0x3f);
N}
N
N/**
N * @brief	Return pending SPI interrupts
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	An Or'ed value of SPI_INTSTAT_* values
N * @note	Mask the return value with a SPI_INTSTAT_* value to determine
N * if the interrupt is pending.
N */
NSTATIC INLINE uint32_t Chip_SPI_GetPendingInts(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetPendingInts(LPC_SPI_T *pSPI)
N{
N	return pSPI->INTSTAT & ~SPI_INTSTAT_RESERVED;
X	return pSPI->INTSTAT & ~(~0x3f);
N}
N
N/**
N * @brief	Flush FIFOs
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_FlushFifos(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_FlushFifos(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_Disable(pSPI);
N	Chip_SPI_Enable(pSPI);
N}
N
N/**
N * @brief	Read raw data from receive FIFO with status bits
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Current value in receive data FIFO plus status bits
N */
NSTATIC INLINE uint32_t Chip_SPI_ReadRawRXFifo(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_ReadRawRXFifo(LPC_SPI_T *pSPI)
N{
N	return pSPI->RXDAT & ~SPI_RXDAT_RESERVED;
X	return pSPI->RXDAT & ~((7<<17)|(0x7ffu<<21));
N}
N
N/**
N * @brief	Read data from receive FIFO masking off status bits
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Current value in receive data FIFO
N * @note	The return value is masked with 0xFFFF to not exceed 16-bits. All
N * other status bits are thrown away. This register should only be read if it
N * has data in it. This function is useful for systems that don't need SPI
N * select (SSEL) monitoring.
N */
NSTATIC INLINE uint32_t Chip_SPI_ReadRXData(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_ReadRXData(LPC_SPI_T *pSPI)
N{
N	return pSPI->RXDAT & 0xFFFF;
N}
N
N/**
N * @brief	Write data to transmit FIFO
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	data	: Data to write
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_WriteTXData(LPC_SPI_T *pSPI, uint16_t data)
Xstatic __inline void Chip_SPI_WriteTXData(LPC_SPI_T *pSPI, uint16_t data)
N{
N	pSPI->TXDAT = (uint32_t) data;
N}
N
N/**
N * @brief	Set SPI TXCTRL register control options
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	bits	: TXCTRL register bits to set, amd OR'ed value of SPI_TXDATCTL_* definitions
N * @return	Nothing
N * @note	This function safely sets only the selected bits in the SPI TXCTRL register.
N * It can be used to enable multiple bits at once.
N */
NSTATIC INLINE void Chip_SPI_SetTXCTRLRegBits(LPC_SPI_T *pSPI, uint32_t bits)
Xstatic __inline void Chip_SPI_SetTXCTRLRegBits(LPC_SPI_T *pSPI, uint32_t bits)
N{
N	pSPI->TXCTRL = bits | (pSPI->TXCTRL & SPI_TXDATCTL_CTRLMASK);
X	pSPI->TXCTRL = bits | (pSPI->TXCTRL & (0xF710000));
N}
N
N/**
N * @brief	Clear SPI TXCTRL register control options
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	bits	: TXCTRL register bits to clear, amd OR'ed value of SPI_TXDATCTL_* definitions
N * @return	Nothing
N * @note	This function safely clears only the selected bits in the SPI TXCTRL register.
N * It can be used to disable multiple bits at once.
N */
NSTATIC INLINE void Chip_SPI_ClearTXCTRLRegBits(LPC_SPI_T *pSPI, uint32_t bits)
Xstatic __inline void Chip_SPI_ClearTXCTRLRegBits(LPC_SPI_T *pSPI, uint32_t bits)
N{
N	pSPI->TXCTRL = ~bits & (pSPI->TXCTRL & SPI_TXDATCTL_CTRLMASK);
X	pSPI->TXCTRL = ~bits & (pSPI->TXCTRL & (0xF710000));
N}
N
N/**
N * @brief	Set TX control options (safe)
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	ctrlBits	: Or'ed control bits to set
N * @return	Nothing
N * @note	Selectable control states include SPI_TXCTL_DEASSERTNUM_SSEL(0/1/2/3),
N * SPI_TXCTL_EOT, SPI_TXCTL_EOF, SPI_TXCTL_RXIGNORE, and SPI_TXCTL_FLEN(bits).
N */
NSTATIC INLINE void Chip_SPI_SetTXCtl(LPC_SPI_T *pSPI, uint32_t ctrlBits)
Xstatic __inline void Chip_SPI_SetTXCtl(LPC_SPI_T *pSPI, uint32_t ctrlBits)
N{
N	Chip_SPI_SetTXCTRLRegBits(pSPI, ctrlBits);
N}
N
N/**
N * @brief	Clear TX control options (safe)
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	ctrlBits	: Or'ed control bits to clear
N * @return	Nothing
N * @note	Selectable control states include SPI_TXCTL_DEASSERTNUM_SSEL(0/1/2/3),
N * SPI_TXCTL_EOT, SPI_TXCTL_EOF, SPI_TXCTL_RXIGNORE, and SPI_TXCTL_FLEN(bits).
N */
NSTATIC INLINE void Chip_SPI_ClearTXCtl(LPC_SPI_T *pSPI, uint32_t ctrlBits)
Xstatic __inline void Chip_SPI_ClearTXCtl(LPC_SPI_T *pSPI, uint32_t ctrlBits)
N{
N	Chip_SPI_ClearTXCTRLRegBits(pSPI, ctrlBits);
N}
N
N/**
N * @brief	Set TX data transfer size in bits
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	ctrlBits	: Number of bits to transmit and receive, must be 1 to 16
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SetXferSize(LPC_SPI_T *pSPI, uint32_t ctrlBits)
Xstatic __inline void Chip_SPI_SetXferSize(LPC_SPI_T *pSPI, uint32_t ctrlBits)
N{
N	Chip_SPI_ClearTXCTRLRegBits(pSPI, SPI_TXCTL_FLENMASK);
X	Chip_SPI_ClearTXCTRLRegBits(pSPI, (0xF << 24));
N	Chip_SPI_SetTXCTRLRegBits(pSPI, SPI_TXCTL_FLEN(ctrlBits));
X	Chip_SPI_SetTXCTRLRegBits(pSPI, ((((ctrlBits) - 1) & 0x0F) << 24));
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SPI_COMMON_8XX_H_ */
L 36 ".\lpc_chip_82x\inc\spi_8xx.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SPI_8XX CHIP: LPC8xx SPI driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/** @brief SPI Mode*/
Ntypedef enum {
N	SPI_MODE_MASTER = SPI_CFG_MASTER_EN,		/* Master Mode */
X	SPI_MODE_MASTER = (1 << 2),		 
N	SPI_MODE_SLAVE = SPI_CFG_SLAVE_EN,			/* Slave Mode */
X	SPI_MODE_SLAVE = (0 << 0),			 
N} SPI_MODE_T;
N
N/** @brief SPI Data Order Mode*/
Ntypedef enum IP_SPI_DATA_ORDER {
N	SPI_DATA_MSB_FIRST = SPI_CFG_MSB_FIRST_EN,			/* Standard Order */
X	SPI_DATA_MSB_FIRST = (0 << 3),			 
N	SPI_DATA_LSB_FIRST = SPI_CFG_LSB_FIRST_EN,			/* Reverse Order */
X	SPI_DATA_LSB_FIRST = (1 << 3),			 
N} SPI_DATA_ORDER_T;
N
N/** @brief SPI SSEL Polarity definition*/
Ntypedef enum IP_SPI_SSEL_POL {
N	SPI_SSEL_ACTIVE_LO = SPI_CFG_SPOL_LO,			/* SSEL is active Low*/
X	SPI_SSEL_ACTIVE_LO = (0 << 8),			 
N	SPI_SSEL_ACTIVE_HI = SPI_CFG_SPOL_HI,			/* SSEL is active  High */
X	SPI_SSEL_ACTIVE_HI = (1 << 8),			 
N} SPI_SSEL_POL_T;
N
N/**
N * @brief SPI Configure Struct
N */
Ntypedef struct {
N	SPI_MODE_T             Mode;			/* Mode Select */
N	uint32_t               ClockMode;		/* CPHA CPOL Select */
N	SPI_DATA_ORDER_T       DataOrder;		/* MSB/LSB First */
N	SPI_SSEL_POL_T         SSELPol;		/* SSEL Polarity Select */
N	uint16_t                ClkDiv;			/* SPI Clock Divider Value */
N} SPI_CONFIG_T;
N
N/**
N * @brief SPI Delay Configure Struct
N */
Ntypedef struct {
N	uint8_t     PreDelay;				/* Pre-delay value in SPI clock time */
N	uint8_t     PostDelay;				/* Post-delay value in SPI clock time */
N	uint8_t     FrameDelay;				/* Delay value between frames of a transfer in SPI clock time */
N	uint8_t     TransferDelay;			/* Delay value between transfers in SPI clock time */
N} SPI_DELAY_CONFIG_T;
N
N/**
N * @brief SPI data setup structure
N */
Ntypedef struct {
N	uint16_t  *pTx;	/**< Pointer to data buffer*/
N	uint32_t  TxCnt;/* Transmit Counter */
N	uint16_t  *pRx;	/**< Pointer to data buffer*/
N	uint32_t  RxCnt;/* Transmit Counter */
N	uint32_t  Length;	/**< Data Length*/
N	uint16_t  DataSize;	/** < The size of a frame (1-16)*/
N} SPI_DATA_SETUP_T;
N
N/**
N * @brief	Calculate the divider for SPI clock
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	bitRate	: Expected clock rate
N * @return	Divider value
N */
Nuint32_t Chip_SPI_CalClkRateDivider(LPC_SPI_T *pSPI, uint32_t bitRate);
N
N/**
N * @brief	Config SPI Delay parameters
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	pConfig	: SPI Delay Configure Struct
N * @return	 Nothing
N * @note	The SPI controller is disabled
N */
Nvoid Chip_SPI_DelayConfig(LPC_SPI_T *pSPI, SPI_DELAY_CONFIG_T *pConfig);
N
N/**
N * @brief   Enable/Disable SPI interrupt
N * @param	pSPI			: The base SPI peripheral on the chip
N * @param	IntMask		: Interrupt mask
N * @param	NewState		: ENABLE or DISABLE interrupt
N * @return	Nothing
N */
Nvoid Chip_SPI_Int_Cmd(LPC_SPI_T *pSPI, uint32_t IntMask, FunctionalState NewState);
N
N/**
N * @brief	Enable SPI peripheral
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
N
N/**
N * @brief	Enable loopback mode
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note	Serial input is taken from the serial output (MOSI or MISO) rather
N * than the serial input pin
N */
NSTATIC INLINE void Chip_SPI_EnableLoopBack(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableLoopBack(LPC_SPI_T *pSPI)
N{
N	pSPI->CFG = SPI_CFG_LBM_EN | (pSPI->CFG & ~SPI_CFG_RESERVED);
X	pSPI->CFG = (1 << 7) | (pSPI->CFG & ~((1<<1)|(1<<6)|0xfffffe00));
N}
N
N/**
N * @brief	Disable loopback mode
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note	Serial input is taken from the serial output (MOSI or MISO) rather
N * than the serial input pin
N */
NSTATIC INLINE void Chip_SPI_DisableLoopBack(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_DisableLoopBack(LPC_SPI_T *pSPI)
N{
N	pSPI->CFG &= (~SPI_CFG_LBM_EN) & SPI_CFG_BITMASK;
X	pSPI->CFG &= (~(1 << 7)) & (0x1BD);
N}
N
N/**
N * @brief	Set control information including SSEL, EOT, EOF RXIGNORE and FLEN
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	Flen	: Data size (1-16)
N * @param	Flag	: Flag control (Or-ed values of SPI_TXCTL_*)
N * @note	The control information has no effect unless data is later written to TXDAT
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SetControlInfo(LPC_SPI_T *pSPI, uint8_t Flen, uint32_t Flag)
Xstatic __inline void Chip_SPI_SetControlInfo(LPC_SPI_T *pSPI, uint8_t Flen, uint32_t Flag)
N{
N	pSPI->TXCTRL = Flag | SPI_TXDATCTL_FLEN(Flen - 1);
X	pSPI->TXCTRL = Flag | (((Flen - 1) & 0x0F) << 24);
N}
N
N/**
N * @brief	 Send the first Frame of a transfer (Rx Ignore)
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	Data	:  Transmit data
N * @param	DataSize	:  Data Size (1-16)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SendFirstFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
Xstatic __inline void Chip_SPI_SendFirstFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
N{
N	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_RXIGNORE | SPI_TXDATCTL_FLEN(
N		DataSize - 1) | SPI_TXDATCTL_DATA(Data);
X	pSPI->TXDATCTL = (0 << 16) | (1 << 21) | (1 << 22) | (((DataSize - 1) & 0x0F) << 24) | ((Data) & 0xFFFF);
N}
N
N/**
N * @brief	 Send the first Frame of a transfer
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	Data	:  Transmit data
N * @param	DataSize	:  Data Size (1-16)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SendFirstFrame(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
Xstatic __inline void Chip_SPI_SendFirstFrame(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
N{
N	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(
N		Data);
X	pSPI->TXDATCTL = (0 << 16) | (1 << 21) | (((DataSize - 1) & 0x0F) << 24) | ((Data) & 0xFFFF);
N}
N
N/**
N * @brief	 Send the middle Frame of a transfer
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	Data	:  Transmit data
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SendMidFrame(LPC_SPI_T *pSPI, uint16_t Data)
Xstatic __inline void Chip_SPI_SendMidFrame(LPC_SPI_T *pSPI, uint16_t Data)
N{
N	pSPI->TXDAT = SPI_TXDAT_DATA(Data);
X	pSPI->TXDAT = ((Data) & 0xFFFF);
N}
N
N/**
N * @brief	 Send the last Frame of a transfer (Rx Ignore)
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	Data	:  Transmit data
N * @param	DataSize	:  Data Size (1-16)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
Xstatic __inline void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
N{
N	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
X	pSPI->TXDATCTL = (0 << 16) | (1 << 21) | (1 << 20) | (1 << 22) |
N					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
X					 (((DataSize - 1) & 0x0F) << 24) | ((Data) & 0xFFFF);
N}
N
N/**
N * @brief	 Send the last Frame of a transfer
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @param	Data	:  Transmit data
N * @param	DataSize	:  Data Size (1-16)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPI_SendLastFrame(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
Xstatic __inline void Chip_SPI_SendLastFrame(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
N{
N	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT |
X	pSPI->TXDATCTL = (0 << 16) | (1 << 21) | (1 << 20) |
N					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
X					 (((DataSize - 1) & 0x0F) << 24) | ((Data) & 0xFFFF);
N}
N
N/**
N * @brief	 Read data received
N * @param	pSPI		: The base of SPI peripheral on the chip
N * @return	Receive data
N */
NSTATIC INLINE uint16_t Chip_SPI_ReceiveFrame(LPC_SPI_T *pSPI)
Xstatic __inline uint16_t Chip_SPI_ReceiveFrame(LPC_SPI_T *pSPI)
N{
N	return SPI_RXDAT_DATA(pSPI->RXDAT);
X	return ((pSPI->RXDAT) & 0xFFFF);
N}
N
N/**
N * @brief   SPI Interrupt Read/Write
N * @param	pSPI			: The base SPI peripheral on the chip
N * @param	xf_setup		: Pointer to a SPI_DATA_SETUP_T structure that contains specified
N *                          information about transmit/receive data	configuration
N * @return	SUCCESS or ERROR
N */
NStatus Chip_SPI_Int_RWFrames(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *xf_setup);
N
N/**
N * @brief   SPI Polling Read/Write in blocking mode
N * @param	pSPI			: The base SPI peripheral on the chip
N * @param	pXfSetup		: Pointer to a SPI_DATA_SETUP_T structure that contains specified
N *                          information about transmit/receive data	configuration
N * @return	Actual data length has been transferred
N * @note
N * This function can be used in both master and slave mode. It starts with writing phase and after that,
N * a reading phase is generated to read any data available in RX_FIFO. All needed information is prepared
N * through xf_setup param.
N */
Nuint32_t Chip_SPI_RWFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup);
N
N/**
N * @brief   SPI Polling Write in blocking mode
N * @param	pSPI			: The base SPI peripheral on the chip
N * @param	pXfSetup			:Pointer to a SPI_DATA_SETUP_T structure that contains specified
N *                          information about transmit/receive data	configuration
N * @return	Actual data length has been transferred
N * @note
N * This function can be used in both master and slave mode. First, a writing operation will send
N * the needed data. After that, a dummy reading operation is generated to clear data buffer
N */
Nuint32_t Chip_SPI_WriteFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup);
N
N/**
N * @brief   SPI Polling Read in blocking mode
N * @param	pSPI			: The base SPI peripheral on the chip
N * @param	pXfSetup			:Pointer to a SPI_DATA_SETUP_T structure that contains specified
N *                          information about transmit/receive data	configuration
N * @return	Actual data length has been read
N * @note
N * This function can be used in both master and slave mode. First, a writing operation will send
N * the needed data. After that, a dummy reading operation is generated to clear data buffer
N */
Nuint32_t Chip_SPI_ReadFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SPI_8XX_H_ */
L 193 ".\lpc_chip_82x\inc\chip.h" 2
N#include "i2cm_8xx.h"
L 1 ".\lpc_chip_82x\inc\i2cm_8xx.h" 1
N/*
N * @brief LPC8XX I2C driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __I2CM_8XX_H_
N#define __I2CM_8XX_H_
N
N#include "i2c_common_8xx.h"
L 1 ".\lpc_chip_82x\inc\i2c_common_8xx.h" 1
N/*
N * @brief LPC15xx I2C driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __I2C_COMMON_8XX_H_
N#define __I2C_COMMON_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup I2C_15XX CHIP: LPC15xx I2C driver
N * @ingroup CHIP_15XX_Drivers
N * @{
N */
N
N/**
N * @brief I2C register block structure
N */
Ntypedef struct {					/* I2C0 Structure         */
N	__IO uint32_t CFG;				/*!< I2C Configuration Register common for Master, Slave and Monitor */
X	volatile uint32_t CFG;				 
N	__IO uint32_t STAT;				/*!< I2C Status Register common for Master, Slave and Monitor */
X	volatile uint32_t STAT;				 
N	__IO uint32_t INTENSET;			/*!< I2C Interrupt Enable Set Register common for Master, Slave and Monitor */
X	volatile uint32_t INTENSET;			 
N	__O  uint32_t INTENCLR;			/*!< I2C Interrupt Enable Clear Register common for Master, Slave and Monitor */
X	volatile  uint32_t INTENCLR;			 
N	__IO uint32_t TIMEOUT;			/*!< I2C Timeout value Register */
X	volatile uint32_t TIMEOUT;			 
N	__IO uint32_t CLKDIV;			/*!< I2C Clock Divider Register */
X	volatile uint32_t CLKDIV;			 
N	__I  uint32_t INTSTAT;			/*!< I2C Interrupt Status Register */
X	volatile const  uint32_t INTSTAT;			 
N	__I  uint32_t RESERVED0;        
X	volatile const  uint32_t RESERVED0;        
N	__IO uint32_t MSTCTL;			/*!< I2C Master Control Register */
X	volatile uint32_t MSTCTL;			 
N	__IO uint32_t MSTTIME;			/*!< I2C Master Time Register for SCL */
X	volatile uint32_t MSTTIME;			 
N	__IO uint32_t MSTDAT;			/*!< I2C Master Data Register */
X	volatile uint32_t MSTDAT;			 
N	__I  uint32_t RESERVED1[5];     
X	volatile const  uint32_t RESERVED1[5];     
N	__IO uint32_t SLVCTL;			/*!< I2C Slave Control Register */
X	volatile uint32_t SLVCTL;			 
N	__IO uint32_t SLVDAT;			/*!< I2C Slave Data Register */
X	volatile uint32_t SLVDAT;			 
N	__IO uint32_t SLVADR[4];		/*!< I2C Slave Address Registers */
X	volatile uint32_t SLVADR[4];		 
N	__IO uint32_t SLVQUAL0;			/*!< I2C Slave Address Qualifier 0 Register */
X	volatile uint32_t SLVQUAL0;			 
N	__I  uint32_t RESERVED2[9];     
X	volatile const  uint32_t RESERVED2[9];     
N	__I  uint32_t MONRXDAT;			/*!< I2C Monitor Data Register */
X	volatile const  uint32_t MONRXDAT;			 
N} LPC_I2C_T;
N
N/* Reserved bits masks for registers */
N#define I2C_CFG_RESERVED            (~0x1f)
N#define I2C_STAT_RESERVED           ((1<<5)|(1<<7)|(0xf<<20)|(0x3fu<<26))
N#define I2C_INTENSET_RESERVED       ((7<<1)|(1<<5)|(1<<7)|(3<<9)|(7<<12)|(1<<18)|(0xf<<20)|(0x3fu<<26))
N#define I2C_INTENCLR_RESERVED       ((7<<1)|(1<<5)|(1<<7)|(3<<9)|(7<<12)|(1<<18)|(0xf<<20)|(0x3fu<<26))
N#define I2C_TIMEOUT_RESERVED        0xffff0000
N#define I2C_CLKDIV_RESERVED         0xffff0000
N#define I2C_INTSTAT_RESERVED        ((7<<1)|(1<<5)|(1<<7)|(3<<9)|(7<<12)|(1<<18)|(0xf<<20)|(0x3fu<<26))
N#define I2C_MSTCTL_RESERVED         (~7)
N#define I2C_MSTTIME_RESERVED        (~0x7f)
N#define I2C_MSTDAT_RESERVED         (~0xff)
N#define I2C_SLVCTL_RESERVED         (~3)
N#define I2C_SLVDAT_RESERVED         (~0xff)
N#define I2C_SLVADR_RESERVED         (~0xff)
N#define I2C_SLVQUAL0_RESERVED       (~0xff)
N
N/*
N * @brief I2C Configuration register Bit definition
N */
N#define I2C_CFG_MSTEN               (1 << 0)			/*!< Master Enable/Disable Bit */
N#define I2C_CFG_SLVEN               (1 << 1)			/*!< Slave Enable/Disable Bit */
N#define I2C_CFG_MONEN               (1 << 2)			/*!< Monitor Enable/Disable Bit */
N#define I2C_CFG_TIMEOUTEN           (1 << 3)			/*!< Timeout Enable/Disable Bit */
N#define I2C_CFG_MONCLKSTR           (1 << 4)			/*!< Monitor Clock Stretching Bit */
N#define I2C_CFG_MASK                ((uint32_t) 0x1F)	/*!< Configuration register Mask */
N
N/*
N * @brief I2C Status register Bit definition
N */
N#define I2C_STAT_MSTPENDING         (1 << 0)			/*!< Master Pending Status Bit */
N#define I2C_STAT_MSTSTATE           (0x7 << 1)			/*!< Master State Code */
N#define I2C_STAT_MSTRARBLOSS        (1 << 4)			/*!< Master Arbitration Loss Bit */
N#define I2C_STAT_MSTSTSTPERR        (1 << 6)			/*!< Master Start Stop Error Bit */
N#define I2C_STAT_SLVPENDING         (1 << 8)			/*!< Slave Pending Status Bit */
N#define I2C_STAT_SLVSTATE           (0x3 << 9)			/*!< Slave State Code */
N#define I2C_STAT_SLVNOTSTR          (1 << 11)			/*!< Slave not stretching Clock Bit */
N#define I2C_STAT_SLVIDX             (0x3 << 12)			/*!< Slave Address Index */
N#define I2C_STAT_SLVSEL             (1 << 14)			/*!< Slave Selected Bit */
N#define I2C_STAT_SLVDESEL           (1 << 15)			/*!< Slave Deselect Bit */
N#define I2C_STAT_MONRDY             (1 << 16)			/*!< Monitor Ready Bit */
N#define I2C_STAT_MONOV              (1 << 17)			/*!< Monitor Overflow Flag */
N#define I2C_STAT_MONACTIVE          (1 << 18)			/*!< Monitor Active Flag */
N#define I2C_STAT_MONIDLE            (1 << 19)			/*!< Monitor Idle Flag */
N#define I2C_STAT_EVENTTIMEOUT       (1 << 24)			/*!< Event Timeout Interrupt Flag */
N#define I2C_STAT_SCLTIMEOUT         (1 << 25)			/*!< SCL Timeout Interrupt Flag */
N
N#define I2C_STAT_MSTCODE_IDLE       (0)					/*!< Master Idle State Code */
N#define I2C_STAT_MSTCODE_RXREADY    (1)					/*!< Master Receive Ready State Code */
N#define I2C_STAT_MSTCODE_TXREADY    (2)					/*!< Master Transmit Ready State Code */
N#define I2C_STAT_MSTCODE_NACKADR    (3)					/*!< Master NACK by slave on address State Code */
N#define I2C_STAT_MSTCODE_NACKDAT    (4)					/*!< Master NACK by slave on data State Code */
N
N#define I2C_STAT_SLVCODE_ADDR       (0)					/*!< Master Idle State Code */
N#define I2C_STAT_SLVCODE_RX         (1)					/*!< Received data is available Code */
N#define I2C_STAT_SLVCODE_TX         (2)					/*!< Data can be transmitted Code */
N
N/*
N * @brief I2C Interrupt Enable Set register Bit definition
N */
N#define I2C_INTENSET_MSTPENDING     (1 << 0)			/*!< Master Pending Interrupt Enable Bit */
N#define I2C_INTENSET_MSTRARBLOSS    (1 << 4)			/*!< Master Arbitration Loss Interrupt Enable Bit */
N#define I2C_INTENSET_MSTSTSTPERR    (1 << 6)			/*!< Master Start Stop Error Interrupt Enable Bit */
N#define I2C_INTENSET_SLVPENDING     (1 << 8)			/*!< Slave Pending Interrupt Enable Bit */
N#define I2C_INTENSET_SLVNOTSTR      (1 << 11)			/*!< Slave not stretching Clock Interrupt Enable Bit */
N#define I2C_INTENSET_SLVDESEL       (1 << 15)			/*!< Slave Deselect Interrupt Enable Bit */
N#define I2C_INTENSET_MONRDY         (1 << 16)			/*!< Monitor Ready Interrupt Enable Bit */
N#define I2C_INTENSET_MONOV          (1 << 17)			/*!< Monitor Overflow Interrupt Enable Bit */
N#define I2C_INTENSET_MONIDLE        (1 << 19)			/*!< Monitor Idle Interrupt Enable Bit */
N#define I2C_INTENSET_EVENTTIMEOUT   (1 << 24)			/*!< Event Timeout Interrupt Enable Bit */
N#define I2C_INTENSET_SCLTIMEOUT     (1 << 25)			/*!< SCL Timeout Interrupt Enable Bit */
N
N/*
N * @brief I2C Interrupt Enable Clear register Bit definition
N */
N#define I2C_INTENCLR_MSTPENDING     (1 << 0)			/*!< Master Pending Interrupt Clear Bit */
N#define I2C_INTENCLR_MSTRARBLOSS    (1 << 4)			/*!< Master Arbitration Loss Interrupt Clear Bit */
N#define I2C_INTENCLR_MSTSTSTPERR    (1 << 6)			/*!< Master Start Stop Error Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVPENDING     (1 << 8)			/*!< Slave Pending Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVNOTSTR      (1 << 11)			/*!< Slave not stretching Clock Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVDESEL       (1 << 15)			/*!< Slave Deselect Interrupt Clear Bit */
N#define I2C_INTENCLR_MONRDY         (1 << 16)			/*!< Monitor Ready Interrupt Clear Bit */
N#define I2C_INTENCLR_MONOV          (1 << 17)			/*!< Monitor Overflow Interrupt Clear Bit */
N#define I2C_INTENCLR_MONIDLE        (1 << 19)			/*!< Monitor Idle Interrupt Clear Bit */
N#define I2C_INTENCLR_EVENTTIMEOUT   (1 << 24)			/*!< Event Timeout Interrupt Clear Bit */
N#define I2C_INTENCLR_SCLTIMEOUT     (1 << 25)			/*!< SCL Timeout Interrupt Clear Bit */
N
N/*
N * @brief I2C TimeOut Value Macro
N */
N#define I2C_TIMEOUT_VAL(n)          (((uint32_t) ((n) - 1) & 0xFFF0) | 0x000F)	/*!< Macro for Timeout value register */
N
N/*
N * @brief I2C Interrupt Status register Bit definition
N */
N#define I2C_INTSTAT_MSTPENDING      (1 << 0)			/*!< Master Pending Interrupt Status Bit */
N#define I2C_INTSTAT_MSTRARBLOSS     (1 << 4)			/*!< Master Arbitration Loss Interrupt Status Bit */
N#define I2C_INTSTAT_MSTSTSTPERR     (1 << 6)			/*!< Master Start Stop Error Interrupt Status Bit */
N#define I2C_INTSTAT_SLVPENDING      (1 << 8)			/*!< Slave Pending Interrupt Status Bit */
N#define I2C_INTSTAT_SLVNOTSTR       (1 << 11)			/*!< Slave not stretching Clock Interrupt Status Bit */
N#define I2C_INTSTAT_SLVDESEL        (1 << 15)			/*!< Slave Deselect Interrupt Status Bit */
N#define I2C_INTSTAT_MONRDY          (1 << 16)			/*!< Monitor Ready Interrupt Status Bit */
N#define I2C_INTSTAT_MONOV           (1 << 17)			/*!< Monitor Overflow Interrupt Status Bit */
N#define I2C_INTSTAT_MONIDLE         (1 << 19)			/*!< Monitor Idle Interrupt Status Bit */
N#define I2C_INTSTAT_EVENTTIMEOUT    (1 << 24)			/*!< Event Timeout Interrupt Status Bit */
N#define I2C_INTSTAT_SCLTIMEOUT      (1 << 25)			/*!< SCL Timeout Interrupt Status Bit */
N
N/*
N * @brief I2C Master Control register Bit definition
N */
N#define I2C_MSTCTL_MSTCONTINUE      (1 << 0)			/*!< Master Continue Bit */
N#define I2C_MSTCTL_MSTSTART         (1 << 1)			/*!< Master Start Control Bit */
N#define I2C_MSTCTL_MSTSTOP          (1 << 2)			/*!< Master Stop Control Bit */
N#define I2C_MSTCTL_MSTDMA           (1 << 3)			/*!< Master DMA Enable Bit */
N
N/*
N * @brief I2C Master Time Register Field definition
N */
N#define I2C_MSTTIME_MSTSCLLOW       (0x07 << 0)			/*!< Master SCL Low Time field */
N#define I2C_MSTTIME_MSTSCLHIGH      (0x07 << 4)			/*!< Master SCL High Time field */
N
N/*
N * @brief I2C Master Data Mask
N */
N#define I2C_MSTDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Master data mask */
N
N/*
N * @brief I2C Slave Control register Bit definition
N */
N#define I2C_SLVCTL_SLVCONTINUE      (1 << 0)			/*!< Slave Continue Bit */
N#define I2C_SLVCTL_SLVNACK          (1 << 1)			/*!< Slave NACK Bit */
N#define I2C_SLVCTL_SLVDMA           (1 << 3)			/*!< Slave DMA Enable Bit */
N
N/*
N * @brief I2C Slave Data Mask
N */
N#define I2C_SLVDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Slave data mask */
N
N/*
N * @brief I2C Slave Address register Bit definition
N */
N#define I2C_SLVADR_SADISABLE        (1 << 0)			/*!< Slave Address n Disable Bit */
N#define I2C_SLVADR_SLVADR           (0x7F << 1)			/*!< Slave Address field */
N#define I2C_SLVADR_MASK             ((uint32_t) 0x00FF)	/*!< Slave Address Mask */
N
N/*
N * @brief I2C Slave Address Qualifier 0 Register Bit definition
N */
N#define I2C_SLVQUAL_QUALMODE0       (1 << 0)			/*!< Slave Qualifier Mode Enable Bit */
N#define I2C_SLVQUAL_SLVQUAL0        (0x7F << 1)			/*!< Slave Qualifier Address for Address 0 */
N
N/*
N * @brief I2C Monitor Data Register Bit definition
N */
N#define I2C_MONRXDAT_DATA           (0xFF << 0)			/*!< Monitor Function Receive Data Field */
N#define I2C_MONRXDAT_MONSTART       (1 << 8)			/*!< Monitor Received Start Bit */
N#define I2C_MONRXDAT_MONRESTART     (1 << 9)			/*!< Monitor Received Repeated Start Bit */
N#define I2C_MONRXDAT_MONNACK        (1 << 10)			/*!< Monitor Received Nack Bit */
N
N/**
N * @brief	Initialize I2C Interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function enables the I2C clock for both the master and
N * slave interfaces of the given I2C peripheral. LPC_I2C1, LPC_I2C2 and
N * LPC_I2C3 are available only on LPC82X devices.
N */
Nvoid Chip_I2C_Init(LPC_I2C_T *pI2C);
N
N/**
N * @brief	Shutdown I2C Interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function disables the I2C clock for both the master and
N * slave interfaces of the given I2C peripheral. Only LPC_I2C0 is available
N * on LPC81X devices.
N */
Nvoid Chip_I2C_DeInit(LPC_I2C_T *pI2C);
N
N/**
N * @brief	Sets I2C Clock Divider registers
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	clkdiv	: Clock Divider value for I2C, value is between (1 - 65536)
N * @return	Nothing
N * @note	The clock to I2C block is determined by the following formula (I2C_PCLK
N *          is the frequency of the system clock): <br>
N *              I2C Clock Frequency = (I2C_PCLK)/clkdiv;
N */
Nstatic INLINE void Chip_I2C_SetClockDiv(LPC_I2C_T *pI2C, uint32_t clkdiv)
Xstatic __inline void Chip_I2C_SetClockDiv(LPC_I2C_T *pI2C, uint32_t clkdiv)
N{
N	if ((clkdiv >= 1) && (clkdiv <= 65536)) {
N		pI2C->CLKDIV = clkdiv - 1;
N	}
N	else {
N		pI2C->CLKDIV = 0;
N	}
N}
N
N/**
N * @brief	Get I2C Clock Divider registers
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Clock Divider value
N * @note	Return the divider value for the I2C block
N *          It is the CLKDIV register value + 1
N */
Nstatic INLINE uint32_t Chip_I2C_GetClockDiv(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2C_GetClockDiv(LPC_I2C_T *pI2C)
N{
N	return (pI2C->CLKDIV & 0xFFFF) + 1;
N}
N
N/**
N * @brief	Enable I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	intEn	: ORed Value of I2C_INTENSET_* values to enable
N * @return	Nothing
N */
Nstatic INLINE void Chip_I2C_EnableInt(LPC_I2C_T *pI2C, uint32_t intEn)
Xstatic __inline void Chip_I2C_EnableInt(LPC_I2C_T *pI2C, uint32_t intEn)
N{
N	pI2C->INTENSET = intEn;
N}
N
N/**
N * @brief	Disable I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	intClr	: ORed Value of I2C_INTENSET_* values to disable
N * @return	Nothing
N */
Nstatic INLINE void Chip_I2C_DisableInt(LPC_I2C_T *pI2C, uint32_t intClr)
Xstatic __inline void Chip_I2C_DisableInt(LPC_I2C_T *pI2C, uint32_t intClr)
N{
N	pI2C->INTENCLR = intClr;
N}
N
N/**
N * @brief	Disable I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	intClr	: ORed Value of I2C_INTENSET_* values to disable
N * @return	Nothing
N * @note	It is recommended to use the Chip_I2C_DisableInt() function
N * instead of this function.
N */
Nstatic INLINE void Chip_I2C_ClearInt(LPC_I2C_T *pI2C, uint32_t intClr)
Xstatic __inline void Chip_I2C_ClearInt(LPC_I2C_T *pI2C, uint32_t intClr)
N{
N	Chip_I2C_DisableInt(pI2C, intClr);
N}
N
N/**
N * @brief	Returns pending I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	All pending interrupts, mask with I2C_INTENSET_* to determine specific interrupts
N */
Nstatic INLINE uint32_t Chip_I2C_GetPendingInt(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2C_GetPendingInt(LPC_I2C_T *pI2C)
N{
N	return pI2C->INTSTAT & ~I2C_INTSTAT_RESERVED;
X	return pI2C->INTSTAT & ~((7<<1)|(1<<5)|(1<<7)|(3<<9)|(7<<12)|(1<<18)|(0xf<<20)|(0x3fu<<26));
N}
N
N/**
N * @}
N */
N
N #ifdef __cplusplus
S}
N#endif
N
N#endif /* __I2C_COMMON_8XX_H_ */
L 36 ".\lpc_chip_82x\inc\i2cm_8xx.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup I2CM_8XX CHIP: LPC8XX I2C master-only driver
N * @ingroup I2C_8XX
N * This driver only works in master mode. To describe the I2C transactions
N * following symbols are used in driver documentation.
N *
N * Key to symbols
N * ==============
N * S     (1 bit) : Start bit
N * P     (1 bit) : Stop bit
N * Rd/Wr (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.
N * A, NA (1 bit) : Acknowledge and Not-Acknowledge bit.
N * Addr  (7 bits): I2C 7 bit address. Note that this can be expanded as usual to
N *                 get a 10 bit I2C address.
N * Data  (8 bits): A plain data byte. Sometimes, I write DataLow, DataHigh
N *                 for 16 bit data.
N * [..]: Data sent by I2C device, as opposed to data sent by the host adapter.
N * @{
N */
N
N/** I2CM_8XX_STATUS_TYPES I2C master transfer status types
N * @{
N */
N
N#define I2CM_STATUS_OK              0x00		/*!< Requested Request was executed successfully. */
N#define I2CM_STATUS_ERROR           0x01		/*!< Unknown error condition. */
N#define I2CM_STATUS_NAK_ADR         0x02		/*!< No acknowledgement received from slave during address phase. */
N#define I2CM_STATUS_BUS_ERROR       0x03		/*!< I2C bus error */
N#define I2CM_STATUS_NAK_DAT			0x04		/*!< No acknowledgement received from slave during address phase. */
N#define I2CM_STATUS_ARBLOST         0x05		/*!< Arbitration lost. */
N#define I2CM_STATUS_BUSY            0xFF		/*!< I2C transmistter is busy. */
N
N/**
N * @}
N */
N
N/**
N * @brief Master transfer data structure definitions
N */
Ntypedef struct {
N	const uint8_t *txBuff;	/*!< Pointer to array of bytes to be transmitted */
N	uint8_t *rxBuff;				/*!< Pointer memory where bytes received from I2C be stored */
N	uint16_t txSz;					/*!< Number of bytes in transmit array,
N									                if 0 only receive transfer will be carried on */
N	uint16_t rxSz;					/*!< Number of bytes to received,
N									                if 0 only transmission we be carried on */
N	uint16_t status;				/*!< Status of the current I2C transfer */
N	uint8_t slaveAddr;			/*!< 7-bit I2C Slave address */
N} I2CM_XFER_T;
N
N/**
N * @brief	Set up bus speed for LPC_I2C controller
N * @param	pI2C		: Pointer to selected I2C peripheral
N * @param	busSpeed	: I2C bus clock rate
N * @return	Nothing
N * @note	Per I2C specification the busSpeed should be
N *          @li 100000 for Standard mode
N *          @li 400000 for Fast mode
N *          @li 1000000 for Fast mode plus
N *          IOCON registers corresponding to I2C pads should be updated
N *          according to the bus mode.
N */
Nvoid Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed);
N
N/**
N * @brief	Enable I2C Master interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note
N */
Nstatic INLINE void Chip_I2CM_Enable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_Enable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) | I2C_CFG_MSTEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) | (1 << 0);
N}
N
N/**
N * @brief	Disable I2C Master interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note
N */
Nstatic INLINE void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) & ~I2C_CFG_MSTEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) & ~(1 << 0);
N}
N
N/**
N * @brief	Get I2C Status
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	I2C Status register value
N * @note	This function returns the value of the status register.
N */
Nstatic INLINE uint32_t Chip_I2CM_GetStatus(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CM_GetStatus(LPC_I2C_T *pI2C)
N{
N	return pI2C->STAT & ~I2C_STAT_RESERVED;
X	return pI2C->STAT & ~((1<<5)|(1<<7)|(0xf<<20)|(0x3fu<<26));
N}
N
N/**
N * @brief	Clear I2C status bits (master)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param clrStatus : Status bit to clear, ORed Value of I2C_STAT_MSTRARBLOSS and I2C_STAT_MSTSTSTPERR
N * @return	Nothing
N * @note	This function clears selected status flags.
N */
Nstatic INLINE void Chip_I2CM_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
Xstatic __inline void Chip_I2CM_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
N{
N	/* Clear Master Arbitration Loss and Start, Stop Error */
N	pI2C->STAT = clrStatus & (I2C_STAT_MSTRARBLOSS | I2C_STAT_MSTSTSTPERR);
X	pI2C->STAT = clrStatus & ((1 << 4) | (1 << 6));
N}
N
N/**
N * @brief	Check if I2C Master is pending
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the Master is pending else returns FALSE
N * @note
N */
Nstatic INLINE bool Chip_I2CM_IsMasterPending(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CM_IsMasterPending(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_MSTPENDING) != 0;
X	return (pI2C->STAT & (1 << 0)) != 0;
N}
N
N/**
N * @brief	Get current state of the I2C Master
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Master State Code, a value in the range of 0 - 4
N * @note	After the Master is pending this state code tells the reason
N *        for Master pending.
N */
Nstatic INLINE uint32_t Chip_I2CM_GetMasterState(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CM_GetMasterState(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_MSTSTATE) >> 1;
X	return (pI2C->STAT & (0x7 << 1)) >> 1;
N}
N
N/**
N * @brief	Transmit START or Repeat-START signal on I2C bus
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the controller to transmit START condition when
N *        the bus becomes free. This should be called only when master is pending.
N *				The function writes a complete value to Master Control register, ORing is not advised.
N */
Nstatic INLINE void Chip_I2CM_SendStart(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_SendStart(LPC_I2C_T *pI2C)
N{
N	pI2C->MSTCTL = I2C_MSTCTL_MSTSTART;
X	pI2C->MSTCTL = (1 << 1);
N}
N
N/**
N * @brief	Transmit STOP signal on I2C bus
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the controller to transmit STOP condition.
N *				This should be called only when master is pending. The function writes a
N *				complete value to Master Control register, ORing is not advised.
N */
Nstatic INLINE void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
N{
N	pI2C->MSTCTL = I2C_MSTCTL_MSTSTOP;
X	pI2C->MSTCTL = (1 << 2);
N}
N
N/**
N * @brief	Master Continue transfer operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the master controller to continue transmission.
N *				This should be called only when master is pending. The function writes a
N *				complete value to Master Control register, ORing is not advised.
N */
Nstatic INLINE void Chip_I2CM_MasterContinue(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_MasterContinue(LPC_I2C_T *pI2C)
N{
N	pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
X	pI2C->MSTCTL = (1 << 0);
N}
N
N/**
N * @brief	Transmit a single data byte through the I2C peripheral (master)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	data	: Byte to transmit
N * @return	Nothing
N * @note	This function attempts to place a byte into the I2C Master
N *			Data Register
N *
N */
Nstatic INLINE void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
Xstatic __inline void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
N{
N	pI2C->MSTDAT = (uint32_t) data;
N}
N
N/**
N * @brief	Read a single byte data from the I2C peripheral (master)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	A single byte of data read
N * @note	This function reads a byte from the I2C receive hold register
N *			regardless of I2C state.
N */
Nstatic INLINE uint8_t Chip_I2CM_ReadByte(LPC_I2C_T *pI2C)
Xstatic __inline uint8_t Chip_I2CM_ReadByte(LPC_I2C_T *pI2C)
N{
N	return (uint8_t) (pI2C->MSTDAT & I2C_MSTDAT_DATAMASK);
X	return (uint8_t) (pI2C->MSTDAT & ((uint32_t) 0x00FF << 0));
N}
N
N/**
N * @brief	Transfer state change handler
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
N * @return Returns non-zero value on completion of transfer. The @a status
N *         member of @a xfer structure contains the current status of the
N *         transfer at the end of the call.
N * @note
N * The parameter @a xfer should be same as the one passed to Chip_I2CM_Xfer()
N * routine. This function should be called from the I2C interrupt handler
N * only when a master interrupt occurs.
N */
Nuint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
N
N/**
N * @brief	Transmit and Receive data in master mode
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
N * @return	Nothing
N * @note
N * The parameter @a xfer should have its member @a slaveAddr initialized
N * to the 7-Bit slave address to which the master will do the xfer, Bit0
N * to bit6 should have the address and Bit8 is ignored. During the transfer
N * no code (like event handler) must change the content of the memory
N * pointed to by @a xfer. The member of @a xfer, @a txBuff and @a txSz be
N * initialized to the memory from which the I2C must pick the data to be
N * transfered to slave and the number of bytes to send respectively, similarly
N * @a rxBuff and @a rxSz must have pointer to memory where data received
N * from slave be stored and the number of data to get from slave respectilvely.
N * Following types of transfers are possible:
N * - Write-only transfer: When @a rxSz member of @a xfer is set to 0.
N *
N *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A] P
N *
N *      - If I2CM_XFER_OPTION_IGNORE_NACK is set in @a options memeber
N *
N *          S Addr Wr [A] txBuff0 [A or NA] ... txBuffN [A or NA] P
N *
N * - Read-only transfer: When @a txSz member of @a xfer is set to 0.
N *
N *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
N *
N *      - If I2CM_XFER_OPTION_LAST_RX_ACK is set in @a options memeber
N *
N *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] A P
N *
N * - Read-Write transfer: When @a rxSz and @ txSz members of @a xfer are non-zero.
N *
N *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A]
N *              S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
N *
N */
Nvoid Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
N
N/**
N * @brief	Transmit and Receive data in master mode
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
N * @return Returns non-zero value on succesful completion of transfer.
N * @note
N * This function operates same as Chip_I2CM_Xfer(), but is a blocking call.
N */
Nuint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
N
N/**
N * @}
N */
N
N #ifdef __cplusplus
S}
N#endif
N
N#endif /* __I2C_8XX_H_ */
L 194 ".\lpc_chip_82x\inc\chip.h" 2
N#include "i2cs_8xx.h"
L 1 ".\lpc_chip_82x\inc\i2cs_8xx.h" 1
N/*
N * @brief LPC8XX I2C slave driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __I2CS_8XX_H_
N#define __I2CS_8XX_H_
N
N#include "i2c_common_8xx.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup I2CS_8XX CHIP: LPC8XX I2C slave-only driver
N * @ingroup I2C_8XX
N * This driver only works in slave mode.
N * @{
N */
N
N/** @brief I2C slave service start callback
N * This callback is called from the I2C slave handler when an I2C slave address is
N * received and needs servicing. It's used to indicate the start of a slave transfer
N * that will happen on the slave bus.
N */
Ntypedef void (*I2CSlaveXferStart)(uint8_t addr);
N
N/** @brief I2C slave send data callback
N * This callback is called from the I2C slave handler when an I2C slave address needs
N * data to send. Return 0 to NACK the master and terminate the transfer, or return
N * a non-0 value with the value to send in *data.
N */
Ntypedef uint8_t (*I2CSlaveXferSend)(uint8_t *data);
N
N/** @brief I2C slave receive data callback
N * This callback is called from the I2C slave handler when an I2C slave address has
N * receive data. Return 0 to NACK the master and terminate the transfer, or return
N * a non-0 value to continue the transfer.
N */
Ntypedef uint8_t (*I2CSlaveXferRecv)(uint8_t data);
N
N/** @brief I2C slave service done callback
N * This callback is called from the I2C slave handler when an I2C slave transfer is
N * completed. It's used to indicate the end of a slave transfer.
N */
Ntypedef void (*I2CSlaveXferDone)(void);
N
N/**
N * Slave transfer are performed using 3 callbacks. These 3 callbacks handle most I2C
N * slave transfer cases. When the slave is setup and a slave interrupt is receive
N * and processed with the Chip_I2CS_XferHandler() function in the I2C interrupt handler,
N * one of these 3 callbacks is called. The callbacks can be used for unsized transfers
N * from the master.
N *
N * When an address is received, the SlaveXferAddr() callback is called with the
N * received address. Only addresses enabled in the slave controller will be handled.
N * The slave controller can support up to 4 slave addresses.
N *
N * If the master is going to perform a read operation, the SlaveXferSend() callback
N * is called. Place the data byte to send in *data and return a non-0 value to the
N * caller, or return 0 to NACK the master. (Note the master ACKS/NACKS to slave
N * on reads, so this won't necessarily stop the slave transfer.)<br>
N *
N * If the master performs a write operation, the SlaveXferRecv() callback is called
N * with the received data. Return a non-0 value to the caller, or return 0 to NACK
N * the master.<br>
N *
N * Once the transfer completes, the SlaveXferDone() callback will be called.<br>
N */
Ntypedef struct {
N	I2CSlaveXferStart slaveStart;	/*!< Called when an matching I2C slave address is received */
N	I2CSlaveXferSend slaveSend;		/*!< Called when a byte is needed to send to master */
N	I2CSlaveXferRecv slaveRecv;		/*!< Called when a byte is received from master */
N	I2CSlaveXferDone slaveDone;		/*!< Called when a slave transfer is complete */
N} I2CS_XFER_T;
N
N/**
N * @brief	Enable I2C slave interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	Do not call this function until the slave interface is fully configured.
N */
NSTATIC INLINE void Chip_I2CS_Enable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_Enable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) | I2C_CFG_SLVEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) | (1 << 1);
N}
N
N/**
N * @brief	Disable I2C slave interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N */
NSTATIC INLINE void Chip_I2CS_Disable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_Disable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) & ~I2C_CFG_SLVEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) & ~(1 << 1);
N}
N
N/**
N * @brief	Get I2C Status
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	I2C Status register value
N * @note	This function returns the value of the status register.
N */
NSTATIC INLINE uint32_t Chip_I2CS_GetStatus(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CS_GetStatus(LPC_I2C_T *pI2C)
N{
N	return pI2C->STAT & ~I2C_STAT_RESERVED;
X	return pI2C->STAT & ~((1<<5)|(1<<7)|(0xf<<20)|(0x3fu<<26));
N}
N
N/**
N * @brief	Clear I2C status bits (slave)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param clrStatus : Status bit to clear, must be I2C_STAT_SLVDESEL
N * @return	Nothing
N * @note	This function clears selected status flags.
N */
NSTATIC INLINE void Chip_I2CS_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
Xstatic __inline void Chip_I2CS_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
N{
N	pI2C->STAT = clrStatus & I2C_STAT_SLVDESEL;
X	pI2C->STAT = clrStatus & (1 << 15);
N}
N
N/**
N * @brief	Check if I2C slave is pending
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the slave is pending else returns FALSE
N * @note
N */
NSTATIC INLINE bool Chip_I2CS_IsSlavePending(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CS_IsSlavePending(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVPENDING) != 0;
X	return (pI2C->STAT & (1 << 8)) != 0;
N}
N
N/**
N * @brief	Check if I2C slave is selected
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the slave is is selected, otherwise FALSE
N * @note
N */
NSTATIC INLINE bool Chip_I2CS_IsSlaveSelected(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CS_IsSlaveSelected(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVSEL) != 0;
X	return (pI2C->STAT & (1 << 14)) != 0;
N}
N
N/**
N * @brief	Check if I2C slave is deselected
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the slave is is deselected, otherwise FALSE
N * @note
N */
NSTATIC INLINE bool Chip_I2CS_IsSlaveDeSelected(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CS_IsSlaveDeSelected(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVDESEL) != 0;
X	return (pI2C->STAT & (1 << 15)) != 0;
N}
N
N/**
N * @brief	Get current state of the I2C slave
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	slave State Code, a value of type I2C_STAT_SLVCODE_*
N * @note	After the slave is pending this state code tells the reason
N *        for slave pending.
N */
NSTATIC INLINE uint32_t Chip_I2CS_GetSlaveState(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CS_GetSlaveState(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVSTATE) >> 9;
X	return (pI2C->STAT & (0x3 << 9)) >> 9;
N}
N
N/**
N * @brief	Returns the current slave address match index
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	slave match index, 0 - 3
N */
NSTATIC INLINE uint32_t Chip_I2CS_GetSlaveMatchIndex(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CS_GetSlaveMatchIndex(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVIDX) >> 12;
X	return (pI2C->STAT & (0x3 << 12)) >> 12;
N}
N
N/**
N * @brief	Slave Continue transfer operation (ACK)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the slave controller to continue transmission.
N *				This should be called only when slave is pending. The function writes a
N *				complete value to slave Control register, ORing is not advised.
N */
NSTATIC INLINE void Chip_I2CS_SlaveContinue(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_SlaveContinue(LPC_I2C_T *pI2C)
N{
N	pI2C->SLVCTL = I2C_SLVCTL_SLVCONTINUE;
X	pI2C->SLVCTL = (1 << 0);
N}
N
N/**
N * @brief	Slave NACK operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the slave controller to NAK the master.
N */
NSTATIC INLINE void Chip_I2CS_SlaveNACK(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_SlaveNACK(LPC_I2C_T *pI2C)
N{
N	pI2C->SLVCTL = I2C_SLVCTL_SLVNACK;
X	pI2C->SLVCTL = (1 << 1);
N}
N
N/**
N * @brief	Transmit a single data byte through the I2C peripheral (slave)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	data	: Byte to transmit
N * @return	Nothing
N * @note	This function attempts to place a byte into the I2C slave
N *			Data Register
N *
N */
NSTATIC INLINE void Chip_I2CS_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
Xstatic __inline void Chip_I2CS_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
N{
N	pI2C->SLVDAT = (uint32_t) data;
N}
N
N/**
N * @brief	Read a single byte data from the I2C peripheral (slave)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	A single byte of data read
N * @note	This function reads a byte from the I2C receive hold register
N *			regardless of I2C state.
N */
NSTATIC INLINE uint8_t Chip_I2CS_ReadByte(LPC_I2C_T *pI2C)
Xstatic __inline uint8_t Chip_I2CS_ReadByte(LPC_I2C_T *pI2C)
N{
N	return (uint8_t) (pI2C->SLVDAT & I2C_SLVDAT_DATAMASK);
X	return (uint8_t) (pI2C->SLVDAT & ((uint32_t) 0x00FF << 0));
N}
N
N/**
N * @brief	Set a I2C slave address for slave operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @param	slvAddr	: Slave Address for the index (7-bits, bit 7 = 0)
N * @return	Nothing
N * @note	Setting a slave address also enables the slave address. Do
N * not 'pre-shift' the slave address.
N */
NSTATIC INLINE void Chip_I2CS_SetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum, uint8_t slvAddr)
Xstatic __inline void Chip_I2CS_SetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum, uint8_t slvAddr)
N{
N	pI2C->SLVADR[slvNum] = (uint32_t) (slvAddr << 1);
N}
N
N/**
N * @brief	Return a I2C programmed slave address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @return	Nothing
N */
NSTATIC INLINE uint8_t Chip_I2CS_GetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
Xstatic __inline uint8_t Chip_I2CS_GetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
N{
N	return (pI2C->SLVADR[slvNum] >> 1) & 0x7F;
N}
N
N/**
N * @brief	Enable a I2C address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @return	Nothing
N */
NSTATIC INLINE void Chip_I2CS_EnableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
Xstatic __inline void Chip_I2CS_EnableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
N{
N	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & I2C_SLVADR_MASK) & ~I2C_SLVADR_SADISABLE;
X	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & ((uint32_t) 0x00FF)) & ~(1 << 0);
N}
N
N/**
N * @brief	Disable a I2C address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @return	Nothing
N */
NSTATIC INLINE void Chip_I2CS_DisableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
Xstatic __inline void Chip_I2CS_DisableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
N{
N	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & I2C_SLVADR_MASK) | I2C_SLVADR_SADISABLE;
X	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & ((uint32_t) 0x00FF)) | (1 << 0);
N}
N
N/**
N * @brief	Setup slave qialifier address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	extend	: true to extend I2C slave detect address 0 range, or false to match to corresponding bits
N * @param	slvNum	: Slave address qualifier, see SLVQUAL0 register in User Manual
N * @return	Nothing
N * @note	Do not 'pre-shift' the slave address.
N */
NSTATIC INLINE void Chip_I2CS_SetSlaveQual0(LPC_I2C_T *pI2C, bool extend, uint8_t slvNum)
Xstatic __inline void Chip_I2CS_SetSlaveQual0(LPC_I2C_T *pI2C, _Bool extend, uint8_t slvNum)
N{
N	slvNum = slvNum << 1;
N	if (extend) {
N		slvNum |= I2C_SLVQUAL_QUALMODE0;
X		slvNum |= (1 << 0);
N	}
N
N	pI2C->SLVQUAL0 = slvNum;
N}
N
N/**
N * @brief	Slave transfer state change handler
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfers	: Pointer to a I2CS_MULTI_XFER_T structure see notes below
N * @return	Returns non-zero value on completion of transfer
N * @note	See @ref I2CS_XFER_T for more information on this function. When using
N * this function, the I2C_INTENSET_SLVPENDING and I2C_INTENSET_SLVDESEL interrupts
N * should be enabled and setup in the I2C interrupt handler to call this function
N * when they fire.
N */
Nuint32_t Chip_I2CS_XferHandler(LPC_I2C_T *pI2C, const I2CS_XFER_T *xfers);
N
N/**
N * @}
N */
N
N #ifdef __cplusplus
S}
N#endif
N
N#endif /* __I2CS_8XX_H_ */
L 195 ".\lpc_chip_82x\inc\chip.h" 2
N#include "spim_8xx.h"
L 1 ".\lpc_chip_82x\inc\spim_8xx.h" 1
N/*
N * @brief LPC8XX SPI master driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SPIM_8XX_H_
N#define __SPIM_8XX_H_
N
N#include "spi_common_8xx.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SPI_MASTER_8XX CHIP: LPC8XX SPI master driver
N * @ingroup SPI_COMMON_8XX
N * @{
N */
N
N/**
N * @brief	Get SPI master bit rate
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	The actual SPI clock bit rate
N */
Nuint32_t Chip_SPIM_GetClockRate(LPC_SPI_T *pSPI);
N
N/**
N * @brief	Set SPI master bit rate
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	rate	: Desired clock bit rate for the SPI interface
N * @return	The actual SPI clock bit rate
N * @note	This function will set the SPI clock divider to get closest
N * to the desired rate as possible.
N */
Nuint32_t Chip_SPIM_SetClockRate(LPC_SPI_T *pSPI, uint32_t rate);
N
N/**
N * @brief SPI Delay Configure Struct
N */
Ntypedef struct {
N	uint8_t PreDelay;					/** Pre-delay value in SPI clocks, 0 - 15 */
N	uint8_t PostDelay;					/** Post-delay value in SPI clocks, 0 - 15 */
N	uint8_t FrameDelay;					/** Delay value between frames of a transfer in SPI clocks, 0 - 15 */
N	uint8_t TransferDelay;				/** Delay value between transfers in SPI clocks, 1 - 16 */
N} SPIM_DELAY_CONFIG_T;
N
N/**
N * @brief	Config SPI Delay parameters
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	pConfig	: SPI Delay Configure Struct
N * @return	Nothing
N */
Nvoid Chip_SPIM_DelayConfig(LPC_SPI_T *pSPI, SPIM_DELAY_CONFIG_T *pConfig);
N
N/**
N * @brief	Forces an end of transfer for the current master transfer
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note	Use this function to perform an immediate end of trasnfer for the
N * current master operation. If the master is currently transferring data started
N * with the Chip_SPIM_Xfer function, this terminates the transfer after the
N * current byte completes and completes the transfer.
N */
NSTATIC INLINE void Chip_SPIM_ForceEndOfTransfer(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPIM_ForceEndOfTransfer(LPC_SPI_T *pSPI)
N{
N	pSPI->STAT = SPI_STAT_EOT;
X	pSPI->STAT = (1 << 7);
N}
N
N/**
N * @brief	Assert a SPI select
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	sselNum	: SPI select to assert, 0 - 3
N * @return	Nothing
N */
Nvoid Chip_SPIM_AssertSSEL(LPC_SPI_T *pSPI, uint8_t sselNum);
N
N/**
N * @brief	Deassert a SPI select
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	sselNum	: SPI select to deassert, 0 - 3
N * @return	Nothing
N */
Nvoid Chip_SPIM_DeAssertSSEL(LPC_SPI_T *pSPI, uint8_t sselNum);
N
N/**
N * @brief	Enable loopback mode
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note	Serial input is taken from the serial output (MOSI or MISO) rather
N * than the serial input pin.
N */
NSTATIC INLINE void Chip_SPIM_EnableLoopBack(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPIM_EnableLoopBack(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_LBM_EN);
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << 7));
N}
N
N/**
N * @brief	Disable loopback mode
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_SPIM_DisableLoopBack(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPIM_DisableLoopBack(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_LBM_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 7));
N}
N
Nstruct SPIM_XFER;
N
N/** @brief SPI master select assert callback
N * This callback is called from the SPI master handler when the SPI master
N * selects the slave (asserts SSEL).
N */
Ntypedef void (*SPIMasterXferCSAssert)(struct SPIM_XFER *pMasterXfer);
N
N/** @brief SPI master send data callback
N * This callback is called from the SPI master handler when the SPI master
N * needs a data buffer to send.
N */
Ntypedef void (*SPIMasterXferSend)(struct SPIM_XFER *pMasterXfer);
N
N/** @brief SPI master receive data callback
N * This callback is called from the SPI master handler when the SPI master
N * needs a buffer to place data into.
N */
Ntypedef void (*SPIMasterXferRecv)(struct SPIM_XFER *pMasterXfer);
N
N/** @brief SPI master transfer select deassert data callback
N * This callback is called from the SPI master handler when the SPI master
N * deasserts the slave select.
N */
Ntypedef void (*SPIMMasterXferCSDeAssert)(struct SPIM_XFER *pMasterXfer);
N
N/** @brief SPI master transfer done data callback
N * This callback is called from the SPI master handler when the SPI master
N * has completed the transfer and becomes idle.
N */
Ntypedef void (*SPIMMasterXferDone)(struct SPIM_XFER *pMasterXfer);
N
N/** SPI slave callback functions */
Ntypedef struct {
N	SPIMasterXferCSAssert   masterXferCSAssert;		/** SPI transfer CS assert, called when a slave select is asserted */
N	SPIMasterXferSend       masterXferSend;			/** SPI transfer data receive buffer callback, called when a send buffer is needed */
N	SPIMasterXferRecv       masterXferRecv;			/** SPI transfer send buffer callback, called when send buffer is needed (and SPI_TXCTL_RXIGNORE option is not set) */
N	SPIMMasterXferCSDeAssert mMasterXferCSDeAssert;	/** SPI transfer CS deassert, called when a slave select is deasserted */
N	SPIMMasterXferDone      mMasterXferDone;		/** SPI transfer done callback, called when transfer is complete */
N} SPIM_CALLBACKS_T;
N
N/** Slave transfer data context */
Ntypedef struct SPIM_XFER {
N	const SPIM_CALLBACKS_T *pCB;	/** Pointer to SPI master data callback functions */
N	union {							/** Pointer to receive buffer, set to NULL to toss receeive data */
N		uint8_t *pRXData8;			/** Receive buffer used with data transfer size <= 8-bits, modified by driver */
N		uint16_t *pRXData16;		/** Receive buffer used with data transfer size > 8-bits, modified by driver */
N	};
N
N	union {							/** Pointer to transmit buffer, set to NULL to transmit 0x0 */
N		uint8_t *pTXData8;			/** Send buffer used with data transfer size <= 8-bits, modified by driver */
N		uint16_t *pTXData16;		/** Send buffer used with data transfer size > 8-bits, modified by driver */
N	};
N
N	uint32_t options;				/** Master transfer options, an OR'ed value of SPI_TXCTL_EOT, SPI_TXCTL_EOF, SPI_TXCTL_RXIGNORE, and SPI_TXCTL_FLEN(bits) */
N	uint16_t rxCount;				/** Size of the pRXData buffer in items (not bytes), modified by driver */
N	uint16_t txCount;				/** Number of items (not bytes) to send in pTXData buffer, modified by driver */
N	uint16_t dataRXferred;			/** Total items (not bytes) received, modified by driver */
N	uint16_t dataTXferred;			/** Total items (not bytes) transmitted, modified by driver */
N	uint8_t sselNum;				/** Slave number assigned to this transfer, 0 - 3, used by driver to select slave */
N	bool    terminate;				/** Transfer will terminate when txCount goes to 0 and master goes idle, must be set before last byte is sent */
X	_Bool    terminate;				 
N} SPIM_XFER_T;
N
N/**
N * @brief	SPI master transfer state change handler
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
N * @return	Nothing
N * @note	See @ref SPIM_XFER_T for more information on this function. When using
N * this function, the SPI master interrupts should be enabled and setup in the SPI
N * interrupt handler to call this function when they fire. This function is meant
N * to be called from the interrupt handler.
N */
Nvoid Chip_SPIM_XferHandler(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
N
N/**
N * @brief	Start non-blocking SPI master transfer
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
N * @return	Nothing
N * @note	This function starts a non-blocking SPI master transfer with the
N * parameters setup in the passed @ref SPIM_XFER_T structure. Once the transfer is
N * started, the interrupt handler must call Chip_SPIM_XferHandler to keep the
N * transfer going and fed with data. This function should only be called when
N * the master is idle.<br>
N *
N * This function must be called with the options and sselNum fields correctly
N * setup. Initial data buffers and the callback pointer must also be setup. No
N * sanity checks are performed on the passed data.<br>
N *
N * Example call:<br>
N * SPIM_XFER_T mxfer;
N * mxfer.pCB = &masterCallbacks;
N * mxfer.sselNum = 2; // Use chip select 2
N * mxfer.options = SPI_TXCTL_FLEN(8); // 8 data bits, supports 1 - 16 bits
N * mxfer.options |= SPI_TXCTL_EOT | SPI_TXCTL_EOF; // Apply frame and transfer delays to master transfer
N * mxfer.options |= SPI_TXCTL_RXIGNORE; // Ignore RX data, will toss receive data regardless of pRXData8 or pRXData16 buffer
N * mxfer.pTXData8 = SendBuffer;
N * mxfer.txCount = 16; // Number of bytes to send before SPIMasterXferSend callback is called
N * mxfer.pRXData8 = RecvBuffer; // Will not receive data if pRXData8/pRXData16 is NULL or SPI_TXCTL_RXIGNORE option is set
N * mxfer.rxCount = 16; // Number of bytes to receive before SPIMasterXferRecv callback is called
N * Chip_SPIM_Xfer(LPC_SPI0, &mxfer); // Start transfer
N *
N * Note that the transfer, once started, needs to be constantly fed by the callbacks.
N * The txCount and rxCount field only indicate the buffer size before the callbacks are called.
N * To terminate the transfer, the SPIMasterXferSend callback must set the terminate field.
N */
Nvoid Chip_SPIM_Xfer(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
N
N/**
N * @brief	Perform blocking SPI master transfer
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
N * @return	Nothing
N * @note	This function starts a blocking SPI master transfer with the
N * parameters setup in the passed @ref SPIM_XFER_T structure. Once the transfer is
N * started, the callbacks in Chip_SPIM_XferHandler may be called to keep the
N * transfer going and fed with data. SPI interrupts must be disabled prior to
N * calling this function. It is not recommended to use this function.<br>
N */
Nvoid Chip_SPIM_XferBlocking(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SPIM_8XX_H_ */
L 196 ".\lpc_chip_82x\inc\chip.h" 2
N#include "spis_8xx.h"
L 1 ".\lpc_chip_82x\inc\spis_8xx.h" 1
N/*
N * @brief LPC8XX SPI slave driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SPIS_8XX_H_
N#define __SPIS_8XX_H_
N
N#include "spi_common_8xx.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SPI_SLAVE_8XX CHIP: LPC8XX SPI slave driver
N * @ingroup SPI_COMMON_8XX
N * @{
N */
N
N/**
N * Macro defines for SPI Status register
N */
N
N/* Clear RXOV Flag */
N#define SPI_STAT_CLR_RXOV       ((uint32_t) (1 << 2))
N/* Clear TXUR Flag */
N#define SPI_STAT_CLR_TXUR       ((uint32_t) (1 << 3))
N/* Clear SSA Flag */
N#define SPI_STAT_CLR_SSA        ((uint32_t) (1 << 4))
N/* Clear SSD Flag */
N#define SPI_STAT_CLR_SSD        ((uint32_t) (1 << 5))
N
Nstruct SPIS_XFER;
N
N/** @brief SPI slave select assertion callback
N * This callback is called from the SPI slave handler when an SPI slave select (SSEL)
N * is initially asserted. It is used to indicate the start of a slave transfer that
N * will happen on the bus.
N */
Ntypedef void (*SPISlaveXferCSAssert)(struct SPIS_XFER *pSlaveXfer);
N
N/** @brief SPI slave send data callback
N * This callback is called from the SPI slave handler when an SPI slave select (SSEL)
N * needs a data buffer to send.
N */
Ntypedef void (*SPISlaveXferSend)(struct SPIS_XFER *pSlaveXfer);
N
N/** @brief SPI slave receive data callback
N * This callback is called from the SPI slave handler when an SPI slave select (SSEL)
N * needs a buffer to place data.
N */
Ntypedef void (*SPISlaveXferRecv)(struct SPIS_XFER *pSlaveXfer);
N
N/** @brief SPI slave select de-assertion callback
N * This callback is called from the SPI slave handler when an SPI slave select (SSEL)
N * is de-asserted. It can be used to indicate the end of a transfer.
N */
Ntypedef void (*SPISlaveXferCSDeAssert)(struct SPIS_XFER *pSlaveXfer);
N
N/** SPI slave callback functions */
Ntypedef struct {
N	SPISlaveXferCSAssert    slaveXferCSAssert;		/** SPI transfer start callback, called on SPI CS assertion */
N	SPISlaveXferSend        slaveXferSend;			/** SPI transfer data receive buffer callback, called when a receive buffer is needed */
N	SPISlaveXferRecv        slaveXferRecv;			/** SPI transfer send buffer callback, called when data is needed */
N	SPISlaveXferCSDeAssert  slaveXferCSDeAssert;	/** SPI transfer completion callback, called on SPI CS deassertion */
N} SPIS_CALLBACKS_T;
N
N/** Slave transfer data context */
Ntypedef struct SPIS_XFER {
N	const SPIS_CALLBACKS_T *pCB;	/** Pointer to SPI slave callback functions */
N	union {							/** Pointer to receive buffer, set to NULL to toss receeive data */
N		uint8_t *pRXData8;			/** Receive buffer used with data transfer size <= 8-bits, modified by driver */
N		uint16_t *pRXData16;		/** Receive buffer used with data transfer size > 8-bits, modified by driver */
N	};
N
N	union {							/** Pointer to transmit buffer, set to NULL to transmit 0x0 */
N		uint8_t *pTXData8;			/** Send buffer used with data transfer size <= 8-bits, modified by driver */
N		uint16_t *pTXData16;		/** Send buffer used with data transfer size > 8-bits, modified by driver */
N	};
N
N	uint16_t rxCount;				/** Size of the pRXData buffer in items (not bytes), modified by driver */
N	uint16_t txCount;				/** Number of items (not bytes) to send in pTXData buffer, modified by driver */
N	uint16_t dataRXferred;			/** Total items (not bytes) received, modified by driver */
N	uint16_t dataTXferred;			/** Total items (not bytes) transmitted, modified by driver */
N	uint8_t sselNum;				/** Slave number assigned to this transfer, 0 - 3, modified by driver */
N} SPIS_XFER_T;
N
N/**
N * @brief	SPI slave transfer state change handler
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIS_XFER_T structure see notes below
N * @return	returns 0 on success, or SPI_STAT_RXOV and/or SPI_STAT_TXUR on an error
N * @note	See @ref SPIS_XFER_T for more information on this function. When using
N * this function, the SPI slave interrupts should be enabled and setup in the SPI
N * interrupt handler to call this function when they fire. This function is meant
N * to be called from the interrupt handler. The @ref SPIS_XFER_T data does not need
N * to be setup prior to the call and should be setup by the callbacks instead.<br>
N *
N * The callbacks are handled in the interrupt handler. If you are getting overflow
N * or underflow errors, you might need to lower the speed of the master clock or
N * extend the master's select assetion time.<br>
N */
Nuint32_t Chip_SPIS_XferHandler(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer);
N
N/**
N * @brief	Pre-buffers slave transmit data
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIS_XFER_T structure see notes below
N * @return	Nothing
N * @note Pre-buffering allows the slave to prime the transmit FIFO with data prior to
N * the master starting a transfer. If data is not pre-buffered, the initial slave
N * transmit data will always be 0x0 with a slave transmit underflow status.
N * Pre-buffering is best used when only a single slave select is used by an
N * application.
N */
NSTATIC INLINE void Chip_SPIS_PreBuffSlave(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer)
Xstatic __inline void Chip_SPIS_PreBuffSlave(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer)
N{
N	Chip_SPIS_XferHandler(pSPI, xfer);
N}
N
N/**
N * @brief	SPI slave transfer blocking function
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIS_XFER_T structure
N * @return	returns 0 on success, or SPI_STAT_RXOV and/or SPI_STAT_TXUR on an error
N * @note	This function performs a blocking transfer on the SPI slave interface.
N * It is not recommended to use this function. Once this function is called, it
N * will block forever until a slave transfer consisting of a slave SSEL assertion,
N * and de-assertion occur. The callbacks are still used for slave data buffer
N * management. SPI interrupts must be disabled prior to calling this function.
N */
Nuint32_t Chip_SPIS_XferBlocking(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SPIS_8XX_H_ */
L 197 ".\lpc_chip_82x\inc\chip.h" 2
N#include "irc_8xx.h"
L 1 ".\lpc_chip_82x\inc\irc_8xx.h" 1
N/*
N * @brief LPC8xx IRC configuration
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __IRC_8XX_H_
N#define __IRC_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup IRC_8XX CHIP: LPC8xx IRC Configuration
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N /**
N * @brief	set main / system clock using IRC and PLL
N * @param	main: main clock frequency (in MHz)
N * @param	sys	: system clock frequency (in MHz)
N * @return	bool: Success = true / fail = false
N * @note	This is a table based function. The table uses both the 
N *			main frequency and the system frequency to set the PLL.
N *			All useful main / system clock combinations are in the table.
N *			See irc_8xx.c for details.
N */
Nbool Chip_IRC_SetFreq(uint32_t main, uint32_t sys);
X_Bool Chip_IRC_SetFreq(uint32_t main, uint32_t sys);
N
N /**
N * @brief	Set main / system clock using IRC and PLL
N * @param	sys	: system clock frequency (in MHz)
N * @return	Nothing
N * @note	This function uses the ROM set_pll() function.
N */
Nvoid Chip_IRC_SetFreq_ROM(uint32_t sys);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __IRC_8XX_H_ */
L 198 ".\lpc_chip_82x\inc\chip.h" 2
N#ifdef CHIP_LPC82X
N#include "adc_8xx.h"
L 1 ".\lpc_chip_82x\inc\adc_8xx.h" 1
N/*
N * @brief  LPC82x ADC driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ADC_8XX_H_
N#define __ADC_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup ADC_8XX CHIP:  LPC8xx A/D conversion driver (Available on LPC82x Family)
N * @ingroup CHIP_8xx_Drivers
N * @{
N */
N
N/** Sequence index enumerations, used in various parts of the code for
N    register indexing and sequencer selection */
Ntypedef enum {
N	ADC_SEQA_IDX,
N	ADC_SEQB_IDX
N} ADC_SEQ_IDX_T;
N
N/**
N * @brief ADC register block structure
N */
Ntypedef struct {								/*!< ADCn Structure */
N	__IO uint32_t CTRL;							/*!< A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur. */
X	volatile uint32_t CTRL;							 
N	__I  uint32_t RESERVED0;
X	volatile const  uint32_t RESERVED0;
N	__IO uint32_t SEQ_CTRL[ADC_SEQB_IDX + 1];	/*!< A/D Sequence A & B Control Register. Controls triggering and channel selection for sonversion sequence. */
X	volatile uint32_t SEQ_CTRL[ADC_SEQB_IDX + 1];	 
N	__IO uint32_t SEQ_GDAT[ADC_SEQB_IDX + 1];	/*!< A/D Sequence A & B Global Data Register. Contains the result of the most recent A/D conversion for sequence. */
X	volatile uint32_t SEQ_GDAT[ADC_SEQB_IDX + 1];	 
N	__I  uint32_t RESERVED1[2];
X	volatile const  uint32_t RESERVED1[2];
N	__I  uint32_t DR[12];						/*!< A/D Channel Data Register. This register contains the result of the most recent conversion completed on channel n. */
X	volatile const  uint32_t DR[12];						 
N	__IO uint32_t THR_LOW[2];					/*!< A/D Low Compare Threshold Register 0 & 1. Contains the lower threshold level for automatic threshold comparison. */
X	volatile uint32_t THR_LOW[2];					 
N	__IO uint32_t THR_HIGH[2];					/*!< A/D High Compare Threshold Register 0 & 1. Contains the higher threshold level for automatic threshold comparison. */
X	volatile uint32_t THR_HIGH[2];					 
N	__IO uint32_t CHAN_THRSEL;					/*!< A/D Channel Threshold Select Register. Specifies which set of threshold compare registers to use. */
X	volatile uint32_t CHAN_THRSEL;					 
N	__IO uint32_t INTEN;						/*!< A/D Interrupt Enable Register. This register contains enable bits that enable sequence-A, sequence-B, threshold compare and overrun interrupts. */
X	volatile uint32_t INTEN;						 
N	__IO uint32_t FLAGS;						/*!< A/D Flags Register. This register contains interrupt flags. - To be checked */
X	volatile uint32_t FLAGS;						 
N	__IO uint32_t TRM;							/*!< A/D Trim Register. */
X	volatile uint32_t TRM;							 
N} LPC_ADC_T;
N
N/** Maximum sample rate in Hz (12-bit conversions) */
N#define ADC_MAX_SAMPLE_RATE 30000000
N
N/**
N * @brief ADC register support bitfields and mask
N */
N/** ADC Control register bit fields */
N#define ADC_CR_CLKDIV_MASK      (0xFF << 0)				/*!< Mask for Clock divider value */
N#define ADC_CR_CLKDIV_BITPOS    (0)						/*!< Bit position for Clock divider value */
N#define ADC_CR_ASYNMODE         (1 << 8)				/*!< Asynchronous mode enable bit */
N#define ADC_CR_MODE10BIT        (1 << 9)				/*!< 10-bit mode enable bit */
N#define ADC_CR_LPWRMODEBIT      (1 << 10)				/*!< Low power mode enable bit */
N#define ADC_CR_CALMODEBIT       (1 << 30)				/*!< Self calibration cycle enable bit */
N#define ADC_CR_BITACC(n)        ((((n) & 0x1) << 9))	/*!< 12-bit or 10-bit ADC accuracy */
N#define ADC_CR_CLKDIV(n)        ((((n) & 0xFF) << 0))	/*!< The APB clock (PCLK) is divided by (this value plus one) to produce the clock for the A/D */
N#define ADC_SAMPLE_RATE_CONFIG_MASK (ADC_CR_CLKDIV(0xFF) | ADC_CR_BITACC(0x01))
N
N/** ADC Sequence Control register bit fields */
N#define ADC_SEQ_CTRL_CHANSEL(n)   (1 << (n))			/*!< Channel select macro */
N#define ADC_SEQ_CTRL_CHANSEL_MASK (0xFFF)				/*!< Channel select mask */
N
N/** ADC hardware trigger sources in SEQ_CTRL */
N#define ADC_SEQ_CTRL_HWTRIG_ARM_TXEV     (0 << 12)		/*!< HW trigger input - ARM TXEV */
N#define ADC_SEQ_CTRL_HWTRIG_CT32B0_MAT0  (1 << 12)		/*!< HW trigger input - Match output 0 of CT32B0 */
N#define ADC_SEQ_CTRL_HWTRIG_CT32B0_MAT1  (2 << 12)		/*!< HW trigger input - Match output 1 of CT32B1 or SCT_OUT0 */
N#define ADC_SEQ_CTRL_HWTRIG_SCT_OUT0     (2 << 12)		/*!< HW trigger input - Match output 1 of CT32B1 or SCT_OUT0 */
N#define ADC_SEQ_CTRL_HWTRIG_CT16B0_MAT0  (3 << 12)		/*!< HW trigger input - Match output 0 of CT16B0 */
N#define ADC_SEQ_CTRL_HWTRIG_CT16B0_MAT1  (4 << 12)		/*!< HW trigger input - Match output 1 of CT16B1 or SCT_OUT1 */
N#define ADC_SEQ_CTRL_HWTRIG_SCT_OUT1     (4 << 12)		/*!< HW trigger input - Match output 1 of CT16B1 or SCT_OUT1 */
N#define ADC_SEQ_CTRL_HWTRIG_CT16B0_CAP0  (5 << 12)		/*!< HW trigger input - Capture input 0 of CT16B0 */
N#define ADC_SEQ_CTRL_HWTRIG_CT16B1_CAP0  (6 << 12)		/*!< HW trigger input - Capture input 0 of CT16B1 */
N#define ADC_SEQ_CTRL_HWTRIG_CT32B0_CAP0  (7 << 12)		/*!< HW trigger input - Capture input 0 of CT32B1 */
N#define ADC_SEQ_CTRL_HWTRIG_MASK         (0x3F << 12)	/*!< HW trigger input bitfield mask */
N
N/** SEQ_CTRL register bit fields */
N#define ADC_SEQ_CTRL_HWTRIG_POLPOS       (1 << 18)		/*!< HW trigger polarity - positive edge */
N#define ADC_SEQ_CTRL_HWTRIG_SYNCBYPASS   (1 << 19)		/*!< HW trigger bypass synchronisation */
N#define ADC_SEQ_CTRL_START               (1 << 26)		/*!< Start conversion enable bit */
N#define ADC_SEQ_CTRL_BURST               (1 << 27)		/*!< Repeated conversion enable bit */
N#define ADC_SEQ_CTRL_SINGLESTEP          (1 << 28)		/*!< Single step enable bit */
N#define ADC_SEQ_CTRL_LOWPRIO             (1 << 29)		/*!< High priority enable bit (regardless of name) */
N#define ADC_SEQ_CTRL_MODE_EOS            (1 << 30)		/*!< Mode End of sequence enable bit */
N#define ADC_SEQ_CTRL_SEQ_ENA             (1UL << 31)	/*!< Sequence enable bit */
N
N/** ADC global data register bit fields */
N#define ADC_SEQ_GDAT_RESULT_MASK         (0xFFF << 4)	/*!< Result value mask */
N#define ADC_SEQ_GDAT_RESULT_BITPOS       (4)			/*!< Result start bit position */
N#define ADC_SEQ_GDAT_THCMPRANGE_MASK     (0x3 << 16)	/*!< Comparion range mask */
N#define ADC_SEQ_GDAT_THCMPRANGE_BITPOS   (16)			/*!< Comparison range bit position */
N#define ADC_SEQ_GDAT_THCMPCROSS_MASK     (0x3 << 18)	/*!< Comparion cross mask */
N#define ADC_SEQ_GDAT_THCMPCROSS_BITPOS   (18)			/*!< Comparison cross bit position */
N#define ADC_SEQ_GDAT_CHAN_MASK           (0xF << 26)	/*!< Channel number mask */
N#define ADC_SEQ_GDAT_CHAN_BITPOS         (26)			/*!< Channel number bit position */
N#define ADC_SEQ_GDAT_OVERRUN             (1 << 30)		/*!< Overrun bit */
N#define ADC_SEQ_GDAT_DATAVALID           (1UL << 31)	/*!< Data valid bit */
N
N/** ADC Data register bit fields */
N#define ADC_DR_RESULT(n)           ((((n) >> 4) & 0xFFF))	/*!< Macro for getting the ADC data value */
N#define ADC_DR_THCMPRANGE_MASK     (0x3 << 16)			/*!< Comparion range mask */
N#define ADC_DR_THCMPRANGE_BITPOS   (16)					/*!< Comparison range bit position */
N#define ADC_DR_THCMPRANGE(n)       (((n) >> ADC_DR_THCMPRANGE_BITPOS) & 0x3)
N#define ADC_DR_THCMPCROSS_MASK     (0x3 << 18)			/*!< Comparion cross mask */
N#define ADC_DR_THCMPCROSS_BITPOS   (18)					/*!< Comparison cross bit position */
N#define ADC_DR_THCMPCROSS(n)       (((n) >> ADC_DR_THCMPCROSS_BITPOS) & 0x3)
N#define ADC_DR_CHAN_MASK           (0xF << 26)			/*!< Channel number mask */
N#define ADC_DR_CHAN_BITPOS         (26)					/*!< Channel number bit position */
N#define ADC_DR_CHANNEL(n)          (((n) >> ADC_DR_CHAN_BITPOS) & 0xF)	/*!< Channel number bit position */
N#define ADC_DR_OVERRUN             (1 << 30)			/*!< Overrun bit */
N#define ADC_DR_DATAVALID           (1UL << 31)			/*!< Data valid bit */
N#define ADC_DR_DONE(n)             (((n) >> 31))
N
N/** ADC low/high Threshold register bit fields */
N#define ADC_THR_VAL_MASK            (0xFFF << 4)		/*!< Threshold value bit mask */
N#define ADC_THR_VAL_POS             (4)					/*!< Threshold value bit position */
N
N/** ADC Threshold select register bit fields */
N#define ADC_THRSEL_CHAN_SEL_THR1(n) (1 << (n))			/*!< Select THR1 register for channel n */
N
N/** ADC Interrupt Enable register bit fields */
N#define ADC_INTEN_SEQA_ENABLE       (1 << 0)			/*!< Sequence A Interrupt enable bit */
N#define ADC_INTEN_SEQB_ENABLE       (1 << 1)			/*!< Sequence B Interrupt enable bit */
N#define ADC_INTEN_SEQN_ENABLE(seq)  (1 << (seq))		/*!< Sequence A/B Interrupt enable bit */
N#define ADC_INTEN_OVRRUN_ENABLE     (1 << 2)			/*!< Overrun Interrupt enable bit */
N#define ADC_INTEN_CMP_DISBALE       (0)					/*!< Disable comparison interrupt value */
N#define ADC_INTEN_CMP_OUTSIDETH     (1)					/*!< Outside threshold interrupt value */
N#define ADC_INTEN_CMP_CROSSTH       (2)					/*!< Crossing threshold interrupt value */
N#define ADC_INTEN_CMP_MASK          (3)					/*!< Comparison interrupt value mask */
N#define ADC_INTEN_CMP_ENABLE(isel, ch) (((isel) & ADC_INTEN_CMP_MASK) << ((2 * (ch)) + 3))	/*!< Interrupt selection for channel */
N
N/** ADC Flags register bit fields */
N#define ADC_FLAGS_THCMP_MASK(ch)    (1 << (ch))		/*!< Threshold comparison status for channel */
N#define ADC_FLAGS_OVRRUN_MASK(ch)   (1 << (12 + (ch)))	/*!< Overrun status for channel */
N#define ADC_FLAGS_SEQA_OVRRUN_MASK  (1 << 24)			/*!< Seq A Overrun status */
N#define ADC_FLAGS_SEQB_OVRRUN_MASK  (1 << 25)			/*!< Seq B Overrun status */
N#define ADC_FLAGS_SEQN_OVRRUN_MASK(seq) (1 << (24 + (seq)))	/*!< Seq A/B Overrun status */
N#define ADC_FLAGS_SEQA_INT_MASK     (1 << 28)			/*!< Seq A Interrupt status */
N#define ADC_FLAGS_SEQB_INT_MASK     (1 << 29)			/*!< Seq B Interrupt status */
N#define ADC_FLAGS_SEQN_INT_MASK(seq) (1 << (28 + (seq)))/*!< Seq A/B Interrupt status */
N#define ADC_FLAGS_THCMP_INT_MASK    (1 << 30)			/*!< Threshold comparison Interrupt status */
N#define ADC_FLAGS_OVRRUN_INT_MASK   (1UL << 31)			/*!< Overrun Interrupt status */
N
N/** ADC Trim register bit fields */
N#define ADC_TRIM_VRANGE_HIGHV       (0 << 5)			/*!< Voltage range bit - High volatge (2.7V to 3.6V) */
N#define ADC_TRIM_VRANGE_LOWV        (1 << 5)			/*!< Voltage range bit - Low volatge (1.8V to 2.7V) */
N
N/** ADC Register reserved bit masks */
N#define ADC_CHAN_THRSEL_RES 0xFFFFF000
N#define ADC_INTEN_RES       0xF8000000
N#define ADC_SEQ_CTRL_RES    ((7 << 15) | (0x3F << 20))
N
N/**
N * @brief	Initialize the ADC peripheral
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	flags	: ADC flags for init (ADC_CR_MODE10BIT and/or ADC_CR_LPWRMODEBIT)
N * @return	Nothing
N * @note	To select low-power ADC mode, enable the ADC_CR_LPWRMODEBIT flag.
N * To select 10-bit conversion mode, enable the ADC_CR_MODE10BIT flag.<br>
N * Example: Chip_ADC_Init(LPC_ADC, (ADC_CR_MODE10BIT | ADC_CR_LPWRMODEBIT));
N */
Nvoid Chip_ADC_Init(LPC_ADC_T *pADC, uint32_t flags);
N
N/**
N * @brief	Shutdown ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return	Nothing
N * @note	Disables the ADC clocks and ADC power
N */
Nvoid Chip_ADC_DeInit(LPC_ADC_T *pADC);
N
N/**
N * @brief	Set ADC divider
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	div		: ADC divider value to set minus 1
N * @return	Nothing
N * @note	The value is used as a divider to generate the ADC
N * clock rate from the ADC input clock. The ADC input clock is based
N * on the system clock. Valid values for this function are from 0 to 255
N * with 0=divide by 1, 1=divide by 2, 2=divide by 3, etc.<br>
N * Do not decrement this value by 1.<br>
N * To set the ADC clock rate to 1MHz, use the following function:<br>
N * Chip_ADC_SetDivider(LPC_ADC, (Chip_Clock_GetSystemClockRate() / 1000000) - 1);
N */
NSTATIC INLINE void Chip_ADC_SetDivider(LPC_ADC_T *pADC, uint8_t div)
Xstatic __inline void Chip_ADC_SetDivider(LPC_ADC_T *pADC, uint8_t div)
N{
N	uint32_t temp;
N
N	temp = pADC->CTRL & ~(ADC_CR_CLKDIV_MASK);
X	temp = pADC->CTRL & ~((0xFF << 0));
N	pADC->CTRL = temp | (uint32_t) div;
N}
N
N/**
N * @brief	Set ADC clock rate
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	rate	: rate in Hz to set ADC clock to (maximum ADC_MAX_SAMPLE_RATE)
N * @return	Nothing
N * @note	When ADC is set to ADC_CR_ASYNMODE this function has no effect. The
N * rate mentioned in @a rate is the sampling clock rate and not the frequency at
N * at which the conversion will be done. Example setting @a rate to 30 MHz will
N * get a sampling rate of 1.2M samples per second.
N */
NSTATIC INLINE void Chip_ADC_SetClockRate(LPC_ADC_T *pADC, uint32_t rate)
Xstatic __inline void Chip_ADC_SetClockRate(LPC_ADC_T *pADC, uint32_t rate)
N{
N	Chip_ADC_SetDivider(pADC, (uint8_t) (Chip_Clock_GetSystemClockRate() / rate) - 1);
N}
N
N/**
N * @brief	Get ADC divider
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return	the current ADC divider
N * @note	This function returns the divider that is used to generate the
N * ADC frequency. The returned value must be incremented by 1. The
N * frequency can be determined with the following function:<br>
N * adc_freq = Chip_Clock_GetSystemClockRate() / (Chip_ADC_GetDivider(LPC_ADC) + 1);
N */
NSTATIC INLINE uint8_t Chip_ADC_GetDivider(LPC_ADC_T *pADC)
Xstatic __inline uint8_t Chip_ADC_GetDivider(LPC_ADC_T *pADC)
N{
N	return pADC->CTRL & ADC_CR_CLKDIV_MASK;
X	return pADC->CTRL & (0xFF << 0);
N}
N
N/**
N * @brief	Start ADC calibration
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return	Nothing
N * @note	Calibration is not done as part of Chip_ADC_Init(), but
N * is required after the call to Chip_ADC_Init() or after returning
N * from a power-down state. Calibration may alter the ADC_CR_ASYNMODE
N * and ADC_CR_LPWRMODEBIT flags ni the CTRL register.
N */
Nvoid Chip_ADC_StartCalibration(LPC_ADC_T *pADC);
N
N/**
N * @brief	Start ADC calibration
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return	TRUE if calibration is complete, otherwise FALSE.
N */
NSTATIC INLINE bool Chip_ADC_IsCalibrationDone(LPC_ADC_T *pADC)
Xstatic __inline _Bool Chip_ADC_IsCalibrationDone(LPC_ADC_T *pADC)
N{
N	return (bool) ((pADC->CTRL & ADC_CR_CALMODEBIT) == 0);
X	return (_Bool) ((pADC->CTRL & (1 << 30)) == 0);
N}
N
N/**
N * @brief	Helper function for safely setting ADC sequencer register bits
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to set bits for
N * @param	bits		: Or'ed bits of a sequencer register to set
N * @return	Nothing
N * @note	This function will safely set the ADC sequencer register bits
N * while maintaining bits 20..25 as 0, regardless of the read state of those bits.
N */
NSTATIC INLINE void Chip_ADC_SetSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
Xstatic __inline void Chip_ADC_SetSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
N{
N	pADC->SEQ_CTRL[seqIndex] = (pADC->SEQ_CTRL[seqIndex] & ~ADC_SEQ_CTRL_RES) | bits;
X	pADC->SEQ_CTRL[seqIndex] = (pADC->SEQ_CTRL[seqIndex] & ~((7 << 15) | (0x3F << 20))) | bits;
N}
N
N/**
N * @brief	Helper function for safely clearing ADC sequencer register bits
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to clear bits for
N * @param	bits		: Or'ed bits of a sequencer register to clear
N * @return	Nothing
N * @note	This function will safely clear the ADC sequencer register bits
N * while maintaining bits 20..25 as 0, regardless of the read state of those bits.
N */
NSTATIC INLINE void Chip_ADC_ClearSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
Xstatic __inline void Chip_ADC_ClearSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
N{
N	pADC->SEQ_CTRL[seqIndex] = pADC->SEQ_CTRL[seqIndex] & ~(ADC_SEQ_CTRL_RES | bits);
X	pADC->SEQ_CTRL[seqIndex] = pADC->SEQ_CTRL[seqIndex] & ~(((7 << 15) | (0x3F << 20)) | bits);
N}
N
N/**
N * @brief	Sets up ADC conversion sequencer A or B
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to setup
N * @param	options		: OR'ed Sequencer options to setup (see notes)
N * @return	Nothing
N * @note	Sets up sequencer options for a conversion sequence. This function
N * should be used to setup the selected channels for the sequence, the sequencer
N * trigger, the trigger polarity, synchronization bypass, priority, and mode. All
N * options are passed to the functions as a OR'ed list of values. This function will
N * disable/clear the sequencer start/burst/single step/enable if they are enabled.<br>
N * Select the channels by OR'ing in one or more ADC_SEQ_CTRL_CHANSEL(ch) values.<br>
N * Select the hardware trigger by OR'ing in one ADC_SEQ_CTRL_HWTRIG_* value.<br>
N * Select a positive edge hardware trigger by OR'ing in ADC_SEQ_CTRL_HWTRIG_POLPOS.<br>
N * Select trigger bypass synchronisation by OR'ing in ADC_SEQ_CTRL_HWTRIG_SYNCBYPASS.<br>
N * Select ADC single step on trigger/start by OR'ing in ADC_SEQ_CTRL_SINGLESTEP.<br>
N * Select higher priority conversion on the other sequencer by OR'ing in ADC_SEQ_CTRL_LOWPRIO.<br>
N * Select end of seqeuence instead of end of conversion interrupt by OR'ing in ADC_SEQ_CTRL_MODE_EOS.<br>
N * Example for setting up sequencer A (channels 0-2, trigger on high edge of PIO0_2, interrupt on end of sequence):<br>
N * Chip_ADC_SetupSequencer(LPC_ADC, ADC_SEQA_IDX, (
N *     ADC_SEQ_CTRL_CHANSEL(0) | ADC_SEQ_CTRL_CHANSEL(1) | ADC_SEQ_CTRL_CHANSEL(2) |
N *     ADC_SEQ_CTRL_HWTRIG_PIO0_2 | ADC_SEQ_CTRL_HWTRIG_POLPOS | ADC_SEQ_CTRL_MODE_EOS));
N */
NSTATIC INLINE void Chip_ADC_SetupSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t options)
Xstatic __inline void Chip_ADC_SetupSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t options)
N{
N	pADC->SEQ_CTRL[seqIndex] = options;
N}
N
N/**
N * @brief	Enables a sequencer
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to enable
N * @return	Nothing
N */
NSTATIC INLINE void Chip_ADC_EnableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_EnableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_SEQ_ENA);
X	Chip_ADC_SetSequencerBits(pADC, seqIndex, (1UL << 31));
N}
N
N/**
N * @brief	Disables a sequencer
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to disable
N * @return	Nothing
N */
NSTATIC INLINE void Chip_ADC_DisableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_DisableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_SEQ_ENA);
X	Chip_ADC_ClearSequencerBits(pADC, seqIndex, (1UL << 31));
N}
N
N/**
N * @brief	Forces a sequencer trigger event (software trigger of ADC)
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to start
N * @return	Nothing
N * @note	This function sets the START bit for the sequencer to force a
N * single conversion sequence or a single step conversion.
N */
NSTATIC INLINE void Chip_ADC_StartSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_StartSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_START);
X	Chip_ADC_SetSequencerBits(pADC, seqIndex, (1 << 26));
N}
N
N/**
N * @brief	Starts sequencer burst mode
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to start burst on
N * @return	Nothing
N * @note	This function sets the BURST bit for the sequencer to force
N * continuous conversion. Use Chip_ADC_StopBurstSequencer() to stop the
N * ADC burst sequence.
N */
NSTATIC INLINE void Chip_ADC_StartBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_StartBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
X	Chip_ADC_SetSequencerBits(pADC, seqIndex, (1 << 27));
N}
N
N/**
N * @brief	Stops sequencer burst mode
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to stop burst on
N * @return	Nothing
N */
NSTATIC INLINE void Chip_ADC_StopBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_StopBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
X	Chip_ADC_ClearSequencerBits(pADC, seqIndex, (1 << 27));
N}
N
N/** ADC sequence global data register threshold comparison range enumerations */
Ntypedef enum {
N	ADC_DR_THCMPRANGE_INRANGE,
N	ADC_DR_THCMPRANGE_RESERVED,
N	ADC_DR_THCMPRANGE_BELOW,
N	ADC_DR_THCMPRANGE_ABOVE
N} ADC_DR_THCMPRANGE_T;
N
N/** ADC sequence global data register threshold comparison cross enumerations */
Ntypedef enum {
N	ADC_DR_THCMPCROSS_NOCROSS,
N	ADC_DR_THCMPCROSS_RESERVED,
N	ADC_DR_THCMPCROSS_DOWNWARD,
N	ADC_DR_THCMPCROSS_UPWARD
N} ADC_DR_THCMPCROSS_T;
N
N/**
N * @brief	Read a ADC sequence global data register
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to read
N * @return	Current raw value of the ADC sequence A or B global data register
N * @note	This function returns the raw value of the data register and clears
N * the overrun and datavalid status for the register. Once this register is read,
N * the following functions can be used to parse the raw value:<br>
N * uint32_t adcDataRawValue = Chip_ADC_ReadSequencerDataReg(LPC_ADC, ADC_SEQA_IDX); // Get raw value
N * uint32_t adcDataValue = ADC_DR_RESULT(adcDataRawValue); // Aligned and masked ADC data value
N * ADC_DR_THCMPRANGE_T adcRange = (ADC_DR_THCMPRANGE_T) ADC_DR_THCMPRANGE(adcDataRawValue); // Sample range compared to threshold low/high
N * ADC_DR_THCMPCROSS_T adcRange = (ADC_DR_THCMPCROSS_T) ADC_DR_THCMPCROSS(adcDataRawValue); // Sample cross compared to threshold low
N * uint32_t channel = ADC_DR_CHANNEL(adcDataRawValue); // ADC channel for this sample/data
N * bool adcDataOverrun = (bool) ((adcDataRawValue & ADC_DR_OVERRUN) != 0); // Data overrun flag
N * bool adcDataValid = (bool) ((adcDataRawValue & ADC_SEQ_GDAT_DATAVALID) != 0); // Data valid flag
N */
NSTATIC INLINE uint32_t Chip_ADC_GetSequencerDataReg(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline uint32_t Chip_ADC_GetSequencerDataReg(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	return pADC->SEQ_GDAT[seqIndex];
N}
N
N/**
N * @brief	Read a ADC data register
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	index	: Data register to read, 1-8
N * @return	Current raw value of the ADC data register
N * @note	This function returns the raw value of the data register and clears
N * the overrun and datavalid status for the register. Once this register is read,
N * the following functions can be used to parse the raw value:<br>
N * uint32_t adcDataRawValue = Chip_ADC_ReadSequencerDataReg(LPC_ADC, ADC_SEQA_IDX); // Get raw value
N * uint32_t adcDataValue = ADC_DR_RESULT(adcDataRawValue); // Aligned and masked ADC data value
N * ADC_DR_THCMPRANGE_T adcRange = (ADC_DR_THCMPRANGE_T) ADC_DR_THCMPRANGE(adcDataRawValue); // Sample range compared to threshold low/high
N * ADC_DR_THCMPCROSS_T adcRange = (ADC_DR_THCMPCROSS_T) ADC_DR_THCMPCROSS(adcDataRawValue); // Sample cross compared to threshold low
N * uint32_t channel = ADC_DR_CHANNEL(adcDataRawValue); // ADC channel for this sample/data
N * bool adcDataOverrun = (bool) ((adcDataRawValue & ADC_DR_OVERRUN) != 0); // Data overrun flag
N * bool adcDataValid = (bool) ((adcDataRawValue & ADC_SEQ_GDAT_DATAVALID) != 0); // Data valid flag
N */
NSTATIC INLINE uint32_t Chip_ADC_GetDataReg(LPC_ADC_T *pADC, uint8_t index)
Xstatic __inline uint32_t Chip_ADC_GetDataReg(LPC_ADC_T *pADC, uint8_t index)
N{
N	return pADC->DR[index];
N}
N
N/**
N * @brief	Set Threshold low value in ADC
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param   thrnum      : Threshold register value (1 for threshold register 1, 0 for threshold register 0)
N * @param   value       : Threshold low data value (should be 12-bit value)
N * @return	None
N */
NSTATIC INLINE void Chip_ADC_SetThrLowValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
Xstatic __inline void Chip_ADC_SetThrLowValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
N{
N	pADC->THR_LOW[thrnum] = (((uint32_t) value) << ADC_THR_VAL_POS);
X	pADC->THR_LOW[thrnum] = (((uint32_t) value) << (4));
N}
N
N/**
N * @brief	Set Threshold high value in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param   thrnum	: Threshold register value (1 for threshold register 1, 0 for threshold register 0)
N * @param   value	: Threshold high data value (should be 12-bit value)
N * @return	None
N */
NSTATIC INLINE void Chip_ADC_SetThrHighValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
Xstatic __inline void Chip_ADC_SetThrHighValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
N{
N	pADC->THR_HIGH[thrnum] = (((uint32_t) value) << ADC_THR_VAL_POS);
X	pADC->THR_HIGH[thrnum] = (((uint32_t) value) << (4));
N}
N
N/**
N * @brief	Select threshold 0 values for comparison for selected channels
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param   channels	: An OR'ed value of one or more ADC_THRSEL_CHAN_SEL_THR1(ch) values
N * @return	None
N * @note	Select multiple channels to use the threshold 0 comparison.<br>
N * Example:<br>
N * Chip_ADC_SelectTH0Channels(LPC_ADC, (ADC_THRSEL_CHAN_SEL_THR1(1) | ADC_THRSEL_CHAN_SEL_THR1(2))); // Selects channels 1 and 2 for threshold 0
N */
NSTATIC INLINE void Chip_ADC_SelectTH0Channels(LPC_ADC_T *pADC, uint32_t channels)
Xstatic __inline void Chip_ADC_SelectTH0Channels(LPC_ADC_T *pADC, uint32_t channels)
N{
N	pADC->CHAN_THRSEL = pADC->CHAN_THRSEL & ~(ADC_CHAN_THRSEL_RES | channels);
X	pADC->CHAN_THRSEL = pADC->CHAN_THRSEL & ~(0xFFFFF000 | channels);
N}
N
N/**
N * @brief	Select threshold 1 value for comparison for selected channels
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param   channels	: An OR'ed value of one or more ADC_THRSEL_CHAN_SEL_THR1(ch) values
N * @return	None
N * @note	Select multiple channels to use the 1 threshold comparison.<br>
N * Example:<br>
N * Chip_ADC_SelectTH1Channels(LPC_ADC, (ADC_THRSEL_CHAN_SEL_THR1(4) | ADC_THRSEL_CHAN_SEL_THR1(5))); // Selects channels 4 and 5 for 1 threshold
N */
NSTATIC INLINE void Chip_ADC_SelectTH1Channels(LPC_ADC_T *pADC, uint32_t channels)
Xstatic __inline void Chip_ADC_SelectTH1Channels(LPC_ADC_T *pADC, uint32_t channels)
N{
N	pADC->CHAN_THRSEL = (pADC->CHAN_THRSEL & ~ADC_CHAN_THRSEL_RES) | channels;
X	pADC->CHAN_THRSEL = (pADC->CHAN_THRSEL & ~0xFFFFF000) | channels;
N}
N
N/**
N * @brief	Enable interrupts in ADC (sequencers A/B and overrun)
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	intMask	: Interrupt values to be enabled (see notes)
N * @return	None
N * @note	Select one or more OR'ed values of ADC_INTEN_SEQA_ENABLE,
N * ADC_INTEN_SEQB_ENABLE, and ADC_INTEN_OVRRUN_ENABLE to enable the
N * specific ADC interrupts.
N */
NSTATIC INLINE void Chip_ADC_EnableInt(LPC_ADC_T *pADC, uint32_t intMask)
Xstatic __inline void Chip_ADC_EnableInt(LPC_ADC_T *pADC, uint32_t intMask)
N{
N	pADC->INTEN = (pADC->INTEN & ~ADC_INTEN_RES) | intMask;
X	pADC->INTEN = (pADC->INTEN & ~0xF8000000) | intMask;
N}
N
N/**
N * @brief	Disable interrupts in ADC (sequencers A/B and overrun)
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	intMask	: Interrupt values to be disabled (see notes)
N * @return	None
N * @note	Select one or more OR'ed values of ADC_INTEN_SEQA_ENABLE,
N * ADC_INTEN_SEQB_ENABLE, and ADC_INTEN_OVRRUN_ENABLE to disable the
N * specific ADC interrupts.
N */
NSTATIC INLINE void Chip_ADC_DisableInt(LPC_ADC_T *pADC, uint32_t intMask)
Xstatic __inline void Chip_ADC_DisableInt(LPC_ADC_T *pADC, uint32_t intMask)
N{
N	pADC->INTEN = pADC->INTEN & ~(ADC_INTEN_RES | intMask);
X	pADC->INTEN = pADC->INTEN & ~(0xF8000000 | intMask);
N}
N
N/** Threshold interrupt event options */
Ntypedef enum {
N	ADC_INTEN_THCMP_DISABLE,
N	ADC_INTEN_THCMP_OUTSIDE,
N	ADC_INTEN_THCMP_CROSSING,
N} ADC_INTEN_THCMP_T;
N
N/**
N * @brief	Enable a threshold event interrupt in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	ch		: ADC channel to set threshold inetrrupt for, 1-8
N * @param	thInt	: Selected threshold interrupt type
N * @return	None
N */
NSTATIC INLINE void Chip_ADC_SetThresholdInt(LPC_ADC_T *pADC, uint8_t ch, ADC_INTEN_THCMP_T thInt)
Xstatic __inline void Chip_ADC_SetThresholdInt(LPC_ADC_T *pADC, uint8_t ch, ADC_INTEN_THCMP_T thInt)
N{
N	pADC->INTEN = (pADC->INTEN & ~(ADC_INTEN_RES | (3 << (3 + (ch * 2))))) | (thInt << (3 + (ch * 2)));
X	pADC->INTEN = (pADC->INTEN & ~(0xF8000000 | (3 << (3 + (ch * 2))))) | (thInt << (3 + (ch * 2)));
N}
N
N/**
N * @brief	Get flags register in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return  Flags register value (ORed ADC_FLAG* values)
N * @note	Mask the return value of this function with the ADC_FLAGS_*
N * definitions to determine the overall ADC interrupt events.<br>
N * Example:<br>
N * if (Chip_ADC_GetFlags(LPC_ADC) & ADC_FLAGS_THCMP_MASK(3) // Check of threshold comp status for ADC channel 3
N */
NSTATIC INLINE uint32_t Chip_ADC_GetFlags(LPC_ADC_T *pADC)
Xstatic __inline uint32_t Chip_ADC_GetFlags(LPC_ADC_T *pADC)
N{
N	return pADC->FLAGS;
N}
N
N/**
N * @brief	Clear flags register in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	flags	: An Or'ed values of ADC_FLAGS_* values to clear
N * @return  Flags register value (ORed ADC_FLAG* values)
N */
NSTATIC INLINE void Chip_ADC_ClearFlags(LPC_ADC_T *pADC, uint32_t flags)
Xstatic __inline void Chip_ADC_ClearFlags(LPC_ADC_T *pADC, uint32_t flags)
N{
N	pADC->FLAGS = flags;
N}
N
N/**
N * @brief	Set Trim register in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	trim	: Trim value (ADC_TRIM_VRANGE_HIGHV or ADC_TRIM_VRANGE_LOWV)
N * @return	None
N */
NSTATIC INLINE void Chip_ADC_SetTrim(LPC_ADC_T *pADC, uint32_t trim)
Xstatic __inline void Chip_ADC_SetTrim(LPC_ADC_T *pADC, uint32_t trim)
N{
N	pADC->TRM = trim;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ADC_8XX_H_ */
L 200 ".\lpc_chip_82x\inc\chip.h" 2
N#include "dma_8xx.h"
L 1 ".\lpc_chip_82x\inc\dma_8xx.h" 1
N/*
N * @brief LPC8xx DMA chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __DMA_8XX_H_
N#define __DMA_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup DMA_8XX CHIP: LPC8xx DMA Controller driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief DMA Controller shared registers structure
N */
Ntypedef struct {					/*!< DMA shared registers structure */
N	__IO uint32_t  ENABLESET;		/*!< DMA Channel Enable read and Set for all DMA channels */
X	volatile uint32_t  ENABLESET;		 
N	__I  uint32_t  RESERVED0;
X	volatile const  uint32_t  RESERVED0;
N	__O  uint32_t  ENABLECLR;		/*!< DMA Channel Enable Clear for all DMA channels */
X	volatile  uint32_t  ENABLECLR;		 
N	__I  uint32_t  RESERVED1;
X	volatile const  uint32_t  RESERVED1;
N	__I  uint32_t  ACTIVE;			/*!< DMA Channel Active status for all DMA channels */
X	volatile const  uint32_t  ACTIVE;			 
N	__I  uint32_t  RESERVED2;
X	volatile const  uint32_t  RESERVED2;
N	__I  uint32_t  BUSY;			/*!< DMA Channel Busy status for all DMA channels */
X	volatile const  uint32_t  BUSY;			 
N	__I  uint32_t  RESERVED3;
X	volatile const  uint32_t  RESERVED3;
N	__IO uint32_t  ERRINT;			/*!< DMA Error Interrupt status for all DMA channels */
X	volatile uint32_t  ERRINT;			 
N	__I  uint32_t  RESERVED4;
X	volatile const  uint32_t  RESERVED4;
N	__IO uint32_t  INTENSET;		/*!< DMA Interrupt Enable read and Set for all DMA channels */
X	volatile uint32_t  INTENSET;		 
N	__I  uint32_t  RESERVED5;
X	volatile const  uint32_t  RESERVED5;
N	__O  uint32_t  INTENCLR;		/*!< DMA Interrupt Enable Clear for all DMA channels */
X	volatile  uint32_t  INTENCLR;		 
N	__I  uint32_t  RESERVED6;
X	volatile const  uint32_t  RESERVED6;
N	__IO uint32_t  INTA;			/*!< DMA Interrupt A status for all DMA channels */
X	volatile uint32_t  INTA;			 
N	__I  uint32_t  RESERVED7;
X	volatile const  uint32_t  RESERVED7;
N	__IO uint32_t  INTB;			/*!< DMA Interrupt B status for all DMA channels */
X	volatile uint32_t  INTB;			 
N	__I  uint32_t  RESERVED8;
X	volatile const  uint32_t  RESERVED8;
N	__O  uint32_t  SETVALID;		/*!< DMA Set ValidPending control bits for all DMA channels */
X	volatile  uint32_t  SETVALID;		 
N	__I  uint32_t  RESERVED9;
X	volatile const  uint32_t  RESERVED9;
N	__O  uint32_t  SETTRIG;			/*!< DMA Set Trigger control bits for all DMA channels */
X	volatile  uint32_t  SETTRIG;			 
N	__I  uint32_t  RESERVED10;
X	volatile const  uint32_t  RESERVED10;
N	__O  uint32_t  ABORT;			/*!< DMA Channel Abort control for all DMA channels */
X	volatile  uint32_t  ABORT;			 
N} LPC_DMA_COMMON_T;
N
N/**
N * @brief DMA Controller shared registers structure
N */
Ntypedef struct {					/*!< DMA channel register structure */
N	__IO uint32_t  CFG;				/*!< DMA Configuration register */
X	volatile uint32_t  CFG;				 
N	__I  uint32_t  CTLSTAT;			/*!< DMA Control and status register */
X	volatile const  uint32_t  CTLSTAT;			 
N	__IO uint32_t  XFERCFG;			/*!< DMA Transfer configuration register */
X	volatile uint32_t  XFERCFG;			 
N	__I  uint32_t  RESERVED;
X	volatile const  uint32_t  RESERVED;
N} LPC_DMA_CHANNEL_T;
N
N/* Reserved bits masks... */
N#define DMA_CFG_RESERVED			((3<<2)|(1<<7)|(3<<12)|0xfffc0000)
N#define DMA_CTLSTAT_RESERVED		(~(1|(1<<2)))
N#define DMA_XFERCFG_RESERVED		((3<<6)|(3<<10)|(0x3fu<<26))
N
N/* DMA channel mapping - each channel is mapped to an individual peripheral
N   and direction or a DMA imput mux trigger */
Ntypedef enum {
N	DMAREQ_USART0_RX,					/*!< USART0 receive DMA channel */
N	DMA_CH0 = DMAREQ_USART0_RX,
N	DMAREQ_USART0_TX,					/*!< USART0 transmit DMA channel */
N	DMA_CH1 = DMAREQ_USART0_TX,
N	DMAREQ_USART1_RX,					/*!< USART1 receive DMA channel */
N	DMA_CH2 = DMAREQ_USART1_RX,
N	DMAREQ_USART1_TX,					/*!< USART1 transmit DMA channel */
N	DMA_CH3 = DMAREQ_USART1_TX,
N	DMAREQ_USART2_RX,					/*!< USART2 receive DMA channel */
N	DMA_CH4 = DMAREQ_USART2_RX,
N	DMAREQ_USART2_TX,					/*!< USART2 transmit DMA channel */
N	DMA_CH5 = DMAREQ_USART2_TX,
N	DMAREQ_SPI0_RX,
N	DMA_CH6 = DMAREQ_SPI0_RX,           /*!< SPI0 receive DMA channel */
N	DMAREQ_SPI0_TX,
N	DMA_CH7 = DMAREQ_SPI0_TX,           /*!< SPI0 transmit DMA channel */
N	DMAREQ_SPI1_RX,
N	DMA_CH8 = DMAREQ_SPI1_RX,           /*!< SPI1 receive DMA channel */
N	DMAREQ_SPI1_TX,
N	DMA_CH9 = DMAREQ_SPI1_TX,           /*!< SPI1 transmit DMA channel */
N	DMAREQ_I2C0_MST,
N	DMA_CH10 = DMAREQ_I2C0_MST,         /*!< I2C0 Master DMA channel */
N	DMAREQ_I2C0_SLV,
N	DMA_CH11 = DMAREQ_I2C0_SLV,         /*!< I2C0 Slave DMA channel */
N	DMAREQ_I2C1_MST,
N	DMA_CH12 = DMAREQ_I2C1_MST,         /*!< I2C1 Master DMA channel */
N	DMAREQ_I2C1_SLV,
N	DMA_CH13 = DMAREQ_I2C1_SLV,         /*!< I2C1 Slave DMA channel */
N	DMAREQ_I2C2_MST,
N	DMA_CH14 = DMAREQ_I2C2_MST,         /*!< I2C2 Master DMA channel */
N	DMAREQ_I2C2_SLV,
N	DMA_CH15 = DMAREQ_I2C2_SLV,         /*!< I2C2 Slave DMA channel */
N	DMAREQ_I2C3_MST,
N	DMA_CH16 = DMAREQ_I2C3_MST,         /*!< I2C2 Master DMA channel */
N	DMAREQ_I2C3_SLV,
N	DMA_CH17 = DMAREQ_I2C3_SLV,         /*!< I2C2 Slave DMA channel */
N} DMA_CHID_T;
N
N/* On LPC82x, Max DMA channel is 18 */
N#define MAX_DMA_CHANNEL			(DMA_CH17 + 1)
N
N/* Reserved bits masks... */
N#define DMA_COMMON_RESERVED         (~(0UL) << MAX_DMA_CHANNEL)
N#define DMA_ENABLESET_RESERVED		DMA_COMMON_RESERVED
N#define DMA_ENABLECLR_RESERVED		DMA_COMMON_RESERVED
N#define DMA_ACTIVE_RESERVED			DMA_COMMON_RESERVED
N#define DMA_BUSY_RESERVED			DMA_COMMON_RESERVED
N#define DMA_ERRINT_RESERVED			DMA_COMMON_RESERVED
N#define DMA_INTENSET_RESERVED		DMA_COMMON_RESERVED
N#define DMA_INTENCLR_RESERVED		DMA_COMMON_RESERVED
N#define DMA_INTA_RESERVED			DMA_COMMON_RESERVED
N#define DMA_INTB_RESERVED			DMA_COMMON_RESERVED
N#define DMA_SETVALID_RESERVED		DMA_COMMON_RESERVED
N#define DMA_SETTRIG_RESERVED		DMA_COMMON_RESERVED
N#define DMA_ABORT_RESERVED			DMA_COMMON_RESERVED
N
N/**
N * @brief DMA Controller register block structure
N */
Ntypedef struct {					/*!< DMA Structure */
N	__IO uint32_t  CTRL;			/*!< DMA control register */
X	volatile uint32_t  CTRL;			 
N	__I  uint32_t  INTSTAT;			/*!< DMA Interrupt status register */
X	volatile const  uint32_t  INTSTAT;			 
N	__IO uint32_t  SRAMBASE;		/*!< DMA SRAM address of the channel configuration table */
X	volatile uint32_t  SRAMBASE;		 
N	__I  uint32_t  RESERVED2[5];
X	volatile const  uint32_t  RESERVED2[5];
N	LPC_DMA_COMMON_T DMACOMMON[1];	/*!< DMA shared channel (common) registers */
N	__I  uint32_t  RESERVED0[225];
X	volatile const  uint32_t  RESERVED0[225];
N	LPC_DMA_CHANNEL_T DMACH[MAX_DMA_CHANNEL];	/*!< DMA channel registers */
X	LPC_DMA_CHANNEL_T DMACH[(DMA_CH17 + 1)];	 
N} LPC_DMA_T;
N
N/* Reserved bits masks... */
N#define DMA_CTRL_RESERVED			(~1)
N#define DMA_INTSTAT_RESERVED		(~7)
N#define DMA_SRAMBASE_RESERVED		(0xFF)
N
N/** @defgroup DMA_COMMONDRV_8XX CHIP: LPC8xx DMA Controller driver common functions
N * @{
N */
N
N/**
N * @brief	Initialize DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_Init(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_Init(LPC_DMA_T *pDMA)
N{
N	(void) pDMA;
N	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_DMA);
N}
N
N/**
N * @brief	De-Initialize DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_DeInit(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_DeInit(LPC_DMA_T *pDMA)
N{
N	(void) pDMA;
N	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_DMA);
N}
N
N/**
N * @brief	Enable DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_Enable(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_Enable(LPC_DMA_T *pDMA)
N{
N	pDMA->CTRL = 1;
N}
N
N/**
N * @brief	Disable DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_Disable(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_Disable(LPC_DMA_T *pDMA)
N{
N	pDMA->CTRL = 0;
N}
N
N/* DMA interrupt status bits (common) */
N#define DMA_INTSTAT_ACTIVEINT       0x2		/*!< Summarizes whether any enabled interrupts are pending */
N#define DMA_INTSTAT_ACTIVEERRINT    0x4		/*!< Summarizes whether any error interrupts are pending */
N
N/**
N * @brief	Get pending interrupt or error interrupts
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of DMA_INTSTAT_* types
N * @note	If any DMA channels have an active interrupt or error interrupt
N *			pending, this functional will a common status that applies to all
N *			channels.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetIntStatus(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetIntStatus(LPC_DMA_T *pDMA)
N{
N	return (pDMA->INTSTAT & ~DMA_INTSTAT_RESERVED);
X	return (pDMA->INTSTAT & ~(~7));
N}
N
N/* DMA channel source/address/next descriptor */
Ntypedef struct {
N	uint32_t  xfercfg;		/*!< Transfer configuration (only used in linked lists and ping-pong configs) */
N	uint32_t  source;		/*!< DMA transfer source end address */
N	uint32_t  dest;			/*!< DMA transfer desintation end address */
N	uint32_t  next;			/*!< Link to next DMA descriptor, must be 16 byte aligned */
N} DMA_CHDESC_T;
N
N/* DMA SRAM table - this can be optionally used with the Chip_DMA_SetSRAMBase()
N   function if a DMA SRAM table is needed. */
Nextern DMA_CHDESC_T Chip_DMA_Table[MAX_DMA_CHANNEL];
Xextern DMA_CHDESC_T Chip_DMA_Table[(DMA_CH17 + 1)];
N
N/**
N * @brief	Set DMA controller SRAM base address
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	base	: The base address where the DMA descriptors will be stored
N * @return	Nothing
N * @note	A 256 byte block of memory aligned on a 256 byte boundary must be
N *			provided for this function. It sets the base address used for
N *			DMA descriptor table (16 descriptors total that use 16 bytes each).<br>
N *
N *			A pre-defined table with correct alignment can be used for this
N *			function by calling Chip_DMA_SetSRAMBase(LPC_DMA, DMA_ADDR(Chip_DMA_Table));
N */
NSTATIC INLINE void Chip_DMA_SetSRAMBase(LPC_DMA_T *pDMA, uint32_t base)
Xstatic __inline void Chip_DMA_SetSRAMBase(LPC_DMA_T *pDMA, uint32_t base)
N{
N	pDMA->SRAMBASE = base;
N}
N
N/**
N * @brief	Returns DMA controller SRAM base address
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	The base address where the DMA descriptors are stored
N */
NSTATIC INLINE uint32_t Chip_DMA_GetSRAMBase(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetSRAMBase(LPC_DMA_T *pDMA)
N{
N	return (pDMA->SRAMBASE & ~DMA_SRAMBASE_RESERVED);
X	return (pDMA->SRAMBASE & ~(0xFF));
N}
N
N/**
N * @}
N */
N
N/** @defgroup DMA_COMMON_8XX CHIP: LPC8xx DMA Controller driver common channel functions
N * @{
N */
N
N/**
N * @brief	Enables a single DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_EnableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_EnableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ENABLESET = (1 << ch);
N}
N
N/**
N * @brief	Disables a single DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_DisableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_DisableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ENABLECLR = (1 << ch);
N}
N
N/**
N * @brief	Returns all enabled DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all enabled DMA channels (0 - 15)
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) is enabled. A low state is disabled.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetEnabledChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetEnabledChannels(LPC_DMA_T *pDMA)
N{
N	return (pDMA->DMACOMMON[0].ENABLESET & ~DMA_ENABLESET_RESERVED);
X	return (pDMA->DMACOMMON[0].ENABLESET & ~(~(0UL) << (DMA_CH17 + 1)));
N}
N
N/**
N * @brief	Returns all active DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all active DMA channels (0 - 15)
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) is active. A low state is inactive. A active
N *			channel indicates that a DMA operation has been started but
N *			not yet fully completed.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetActiveChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetActiveChannels(LPC_DMA_T *pDMA)
N{
N	return (pDMA->DMACOMMON[0].ACTIVE & ~DMA_ACTIVE_RESERVED);
X	return (pDMA->DMACOMMON[0].ACTIVE & ~(~(0UL) << (DMA_CH17 + 1)));
N}
N
N/**
N * @brief	Returns all busy DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all busy DMA channels (0 - 15)
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) is busy. A low state is not busy. A DMA
N *			channel is considered busy when there is any operation
N *			related to that channel in the DMA controllers internal
N *			pipeline.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetBusyChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetBusyChannels(LPC_DMA_T *pDMA)
N{
N	return (pDMA->DMACOMMON[0].BUSY & ~DMA_BUSY_RESERVED);
X	return (pDMA->DMACOMMON[0].BUSY & ~(~(0UL) << (DMA_CH17 + 1)));
N}
N
N/**
N * @brief	Returns pending error interrupt status for all DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all channels (0 - 15) error interrupt status
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has a pending error interrupt. A low state
N *			indicates no error interrupt.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetErrorIntChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetErrorIntChannels(LPC_DMA_T *pDMA)
N{
N	return (pDMA->DMACOMMON[0].ERRINT & ~DMA_ERRINT_RESERVED);
X	return (pDMA->DMACOMMON[0].ERRINT & ~(~(0UL) << (DMA_CH17 + 1)));
N}
N
N/**
N * @brief	Clears a pending error interrupt status for a single DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_ClearErrorIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_ClearErrorIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ERRINT = (1 << ch);
N}
N
N/**
N * @brief	Enables a single DMA channel's interrupt used in common DMA interrupt
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_EnableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_EnableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTENSET = (1 << ch);
N}
N
N/**
N * @brief	Disables a single DMA channel's interrupt used in common DMA interrupt
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_DisableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_DisableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTENCLR = (1 << ch);
N}
N
N/**
N * @brief	Returns all enabled interrupt channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has an enabled interrupt for the channel.
N *			A low state indicates that the DMA channel will not contribute
N *			to the common DMA interrupt status.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetEnableIntChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetEnableIntChannels(LPC_DMA_T *pDMA)
N{
N	return (pDMA->DMACOMMON[0].INTENSET & ~DMA_INTENSET_RESERVED);
X	return (pDMA->DMACOMMON[0].INTENSET & ~(~(0UL) << (DMA_CH17 + 1)));
N}
N
N/**
N * @brief	Returns active A interrupt status for all channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has an active A interrupt for the channel.
N *			A low state indicates that the A interrupt is not active.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetActiveIntAChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetActiveIntAChannels(LPC_DMA_T *pDMA)
N{
N	return (pDMA->DMACOMMON[0].INTA & ~DMA_INTA_RESERVED);
X	return (pDMA->DMACOMMON[0].INTA & ~(~(0UL) << (DMA_CH17 + 1)));
N}
N
N/**
N * @brief	Clears active A interrupt status for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_ClearActiveIntAChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_ClearActiveIntAChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTA = (1 << ch);
N}
N
N/**
N * @brief	Returns active B interrupt status for all channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has an active B interrupt for the channel.
N *			A low state indicates that the B interrupt is not active.
N */
NSTATIC INLINE uint32_t Chip_DMA_GetActiveIntBChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetActiveIntBChannels(LPC_DMA_T *pDMA)
N{
N	return (pDMA->DMACOMMON[0].INTB & ~DMA_INTB_RESERVED);
X	return (pDMA->DMACOMMON[0].INTB & ~(~(0UL) << (DMA_CH17 + 1)));
N}
N
N/**
N * @brief	Clears active B interrupt status for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_ClearActiveIntBChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_ClearActiveIntBChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTB = (1 << ch);
N}
N
N/**
N * @brief	Sets the VALIDPENDING control bit for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N * @note	See the User Manual for more information for what this bit does.
N *
N */
NSTATIC INLINE void Chip_DMA_SetValidChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetValidChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].SETVALID = (1 << ch);
N}
N
N/**
N * @brief	Sets the TRIG bit for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N * @note	See the User Manual for more information for what this bit does.
N */
NSTATIC INLINE void Chip_DMA_SetTrigChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetTrigChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].SETTRIG = (1 << ch);
N}
N
N/**
N * @brief	Aborts a DMA operation for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N * @note	To abort a channel, the channel should first be disabled. Then wait
N *			until the channel is no longer busy by checking the corresponding
N *			bit in BUSY. Finally, abort the channel operation. This prevents the
N *			channel from restarting an incomplete operation when it is enabled
N *			again.
N */
NSTATIC INLINE void Chip_DMA_AbortChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_AbortChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ABORT = (1 << ch);
N}
N
N/**
N * @}
N */
N
N
N/** @defgroup DMA_CHANNEL_8XX CHIP: LPC8xx DMA Controller driver channel specific functions
N * @{
N */
N
N/* Support macro for DMA_CHDESC_T */
N#define DMA_ADDR(addr)      ((uint32_t) (addr))
N
N/* Support definitions for setting the configuration of a DMA channel. You
N   will need to get more information on these options from the User manual. */
N#define DMA_CFG_PERIPHREQEN     (1 << 0)	/*!< Enables Peripheral DMA requests */
N#define DMA_CFG_HWTRIGEN        (1 << 1)	/*!< Use hardware triggering via imput mux */
N#define DMA_CFG_TRIGPOL_LOW     (0 << 4)	/*!< Hardware trigger is active low or falling edge */
N#define DMA_CFG_TRIGPOL_HIGH    (1 << 4)	/*!< Hardware trigger is active high or rising edge */
N#define DMA_CFG_TRIGTYPE_EDGE   (0 << 5)	/*!< Hardware trigger is edge triggered */
N#define DMA_CFG_TRIGTYPE_LEVEL  (1 << 5)	/*!< Hardware trigger is level triggered */
N#define DMA_CFG_TRIGBURST_SNGL  (0 << 6)	/*!< Single transfer. Hardware trigger causes a single transfer */
N#define DMA_CFG_TRIGBURST_BURST (1 << 6)	/*!< Burst transfer (see UM) */
N#define DMA_CFG_BURSTPOWER_1    (0 << 8)	/*!< Set DMA burst size to 1 transfer */
N#define DMA_CFG_BURSTPOWER_2    (1 << 8)	/*!< Set DMA burst size to 2 transfers */
N#define DMA_CFG_BURSTPOWER_4    (2 << 8)	/*!< Set DMA burst size to 4 transfers */
N#define DMA_CFG_BURSTPOWER_8    (3 << 8)	/*!< Set DMA burst size to 8 transfers */
N#define DMA_CFG_BURSTPOWER_16   (4 << 8)	/*!< Set DMA burst size to 16 transfers */
N#define DMA_CFG_BURSTPOWER_32   (5 << 8)	/*!< Set DMA burst size to 32 transfers */
N#define DMA_CFG_BURSTPOWER_64   (6 << 8)	/*!< Set DMA burst size to 64 transfers */
N#define DMA_CFG_BURSTPOWER_128  (7 << 8)	/*!< Set DMA burst size to 128 transfers */
N#define DMA_CFG_BURSTPOWER_256  (8 << 8)	/*!< Set DMA burst size to 256 transfers */
N#define DMA_CFG_BURSTPOWER_512  (9 << 8)	/*!< Set DMA burst size to 512 transfers */
N#define DMA_CFG_BURSTPOWER_1024 (10 << 8)	/*!< Set DMA burst size to 1024 transfers */
N#define DMA_CFG_BURSTPOWER(n)   ((n) << 8)	/*!< Set DMA burst size to 2^n transfers, max n=10 */
N#define DMA_CFG_SRCBURSTWRAP    (1 << 14)	/*!< Source burst wrapping is enabled for this DMA channel */
N#define DMA_CFG_DSTBURSTWRAP    (1 << 15)	/*!< Destination burst wrapping is enabled for this DMA channel */
N#define DMA_CFG_CHPRIORITY(p)   ((p) << 16)	/*!< Sets DMA channel priority, min 0 (highest), max 3 (lowest) */
N
N/**
N * @brief	Setup a DMA channel configuration
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	cfg		: An Or'ed value of DMA_CFG_* values that define the channel's configuration
N * @return	Nothing
N * @note	This function sets up all configurable options for the DMA channel.
N *			These options are usually set once for a channel and then unchanged.<br>
N *
N *			The following example show how to configure the channel for peripheral
N *			DMA requests, burst transfer size of 1 (in 'transfers', not bytes),
N *			continuous reading of the same source address, incrementing destination
N *			address, and highest channel priority.<br>
N *			Example: Chip_DMA_SetupChannelConfig(pDMA, SSP0_RX_DMA,
N *				(DMA_CFG_PERIPHREQEN | DMA_CFG_TRIGBURST_BURST | DMA_CFG_BURSTPOWER_1 |
N *				DMA_CFG_SRCBURSTWRAP | DMA_CFG_CHPRIORITY(0)));<br>
N *
N *			The following example show how to configure the channel for an external
N *			trigger from the imput mux with low edge polarity, a burst transfer size of 8,
N *			incrementing source and destination addresses, and lowest channel
N *			priority.<br>
N *			Example: Chip_DMA_SetupChannelConfig(pDMA, DMA_CH14,
N *				(DMA_CFG_HWTRIGEN | DMA_CFG_TRIGPOL_LOW | DMA_CFG_TRIGTYPE_EDGE |
N *				DMA_CFG_TRIGBURST_BURST | DMA_CFG_BURSTPOWER_8 |
N *				DMA_CFG_CHPRIORITY(3)));<br>
N *
N *			For non-peripheral DMA triggering (DMA_CFG_HWTRIGEN definition), use the
N *			DMA input mux functions to configure the DMA trigger source for a DMA channel.
N */
NSTATIC INLINE void Chip_DMA_SetupChannelConfig(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
Xstatic __inline void Chip_DMA_SetupChannelConfig(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
N{
N	pDMA->DMACH[ch].CFG = cfg;
N}
N
N/* DMA channel control and status register definitions */
N#define DMA_CTLSTAT_VALIDPENDING    (1 << 0)	/*!< Valid pending flag for this channel */
N#define DMA_CTLSTAT_TRIG            (1 << 2)	/*!< Trigger flag. Indicates that the trigger for this channel is currently set */
N
N/**
N * @brief	Returns channel specific status flags
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	AN Or'ed value of DMA_CTLSTAT_VALIDPENDING and DMA_CTLSTAT_TRIG
N */
NSTATIC INLINE uint32_t Chip_DMA_GetChannelStatus(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline uint32_t Chip_DMA_GetChannelStatus(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	return (pDMA->DMACH[ch].XFERCFG & ~DMA_XFERCFG_RESERVED);
X	return (pDMA->DMACH[ch].XFERCFG & ~((3<<6)|(3<<10)|(0x3fu<<26)));
N}
N
N/* DMA channel transfer configuration registers definitions */
N#define DMA_XFERCFG_CFGVALID        (1 << 0)	/*!< Configuration Valid flag */
N#define DMA_XFERCFG_RELOAD          (1 << 1)	/*!< Indicates whether the channels control structure will be reloaded when the current descriptor is exhausted */
N#define DMA_XFERCFG_SWTRIG          (1 << 2)	/*!< Software Trigger */
N#define DMA_XFERCFG_CLRTRIG         (1 << 3)	/*!< Clear Trigger */
N#define DMA_XFERCFG_SETINTA         (1 << 4)	/*!< Set Interrupt flag A for this channel to fire when descriptor is complete */
N#define DMA_XFERCFG_SETINTB         (1 << 5)	/*!< Set Interrupt flag B for this channel to fire when descriptor is complete */
N#define DMA_XFERCFG_WIDTH_8         (0 << 8)	/*!< 8-bit transfers are performed */
N#define DMA_XFERCFG_WIDTH_16        (1 << 8)	/*!< 16-bit transfers are performed */
N#define DMA_XFERCFG_WIDTH_32        (2 << 8)	/*!< 32-bit transfers are performed */
N#define DMA_XFERCFG_SRCINC_0        (0 << 12)	/*!< DMA source address is not incremented after a transfer */
N#define DMA_XFERCFG_SRCINC_1        (1 << 12)	/*!< DMA source address is incremented by 1 (width) after a transfer */
N#define DMA_XFERCFG_SRCINC_2        (2 << 12)	/*!< DMA source address is incremented by 2 (width) after a transfer */
N#define DMA_XFERCFG_SRCINC_4        (3 << 12)	/*!< DMA source address is incremented by 4 (width) after a transfer */
N#define DMA_XFERCFG_DSTINC_0        (0 << 14)	/*!< DMA destination address is not incremented after a transfer */
N#define DMA_XFERCFG_DSTINC_1        (1 << 14)	/*!< DMA destination address is incremented by 1 (width) after a transfer */
N#define DMA_XFERCFG_DSTINC_2        (2 << 14)	/*!< DMA destination address is incremented by 2 (width) after a transfer */
N#define DMA_XFERCFG_DSTINC_4        (3 << 14)	/*!< DMA destination address is incremented by 4 (width) after a transfer */
N#define DMA_XFERCFG_XFERCOUNT(n)    ((n - 1) << 16)	/*!< DMA transfer count in 'transfers', between (0)1 and (1023)1024 */
N
N/**
N * @brief	Setup a DMA channel transfer configuration
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	cfg		: An Or'ed value of DMA_XFERCFG_* values that define the channel's transfer configuration
N * @return	Nothing
N * @note	This function sets up the transfer configuration for the DMA channel.<br>
N *
N *			The following example show how to configure the channel's transfer for
N *			multiple transfer descriptors (ie, ping-pong), interrupt 'A' trigger on
N *			transfer descriptor completion, 128 byte size transfers, and source and
N *			destination address increment.<br>
N *			Example: Chip_DMA_SetupChannelTransfer(pDMA, SSP0_RX_DMA,
N *				(DMA_XFERCFG_CFGVALID | DMA_XFERCFG_RELOAD | DMA_XFERCFG_SETINTA |
N *				DMA_XFERCFG_WIDTH_8 | DMA_XFERCFG_SRCINC_1 | DMA_XFERCFG_DSTINC_1 |
N *				DMA_XFERCFG_XFERCOUNT(128)));<br>
N */
NSTATIC INLINE void Chip_DMA_SetupChannelTransfer(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
Xstatic __inline void Chip_DMA_SetupChannelTransfer(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
N{
N	pDMA->DMACH[ch].XFERCFG = cfg;
N}
N
N/**
N * @brief	Set DMA transfer register interrupt bits (safe)
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	mask	: Bits to set
N * @return	Nothing
N * @note	This function safely sets bits in the DMA channel specific XFERCFG
N *			register.
N */
NSTATIC INLINE void Chip_DMA_SetTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
Xstatic __inline void Chip_DMA_SetTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
N{
N	/* Read and write values may not be the same, write 0 to
N	   undefined bits */
N	pDMA->DMACH[ch].XFERCFG = (pDMA->DMACH[ch].XFERCFG & ~DMA_XFERCFG_RESERVED) | mask;
X	pDMA->DMACH[ch].XFERCFG = (pDMA->DMACH[ch].XFERCFG & ~((3<<6)|(3<<10)|(0x3fu<<26))) | mask;
N}
N
N/**
N * @brief	Clear DMA transfer register interrupt bits (safe)
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	mask	: Bits to clear
N * @return	Nothing
N * @note	This function safely clears bits in the DMA channel specific XFERCFG
N *			register.
N */
NSTATIC INLINE void Chip_DMA_ClearTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
Xstatic __inline void Chip_DMA_ClearTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
N{
N	/* Read and write values may not be the same, write 0 to
N	   undefined bits */
N	pDMA->DMACH[ch].XFERCFG &= ~(DMA_XFERCFG_RESERVED | mask);
X	pDMA->DMACH[ch].XFERCFG &= ~(((3<<6)|(3<<10)|(0x3fu<<26)) | mask);
N}
N
N/**
N * @brief	Update the transfer size in an existing DMA channel transfer configuration
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	trans	: Number of transfers to update the transfer configuration to (1 - 1023)
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_SetupChannelTransferSize(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t trans)
Xstatic __inline void Chip_DMA_SetupChannelTransferSize(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t trans)
N{
N	pDMA->DMACH[ch].XFERCFG = (pDMA->DMACH[ch].XFERCFG & ~(DMA_XFERCFG_RESERVED | (0x3FF << 16))) | DMA_XFERCFG_XFERCOUNT(trans);
X	pDMA->DMACH[ch].XFERCFG = (pDMA->DMACH[ch].XFERCFG & ~(((3<<6)|(3<<10)|(0x3fu<<26)) | (0x3FF << 16))) | ((trans - 1) << 16);
N}
N
N/**
N * @brief	Sets a DMA channel configuration as valid
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_SetChannelValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetChannelValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_CFGVALID);
X	Chip_DMA_SetTranBits(pDMA, ch, (1 << 0));
N}
N
N/**
N * @brief	Sets a DMA channel configuration as invalid
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_SetChannelInValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetChannelInValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	Chip_DMA_ClearTranBits(pDMA, ch, DMA_XFERCFG_CFGVALID);
X	Chip_DMA_ClearTranBits(pDMA, ch, (1 << 0));
N}
N
N/**
N * @brief	Performs a software trigger of the DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_DMA_SWTriggerChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SWTriggerChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_SWTRIG);
X	Chip_DMA_SetTranBits(pDMA, ch, (1 << 2));
N}
N
N/**
N * @brief	Checks if the given channel is active or not
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	1 if channel @a ch is active; 0 if channel @a ch is not active
N */
NSTATIC INLINE bool Chip_DMA_IsChannelActive(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline _Bool Chip_DMA_IsChannelActive(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	return (pDMA->DMACOMMON[0].ACTIVE & (1 << ch)) != 0;
N}
N
N/**
N * @brief	Sets up a DMA channel with the passed DMA transfer descriptor
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	desc	: Pointer to DMA transfer descriptor
N * @return	false if the DMA channel was active, otherwise true
N * @note	This function will set the DMA descriptor in the SRAM table to the
N *			the passed descriptor. This function is only meant to be used when
N *			the DMA channel is not active and can be used to setup the
N *			initial transfer for a linked list or ping-pong buffer or just a
N *			single transfer without a next descriptor.<br>
N *
N *			If using this function to write the initial transfer descriptor in
N *			a linked list or ping-pong buffer configuration, it should contain a
N *			non-NULL 'next' field pointer.
N */
NSTATIC INLINE bool Chip_DMA_SetupTranChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch, const DMA_CHDESC_T *desc)
Xstatic __inline _Bool Chip_DMA_SetupTranChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch, const DMA_CHDESC_T *desc)
N{
N	/* If channel is active return false */
N	if (Chip_DMA_IsChannelActive(pDMA, ch))
N		return false;
X		return 0;
N
N	/* Assign the descriptor to descriptor table */
N	((DMA_CHDESC_T *) (pDMA->SRAMBASE & ~DMA_SRAMBASE_RESERVED))[ch] = *desc;
X	((DMA_CHDESC_T *) (pDMA->SRAMBASE & ~(0xFF)))[ch] = *desc;
N	return true;
X	return 1;
N}
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __DMA_8XX_H_ */
L 201 ".\lpc_chip_82x\inc\chip.h" 2
N#include "inmux_8xx.h"
L 1 ".\lpc_chip_82x\inc\inmux_8xx.h" 1
N/*
N * @brief LPC8xx INPUT MUX chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __INMUX_8XX_H_
N#define __INMUX_8XX_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup INMUX_8XX CHIP: LPC8xx INPUT Mux Controller driver
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
Ntypedef struct {
N	__IO uint32_t  DMA_INMUX_INMUX[2];    /*!< DMA Trigger Input 20 & 21 PINMUX 0-1 */
X	volatile uint32_t  DMA_INMUX_INMUX[2];     
N	__O  uint32_t  RESERVED[6];           /*!< Reserved; Should not be used */
X	volatile  uint32_t  RESERVED[6];            
N	__IO uint32_t  SCT0_INMUX[4];         /*!< Input mux register for SCT0; INPUT0-3 */
X	volatile uint32_t  SCT0_INMUX[4];          
N} LPC_INMUX_T;
N
N/**
N * @brief	DMA INPUT MUX Index see Chip_INMUX_SetDMAOTrig()
N */
Ntypedef enum {
N	DMA_INMUX_0,  /*!< MUX for DMA input trigger 20 */
N	DMA_INMUX_1,  /*!< MUX for DMA input trigger 21 */
N}DMA_INMUX_T;
N
N/**
N * @brief	SCT Input Mux Index; See Chip_INMUX_SetSCTInMux()
N */
Ntypedef enum {
N	SCT_INMUX_0,   /*!< Input mux for SCT0; INPUT 0 */
N	SCT_INMUX_1,   /*!< Input mux for SCT0; INPUT 1 */
N	SCT_INMUX_2,   /*!< Input mux for SCT0; INPUT 2 */
N	SCT_INMUX_3,   /*!< Input mux for SCT0; INPUT 3 */
N} SCT_INMUX_T;
N
N/**
N * @brief	SCT INPUT triggers
N */
Ntypedef enum {
N	SCT_INP_IN0,                /*!< SCT0_IN0 selected by Pin Matrix */ /* FIXME: UM hints about changes */
N	SCT_INP_IN1,                /*!< SCT0_IN1 selected by Pin Matrix */
N	SCT_INP_IN2,                /*!< SCT0_IN2 selected by Pin Matrix */
N	SCT_INP_IN3,                /*!< SCT0_IN3 selected by Pin Matrix */
N	SCT_INP_ADC_THCMP_IRQ,      /*!< ADC Threshold compare IRQ */
N	SCT_INP_ACMP_O,             /*!< Analog comparator output */
N	SCT_INP_ARM_TXEV,           /*!< ARM TX Event */
N	SCT_INP_DEBUG_HALTED,       /*!< Debug halted event */
N} SCT_INP_T;
N
N/**
N * @brief	Select a trigger source for a DMA channel
N * @param	pINMUX	: The base of INPUT MUX register block
N * @param	imux	: Index of DMA input mux
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
NSTATIC INLINE void Chip_INMUX_SetDMAOTrig(LPC_INMUX_T *pINMUX, DMA_INMUX_T imux, DMA_CHID_T ch)
Xstatic __inline void Chip_INMUX_SetDMAOTrig(LPC_INMUX_T *pINMUX, DMA_INMUX_T imux, DMA_CHID_T ch)
N{
N	pINMUX->DMA_INMUX_INMUX[imux] = ch;
N}
N
N/**
N * @brief	Select a trigger source SCT module
N * @param	pINMUX	: The base of INPUT MUX register block
N * @param	isct	: Index of SCT input mux
N * @param	trig	: SCT Input function that will cause the trigger
N * @return	Nothing
N */
NSTATIC INLINE void Chip_INMUX_SetSCTInMux(LPC_INMUX_T *pINMUX, SCT_INMUX_T isct, SCT_INP_T trig)
Xstatic __inline void Chip_INMUX_SetSCTInMux(LPC_INMUX_T *pINMUX, SCT_INMUX_T isct, SCT_INP_T trig)
N{
N	pINMUX->SCT0_INMUX[isct] = trig;
N}
N
N/** @defgroup DMATRIGMUX_8XX CHIP: LPC8xx DMA trigger selection driver
N * @{
N */
N
N/**
N * @brief DMA trigger pin muxing structure
N */
Ntypedef struct {					/*!< DMA trigger pin muxing register structure */
N	__IO uint32_t  DMA_ITRIG_INMUX[MAX_DMA_CHANNEL];	/*!< Trigger input select register for DMA channels */
X	volatile uint32_t  DMA_ITRIG_INMUX[(DMA_CH17 + 1)];	 
N} LPC_DMATRIGMUX_T;
N
N/* DMA triggers that can mapped to DMA channels */
Ntypedef enum {
N	DMATRIG_ADC_SEQA_IRQ = 0,			/*!< ADC0 sequencer A interrupt as trigger */
N	DMATRIG_ADC_SEQB_IRQ,				/*!< ADC0 sequencer B interrupt as trigger */
N	DMATRIG_SCT0_DMA0,					/*!< SCT 0, DMA 0 as trigger */
N	DMATRIG_SCT0_DMA1,					/*!< SCT 1, DMA 1 as trigger */
N	DMATRIG_ACMP_O,						/*!< Analog comparator output */
N	DMATRIG_PINT0,						/*!< Pin interrupt 0 as trigger */
N	DMATRIG_PINT1,						/*!< Pin interrupt 1 as trigger */
N	DMATRIG_DMA_INMUX0,					/*!< DMA Trigger MUX0 */
N	DMATRIG_DMA_INMUX1,					/*!< DMA Trigger MUX1 */
N} DMA_TRIGSRC_T;
N
N/**
N * @brief	Select a trigger source for a DMA channel
N * @param	pDMATRIG	: The base of DMA trigger setup block on the chip
N * @param	ch			: DMA channel ID
N * @param	trig		: Trigger source for the DMA channel
N * @return	Nothing
N * @note	A DMA trigger source only needs to be setup when the DMA is setup
N *			for hardware trigger mode (when Chip_DMA_SetupChannelConfig() is
N *			called with DMA_CFG_HWTRIGEN as OR'ed option).
N */
NSTATIC INLINE void Chip_DMATRIGMUX_SetInputTrig(LPC_DMATRIGMUX_T *pDMATRIG, DMA_CHID_T ch, DMA_TRIGSRC_T trig)
Xstatic __inline void Chip_DMATRIGMUX_SetInputTrig(LPC_DMATRIGMUX_T *pDMATRIG, DMA_CHID_T ch, DMA_TRIGSRC_T trig)
N{
N	pDMATRIG->DMA_ITRIG_INMUX[ch] = (uint32_t) trig;
N}
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __INMUX_8XX_H_ */
L 202 ".\lpc_chip_82x\inc\chip.h" 2
N#endif
N
N/** @defgroup SUPPORT_8XX_FUNC CHIP: LPC8xx support functions
N * @ingroup CHIP_8XX_Drivers
N * @{
N */
N
N/**
N * @brief	Current system clock rate, mainly used for sysTick
N */
Nextern uint32_t SystemCoreClock;
N
N/**
N * @brief	Update system core clock rate, should be called if the
N *			system has a clock rate change
N * @return	None
N */
Nvoid SystemCoreClockUpdate(void);
N
N/**
N * @brief	Set up and initialize hardware prior to call to main()
N * @return	None
N * @note	Chip_SystemInit() is called prior to the application and sets up
N * system clocking prior to the application starting.
N */
Nvoid Chip_SystemInit(void);
N
N/**
N * @brief	Clock and PLL initialization based on the external oscillator
N * @return	None
N * @note	This function assumes an external crystal oscillator
N * frequency of 12MHz.
N */
Nvoid Chip_SetupXtalClocking(void);
N
N/**
N * @brief	Clock and PLL initialization based on the internal oscillator
N * @return	None
N */
Nvoid Chip_SetupIrcClocking(void);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CHIP_H_ */
L 33 "lpc_chip_82x\src\spi_8xx.c" 2
N
N/*****************************************************************************
N * Private types/enumerations/variables
N ****************************************************************************/
N
N/*****************************************************************************
N * Public types/enumerations/variables
N ****************************************************************************/
N
N/*****************************************************************************
N * Private functions
N ****************************************************************************/
N
NSTATIC void SPI_Send_Data_RxIgnore(LPC_SPI_T *pSPI,
Xstatic void SPI_Send_Data_RxIgnore(LPC_SPI_T *pSPI,
N								   SPI_DATA_SETUP_T *pXfSetup)
N{
N	if (pXfSetup->TxCnt == (pXfSetup->Length - 1)) {
N		Chip_SPI_SendLastFrame_RxIgnore(pSPI, pXfSetup->pTx[pXfSetup->TxCnt], pXfSetup->DataSize);
N	}
N	else {
N		Chip_SPI_SendMidFrame(pSPI, pXfSetup->pTx[pXfSetup->TxCnt]);
N	}
N
N	pXfSetup->TxCnt++;
N}
N
NSTATIC void SPI_Send_Data(LPC_SPI_T *pSPI,
Xstatic void SPI_Send_Data(LPC_SPI_T *pSPI,
N						  SPI_DATA_SETUP_T *pXfSetup)
N{
N	if (pXfSetup->TxCnt == (pXfSetup->Length - 1)) {
N		Chip_SPI_SendLastFrame(pSPI, pXfSetup->pTx[pXfSetup->TxCnt], pXfSetup->DataSize);
N	}
N	else {
N		Chip_SPI_SendMidFrame(pSPI, pXfSetup->pTx[pXfSetup->TxCnt]);
N	}
N
N	pXfSetup->TxCnt++;
N}
N
NSTATIC void SPI_Send_Dummy(LPC_SPI_T *pSPI,
Xstatic void SPI_Send_Dummy(LPC_SPI_T *pSPI,
N						   SPI_DATA_SETUP_T *pXfSetup)
N{
N	if (pXfSetup->RxCnt == (pXfSetup->Length - 1)) {
N		Chip_SPI_SendLastFrame(pSPI, 0x55, pXfSetup->DataSize);
N	}
N	else {
N		Chip_SPI_SendMidFrame(pSPI, 0x55);
N	}
N}
N
NSTATIC void SPI_Receive_Data(LPC_SPI_T *pSPI,
Xstatic void SPI_Receive_Data(LPC_SPI_T *pSPI,
N							 SPI_DATA_SETUP_T *pXfSetup)
N{
N	pXfSetup->pRx[pXfSetup->RxCnt] = Chip_SPI_ReceiveFrame(pSPI);
N	pXfSetup->RxCnt++;
N}
N
N/*****************************************************************************
N * Public functions
N ****************************************************************************/
N
N/* Calculate the Clock Rate Divider for SPI Peripheral */
Nuint32_t Chip_SPI_CalClkRateDivider(LPC_SPI_T *pSPI, uint32_t bitRate)
N{
N	uint32_t SPIClk;
N	uint32_t DivVal = 1;
N
N	/* Get SPI clock rate */
N	SPIClk = Chip_Clock_GetSystemClockRate();	/*The peripheral clock for both SPIs is the system clock*/
N
N	DivVal = SPIClk / bitRate;
N
N	return DivVal;
N}
N
N/* Configure SPI Delay parameters */
Nvoid Chip_SPI_DelayConfig(LPC_SPI_T *pSPI, SPI_DELAY_CONFIG_T *pConfig)
N{
N	uint32_t delayValue = SPI_DLY_PRE_DELAY(pConfig->PreDelay) |
X	uint32_t delayValue = (((pConfig->PreDelay) & 0x0F) << 0) |
N		SPI_DLY_POST_DELAY(pConfig->PostDelay)                 |
X		(((pConfig->PostDelay) & 0x0F) << 4)                 |
N		SPI_DLY_FRAME_DELAY(pConfig->FrameDelay);
X		(((pConfig->FrameDelay) & 0x0F) << 8);
N	if (pConfig->TransferDelay) {
N		delayValue |= SPI_DLY_TRANSFER_DELAY(pConfig->TransferDelay - 1);
X		delayValue |= (((pConfig->TransferDelay - 1) & 0x0F) << 12);
N	}
N	pSPI->DLY = delayValue;
N}
N
N/* Disable/Enable Interrupt */
Nvoid Chip_SPI_Int_Cmd(LPC_SPI_T *pSPI, uint32_t IntMask, FunctionalState NewState)
N{
N	if (NewState ==  ENABLE) {
N		pSPI->INTENSET = IntMask;
N	}
N	else {
N		pSPI->INTENCLR = IntMask;
N	}
N}
N
N/*Send and Receive SPI Data  */
Nuint32_t Chip_SPI_RWFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
N{
N	uint32_t Status;
N	/* Clear status */
N	Chip_SPI_ClearStatus(pSPI, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);
X	Chip_SPI_ClearStatus(pSPI, ((uint32_t) (1 << 2)) | ((uint32_t) (1 << 3)) | ((uint32_t) (1 << 4)) | ((uint32_t) (1 << 5)));
N	Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, SPI_TXCTL_ASSERT_SSEL | SPI_TXCTL_EOF);
X	Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, (0 << 16) | (1 << 21));
N	pXfSetup->TxCnt = pXfSetup->RxCnt = 0;
N	while ((pXfSetup->TxCnt < pXfSetup->Length) ||
N		   (pXfSetup->RxCnt < pXfSetup->Length)) {
N		Status = Chip_SPI_GetStatus(pSPI);
N
N		/* In case of TxReady */
N		if ((Status & SPI_STAT_TXRDY) && (pXfSetup->TxCnt < pXfSetup->Length)) {
X		if ((Status & (1 << 1)) && (pXfSetup->TxCnt < pXfSetup->Length)) {
N			SPI_Send_Data(pSPI, pXfSetup);
N		}
N
N		/*In case of Rx ready */
N		if ((Status & SPI_STAT_RXRDY) && (pXfSetup->RxCnt < pXfSetup->Length)) {
X		if ((Status & (1 << 0)) && (pXfSetup->RxCnt < pXfSetup->Length)) {
N			SPI_Receive_Data(pSPI, pXfSetup);
N		}
N	}
N	/* Check error */
N	if (Chip_SPI_GetStatus(pSPI) & (SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR)) {
X	if (Chip_SPI_GetStatus(pSPI) & (((uint32_t) (1 << 2)) | ((uint32_t) (1 << 3)))) {
N		return 0;
N	}
N	return pXfSetup->TxCnt;
N}
N
Nuint32_t Chip_SPI_WriteFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
N{
N	/* Clear status */
N	Chip_SPI_ClearStatus(pSPI, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);
X	Chip_SPI_ClearStatus(pSPI, ((uint32_t) (1 << 2)) | ((uint32_t) (1 << 3)) | ((uint32_t) (1 << 4)) | ((uint32_t) (1 << 5)));
N	Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, SPI_TXCTL_ASSERT_SSEL | SPI_TXCTL_EOF | SPI_TXCTL_RXIGNORE);
X	Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, (0 << 16) | (1 << 21) | (1 << 22));
N	pXfSetup->TxCnt = pXfSetup->RxCnt = 0;
N	while (pXfSetup->TxCnt < pXfSetup->Length) {
N		/* Wait for TxReady */
N		while (!(Chip_SPI_GetStatus(pSPI) & SPI_STAT_TXRDY)) {}
X		while (!(Chip_SPI_GetStatus(pSPI) & (1 << 1))) {}
N
N		SPI_Send_Data_RxIgnore(pSPI, pXfSetup);
N
N	}
N
N	/* Make sure the last frame sent completely*/
N	while (!(Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSD)) {}
X	while (!(Chip_SPI_GetStatus(pSPI) & (1 << 5))) {}
N	Chip_SPI_ClearStatus(pSPI, SPI_STAT_CLR_SSD);
X	Chip_SPI_ClearStatus(pSPI, ((uint32_t) (1 << 5)));
N
N	/* Check overrun error */
N	if (Chip_SPI_GetStatus(pSPI) & SPI_STAT_CLR_TXUR) {
X	if (Chip_SPI_GetStatus(pSPI) & ((uint32_t) (1 << 3))) {
N		return 0;
N	}
N	return pXfSetup->TxCnt;
N}
N
Nuint32_t Chip_SPI_ReadFrames_Blocking(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
N{
N	/* Clear status */
N	Chip_SPI_ClearStatus(pSPI, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);
X	Chip_SPI_ClearStatus(pSPI, ((uint32_t) (1 << 2)) | ((uint32_t) (1 << 3)) | ((uint32_t) (1 << 4)) | ((uint32_t) (1 << 5)));
N	Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, SPI_TXCTL_ASSERT_SSEL | SPI_TXCTL_EOF);
X	Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, (0 << 16) | (1 << 21));
N	pXfSetup->TxCnt = pXfSetup->RxCnt = 0;
N	while (pXfSetup->RxCnt < pXfSetup->Length) {
N		/* Wait for TxReady */
N		while (!(Chip_SPI_GetStatus(pSPI) & SPI_STAT_TXRDY)) {}
X		while (!(Chip_SPI_GetStatus(pSPI) & (1 << 1))) {}
N
N		SPI_Send_Dummy(pSPI, pXfSetup);
N
N		/* Wait for receive data */
N		while (!(Chip_SPI_GetStatus(pSPI) & SPI_STAT_RXRDY)) {}
X		while (!(Chip_SPI_GetStatus(pSPI) & (1 << 0))) {}
N
N		SPI_Receive_Data(pSPI, pXfSetup);
N
N	}
N	/* Check overrun error */
N	if (Chip_SPI_GetStatus(pSPI) & (SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR)) {
X	if (Chip_SPI_GetStatus(pSPI) & (((uint32_t) (1 << 2)) | ((uint32_t) (1 << 3)))) {
N		return 0;
N	}
N	return pXfSetup->RxCnt;
N}
N
N/* SPI Interrupt Read/Write with 8-bit frame width */
NStatus Chip_SPI_Int_RWFrames(LPC_SPI_T *pSPI, SPI_DATA_SETUP_T *pXfSetup)
N{
N	uint32_t Status;
N
N	Status = Chip_SPI_GetStatus(pSPI);
N	/* Check  error in INTSTAT register */
N	if (Status & (SPI_STAT_RXOV | SPI_STAT_TXUR)) {
X	if (Status & ((1 << 2) | (1 << 3))) {
N		return ERROR;
N	}
N
N	if (pXfSetup->TxCnt == 0) {
N		Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, SPI_TXCTL_ASSERT_SSEL | SPI_TXCTL_EOF);
X		Chip_SPI_SetControlInfo(pSPI, pXfSetup->DataSize, (0 << 16) | (1 << 21));
N	}
N
N	if (pXfSetup->pRx == NULL) {
X	if (pXfSetup->pRx == ((void *) 0)) {
N		if ((Status & SPI_STAT_TXRDY) && (pXfSetup->TxCnt < pXfSetup->Length)) {
X		if ((Status & (1 << 1)) && (pXfSetup->TxCnt < pXfSetup->Length)) {
N			SPI_Send_Data_RxIgnore(pSPI, pXfSetup);
N		}
N	}
N	else {
N		/* check if Tx ready */
N		if ((Status & SPI_STAT_TXRDY) && (pXfSetup->TxCnt < pXfSetup->Length)) {
X		if ((Status & (1 << 1)) && (pXfSetup->TxCnt < pXfSetup->Length)) {
N			SPI_Send_Data(pSPI, pXfSetup);
N		}
N
N		/* check if RX FIFO contains data */
N		if ((Status & SPI_STAT_RXRDY) && (pXfSetup->RxCnt < pXfSetup->Length)) {
X		if ((Status & (1 << 0)) && (pXfSetup->RxCnt < pXfSetup->Length)) {
N			SPI_Receive_Data(pSPI, pXfSetup);
N		}
N	}
N
N	return SUCCESS;
N}
