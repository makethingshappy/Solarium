; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\spim_8xx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spim_8xx.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\spim_8xx.crf lpc_chip_82x\src\spim_8xx.c]
                          THUMB

                          AREA ||i.Chip_SPIM_AssertSSEL||, CODE, READONLY, ALIGN=2

                  Chip_SPIM_AssertSSEL PROC
;;;90     /* Assert a SPI select */
;;;91     void Chip_SPIM_AssertSSEL(LPC_SPI_T *pSPI, uint8_t sselNum)
000000  b510              PUSH     {r4,lr}
;;;92     {
;;;93     	uint32_t reg;
;;;94     
;;;95     	reg = pSPI->TXCTRL & SPI_TXDATCTL_CTRLMASK;
000002  6a03              LDR      r3,[r0,#0x20]
000004  4c05              LDR      r4,|L1.28|
000006  4023              ANDS     r3,r3,r4
000008  461a              MOV      r2,r3
;;;96     
;;;97     	/* Assert a SSEL line by driving it low */
;;;98     	reg &= ~SPI_TXDATCTL_DEASSERTNUM_SSEL(sselNum);
00000a  460b              MOV      r3,r1
00000c  3310              ADDS     r3,r3,#0x10
00000e  2401              MOVS     r4,#1
000010  409c              LSLS     r4,r4,r3
000012  4613              MOV      r3,r2
000014  43a3              BICS     r3,r3,r4
000016  461a              MOV      r2,r3
;;;99     
;;;100    	pSPI->TXCTRL = reg;
000018  6202              STR      r2,[r0,#0x20]
;;;101    }
00001a  bd10              POP      {r4,pc}
;;;102    
                          ENDP

                  |L1.28|
                          DCD      0x0f710000

                          AREA ||i.Chip_SPIM_DeAssertSSEL||, CODE, READONLY, ALIGN=2

                  Chip_SPIM_DeAssertSSEL PROC
;;;103    /* Deassert a SPI select */
;;;104    void Chip_SPIM_DeAssertSSEL(LPC_SPI_T *pSPI, uint8_t sselNum)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106    	uint32_t reg;
;;;107    
;;;108    	reg = pSPI->TXCTRL & SPI_TXDATCTL_CTRLMASK;
000002  6a03              LDR      r3,[r0,#0x20]
000004  4c04              LDR      r4,|L2.24|
000006  4023              ANDS     r3,r3,r4
000008  461a              MOV      r2,r3
;;;109    	pSPI->TXCTRL = reg | SPI_TXDATCTL_DEASSERTNUM_SSEL(sselNum);
00000a  460c              MOV      r4,r1
00000c  3410              ADDS     r4,r4,#0x10
00000e  2301              MOVS     r3,#1
000010  40a3              LSLS     r3,r3,r4
000012  4313              ORRS     r3,r3,r2
000014  6203              STR      r3,[r0,#0x20]
;;;110    }
000016  bd10              POP      {r4,pc}
;;;111    
                          ENDP

                  |L2.24|
                          DCD      0x0f710000

                          AREA ||i.Chip_SPIM_DelayConfig||, CODE, READONLY, ALIGN=1

                  Chip_SPIM_DelayConfig PROC
;;;81     /* Configure SPI Delay parameters */
;;;82     void Chip_SPIM_DelayConfig(LPC_SPI_T *pSPI, SPIM_DELAY_CONFIG_T *pConfig)
000000  780a              LDRB     r2,[r1,#0]
;;;83     {
;;;84     	pSPI->DLY = (SPI_DLY_PRE_DELAY(pConfig->PreDelay) |
000002  0712              LSLS     r2,r2,#28
000004  0f12              LSRS     r2,r2,#28
000006  784b              LDRB     r3,[r1,#1]
000008  071b              LSLS     r3,r3,#28
00000a  0e1b              LSRS     r3,r3,#24
00000c  431a              ORRS     r2,r2,r3
00000e  788b              LDRB     r3,[r1,#2]
000010  071b              LSLS     r3,r3,#28
000012  0d1b              LSRS     r3,r3,#20
000014  431a              ORRS     r2,r2,r3
000016  78cb              LDRB     r3,[r1,#3]
000018  1e5b              SUBS     r3,r3,#1
00001a  071b              LSLS     r3,r3,#28
00001c  0c1b              LSRS     r3,r3,#16
00001e  431a              ORRS     r2,r2,r3
000020  6042              STR      r2,[r0,#4]
;;;85     				 SPI_DLY_POST_DELAY(pConfig->PostDelay) |
;;;86     				 SPI_DLY_FRAME_DELAY(pConfig->FrameDelay) |
;;;87     				 SPI_DLY_TRANSFER_DELAY(pConfig->TransferDelay - 1));
;;;88     }
000022  4770              BX       lr
;;;89     
                          ENDP


                          AREA ||i.Chip_SPIM_GetClockRate||, CODE, READONLY, ALIGN=1

                  Chip_SPIM_GetClockRate PROC
;;;52     /* Get SPI master bit rate */
;;;53     uint32_t Chip_SPIM_GetClockRate(LPC_SPI_T *pSPI)
000000  b570              PUSH     {r4-r6,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55     	return Chip_Clock_GetSystemClockRate() / ((pSPI->DIV & ~SPI_DIV_RESERVED) + 1);
000004  f7fffffe          BL       Chip_Clock_GetSystemClockRate
000008  4605              MOV      r5,r0
00000a  6a60              LDR      r0,[r4,#0x24]
00000c  b280              UXTH     r0,r0
00000e  1c41              ADDS     r1,r0,#1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       __aeabi_uidivmod
;;;56     }
000016  bd70              POP      {r4-r6,pc}
;;;57     
                          ENDP


                          AREA ||i.Chip_SPIM_SetClockRate||, CODE, READONLY, ALIGN=1

                  Chip_SPIM_SetClockRate PROC
;;;58     /* Set SPI master bit rate */
;;;59     uint32_t Chip_SPIM_SetClockRate(LPC_SPI_T *pSPI, uint32_t rate)
000000  b5f8              PUSH     {r3-r7,lr}
;;;60     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;61     	uint32_t baseClock, div;
;;;62     
;;;63     	/* Get peripheral base clock rate */
;;;64     	baseClock = Chip_Clock_GetSystemClockRate();
000006  f7fffffe          BL       Chip_Clock_GetSystemClockRate
00000a  4607              MOV      r7,r0
;;;65     
;;;66     	/* Compute divider */
;;;67     	div = baseClock / rate;
00000c  4631              MOV      r1,r6
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       __aeabi_uidivmod
000014  4604              MOV      r4,r0
;;;68     
;;;69     	/* Limit values */
;;;70     	if (div == 0) {
000016  2c00              CMP      r4,#0
000018  d101              BNE      |L5.30|
;;;71     		div = 1;
00001a  2401              MOVS     r4,#1
00001c  e004              B        |L5.40|
                  |L5.30|
;;;72     	}
;;;73     	else if (div > 0x10000) {
00001e  2001              MOVS     r0,#1
000020  0400              LSLS     r0,r0,#16
000022  4284              CMP      r4,r0
000024  d900              BLS      |L5.40|
;;;74     		div = 0x10000;
000026  4604              MOV      r4,r0
                  |L5.40|
;;;75     	}
;;;76     	pSPI->DIV = div - 1;
000028  1e60              SUBS     r0,r4,#1
00002a  6268              STR      r0,[r5,#0x24]
;;;77     
;;;78     	return Chip_SPIM_GetClockRate(pSPI);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       Chip_SPIM_GetClockRate
;;;79     }
000032  bdf8              POP      {r3-r7,pc}
;;;80     
                          ENDP


                          AREA ||i.Chip_SPIM_Xfer||, CODE, READONLY, ALIGN=2

                  Chip_SPIM_Xfer PROC
;;;206    /* Start non-blocking SPI master transfer */
;;;207    void Chip_SPIM_Xfer(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;208    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;209    	/* Setup SPI master select, data length, EOT/EOF timing, and RX data ignore */
;;;210    	pSPI->TXCTRL = xfer->options | SPI_TXDATCTL_DEASSERT_ALL;
000006  210f              MOVS     r1,#0xf
000008  0409              LSLS     r1,r1,#16
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  4308              ORRS     r0,r0,r1
00000e  6228              STR      r0,[r5,#0x20]
;;;211    	Chip_SPIM_AssertSSEL(pSPI, xfer->sselNum);
000010  7e21              LDRB     r1,[r4,#0x18]
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       Chip_SPIM_AssertSSEL
;;;212    
;;;213    	/* Clear initial transfer states */
;;;214    	xfer->dataRXferred = xfer->dataTXferred = 0;
000018  2000              MOVS     r0,#0
00001a  82e0              STRH     r0,[r4,#0x16]
00001c  82a0              STRH     r0,[r4,#0x14]
;;;215    
;;;216    	/* Call main handler to start transfer */
;;;217    	xmitOn = true;
00001e  2001              MOVS     r0,#1
000020  4903              LDR      r1,|L6.48|
000022  7008              STRB     r0,[r1,#0]
;;;218    	Chip_SPIM_XferHandler(pSPI, xfer);
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       Chip_SPIM_XferHandler
;;;219    }
00002c  bd70              POP      {r4-r6,pc}
;;;220    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      xmitOn

                          AREA ||i.Chip_SPIM_XferBlocking||, CODE, READONLY, ALIGN=2

                  Chip_SPIM_XferBlocking PROC
;;;221    /* Perform blocking SPI master transfer */
;;;222    void Chip_SPIM_XferBlocking(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;224    	/* Start trasnfer */
;;;225    	Chip_SPIM_Xfer(pSPI, xfer);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       Chip_SPIM_Xfer
;;;226    
;;;227    	/* Wait for termination */
;;;228    	while (xmitOn == true) {
00000e  e003              B        |L7.24|
                  |L7.16|
;;;229    		Chip_SPIM_XferHandler(pSPI, xfer);
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       Chip_SPIM_XferHandler
                  |L7.24|
000018  4802              LDR      r0,|L7.36|
00001a  7800              LDRB     r0,[r0,#0]            ;228  ; xmitOn
00001c  2801              CMP      r0,#1                 ;228
00001e  d0f7              BEQ      |L7.16|
;;;230    	}
;;;231    }
000020  bd70              POP      {r4-r6,pc}
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      xmitOn

                          AREA ||i.Chip_SPIM_XferHandler||, CODE, READONLY, ALIGN=2

                  Chip_SPIM_XferHandler PROC
;;;112    /* SPI master transfer state change handler */
;;;113    void Chip_SPIM_XferHandler(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer)
000000  b5f8              PUSH     {r3-r7,lr}
;;;114    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;115    	uint32_t data;
;;;116    	uint8_t flen;
;;;117    
;;;118    	/* Get length of a receive value */
;;;119    	flen = ((pSPI->TXCTRL & ~SPI_TXCTRL_RESERVED) >> 24) & 0xF;
000006  6a28              LDR      r0,[r5,#0x20]
000008  4947              LDR      r1,|L8.296|
00000a  4008              ANDS     r0,r0,r1
00000c  0e07              LSRS     r7,r0,#24
;;;120    
;;;121    	/* Master asserts slave */
;;;122    	if ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSA) != 0) {
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       Chip_SPI_GetStatus
000014  2110              MOVS     r1,#0x10
000016  4008              ANDS     r0,r0,r1
000018  2800              CMP      r0,#0
00001a  d006              BEQ      |L8.42|
;;;123    		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSA);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       Chip_SPI_ClearStatus
;;;124    
;;;125    		/* SSEL assertion callback */
;;;126    		xfer->pCB->masterXferCSAssert(xfer);
000022  6820              LDR      r0,[r4,#0]
000024  6801              LDR      r1,[r0,#0]
000026  4620              MOV      r0,r4
000028  4788              BLX      r1
                  |L8.42|
;;;127    	}
;;;128    
;;;129    	/* Slave de-assertion */
;;;130    	if ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSD) != 0) {
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       Chip_SPI_GetStatus
000030  2120              MOVS     r1,#0x20
000032  4008              ANDS     r0,r0,r1
000034  2800              CMP      r0,#0
000036  d00a              BEQ      |L8.78|
;;;131    		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSD);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       Chip_SPI_ClearStatus
;;;132    
;;;133    		/* If transmitter disabled and deassert happens, the transfer is done */
;;;134    		if (xmitOn == false) {
00003e  483b              LDR      r0,|L8.300|
000040  7800              LDRB     r0,[r0,#0]  ; xmitOn
000042  2800              CMP      r0,#0
000044  d103              BNE      |L8.78|
;;;135    			xfer->pCB->mMasterXferDone(xfer);
000046  6820              LDR      r0,[r4,#0]
000048  6901              LDR      r1,[r0,#0x10]
00004a  4620              MOV      r0,r4
00004c  4788              BLX      r1
                  |L8.78|
;;;136    		}
;;;137    	}
;;;138    
;;;139    	/* Transmit data? */
;;;140    	while (((Chip_SPI_GetStatus(pSPI) & SPI_STAT_TXRDY) != 0) && (xmitOn == true)) {
00004e  e032              B        |L8.182|
                  |L8.80|
;;;141    		if ((xfer->txCount == 1) && (xfer->terminate)) {
000050  8a60              LDRH     r0,[r4,#0x12]
000052  2801              CMP      r0,#1
000054  d10a              BNE      |L8.108|
000056  7e60              LDRB     r0,[r4,#0x19]
000058  2800              CMP      r0,#0
00005a  d007              BEQ      |L8.108|
;;;142    			/* Transfer is done, this will be last data */
;;;143    			Chip_SPIM_ForceEndOfTransfer(pSPI);
00005c  bf00              NOP      
00005e  2080              MOVS     r0,#0x80
000060  60a8              STR      r0,[r5,#8]
000062  bf00              NOP      
;;;144    			xmitOn = false;
000064  2000              MOVS     r0,#0
000066  4931              LDR      r1,|L8.300|
000068  7008              STRB     r0,[r1,#0]
00006a  e006              B        |L8.122|
                  |L8.108|
;;;145    		}
;;;146    		else if (xfer->txCount == 0) {
00006c  8a60              LDRH     r0,[r4,#0x12]
00006e  2800              CMP      r0,#0
000070  d103              BNE      |L8.122|
;;;147    			/* Request a new buffer first */
;;;148    			xfer->pCB->masterXferSend(xfer);
000072  6820              LDR      r0,[r4,#0]
000074  6841              LDR      r1,[r0,#4]
000076  4620              MOV      r0,r4
000078  4788              BLX      r1
                  |L8.122|
;;;149    		}
;;;150    
;;;151    		if (xfer->txCount > 0) {
00007a  8a60              LDRH     r0,[r4,#0x12]
00007c  2800              CMP      r0,#0
00007e  dd1a              BLE      |L8.182|
;;;152    			/* Send 0 if ignoring transmit */
;;;153    			if (xfer->pTXData8 == NULL) {
000080  68a0              LDR      r0,[r4,#8]
000082  2800              CMP      r0,#0
000084  d101              BNE      |L8.138|
;;;154    				data = 0;
000086  2600              MOVS     r6,#0
000088  e00f              B        |L8.170|
                  |L8.138|
;;;155    			}
;;;156    			else {
;;;157    				/* Copy buffer to data */
;;;158    				if (flen > 8) {
00008a  2f08              CMP      r7,#8
00008c  dd05              BLE      |L8.154|
;;;159    					data = (uint32_t) *xfer->pTXData16;
00008e  68a0              LDR      r0,[r4,#8]
000090  8806              LDRH     r6,[r0,#0]
;;;160    					xfer->pTXData16++;
000092  68a0              LDR      r0,[r4,#8]
000094  1c80              ADDS     r0,r0,#2
000096  60a0              STR      r0,[r4,#8]
000098  e004              B        |L8.164|
                  |L8.154|
;;;161    				}
;;;162    				else {
;;;163    					data = (uint32_t) *xfer->pTXData8;
00009a  68a0              LDR      r0,[r4,#8]
00009c  7806              LDRB     r6,[r0,#0]
;;;164    					xfer->pTXData8++;
00009e  68a0              LDR      r0,[r4,#8]
0000a0  1c40              ADDS     r0,r0,#1
0000a2  60a0              STR      r0,[r4,#8]
                  |L8.164|
;;;165    				}
;;;166    
;;;167    				xfer->dataTXferred++;
0000a4  8ae0              LDRH     r0,[r4,#0x16]
0000a6  1c40              ADDS     r0,r0,#1
0000a8  82e0              STRH     r0,[r4,#0x16]
                  |L8.170|
;;;168    			}
;;;169    
;;;170    			Chip_SPI_WriteTXData(pSPI, data);
0000aa  b2b0              UXTH     r0,r6
0000ac  61e8              STR      r0,[r5,#0x1c]
0000ae  bf00              NOP      
;;;171    			xfer->txCount--;
0000b0  8a60              LDRH     r0,[r4,#0x12]
0000b2  1e40              SUBS     r0,r0,#1
0000b4  8260              STRH     r0,[r4,#0x12]
                  |L8.182|
0000b6  4628              MOV      r0,r5                 ;140
0000b8  f7fffffe          BL       Chip_SPI_GetStatus
0000bc  2102              MOVS     r1,#2                 ;140
0000be  4008              ANDS     r0,r0,r1              ;140
0000c0  2800              CMP      r0,#0                 ;140
0000c2  d003              BEQ      |L8.204|
0000c4  4819              LDR      r0,|L8.300|
0000c6  7800              LDRB     r0,[r0,#0]            ;140  ; xmitOn
0000c8  2801              CMP      r0,#1                 ;140
0000ca  d0c1              BEQ      |L8.80|
                  |L8.204|
;;;172    		}
;;;173    	}
;;;174    
;;;175    	/* Data received? */
;;;176    	while ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_RXRDY) != 0) {
0000cc  e024              B        |L8.280|
                  |L8.206|
;;;177    		/* Get raw data and status */
;;;178    		data = Chip_SPI_ReadRawRXFifo(pSPI);
0000ce  bf00              NOP      
0000d0  6968              LDR      r0,[r5,#0x14]
0000d2  4917              LDR      r1,|L8.304|
0000d4  4008              ANDS     r0,r0,r1
0000d6  4606              MOV      r6,r0
;;;179    
;;;180    		/* Only copy data when not ignoring receive */
;;;181    		if (xfer->pRXData8 != NULL) {
0000d8  6860              LDR      r0,[r4,#4]
0000da  2800              CMP      r0,#0
0000dc  d01c              BEQ      |L8.280|
;;;182    			/* Enough size in current buffers? */
;;;183    			if (xfer->rxCount == 0) {
0000de  8a20              LDRH     r0,[r4,#0x10]
0000e0  2800              CMP      r0,#0
0000e2  d103              BNE      |L8.236|
;;;184    				/* Request a new buffer first */
;;;185    				xfer->pCB->masterXferRecv(xfer);
0000e4  6820              LDR      r0,[r4,#0]
0000e6  6881              LDR      r1,[r0,#8]
0000e8  4620              MOV      r0,r4
0000ea  4788              BLX      r1
                  |L8.236|
;;;186    			}
;;;187    
;;;188    			/* Copy data to buffer */
;;;189    			if (xfer->rxCount > 0) {
0000ec  8a20              LDRH     r0,[r4,#0x10]
0000ee  2800              CMP      r0,#0
0000f0  dd12              BLE      |L8.280|
;;;190    				if (flen > 8) {
0000f2  2f08              CMP      r7,#8
0000f4  dd05              BLE      |L8.258|
;;;191    					*xfer->pRXData16 = (uint16_t) (data & 0xFFFF);
0000f6  6861              LDR      r1,[r4,#4]
0000f8  800e              STRH     r6,[r1,#0]
;;;192    					xfer->pRXData16++;
0000fa  6860              LDR      r0,[r4,#4]
0000fc  1c80              ADDS     r0,r0,#2
0000fe  6060              STR      r0,[r4,#4]
000100  e004              B        |L8.268|
                  |L8.258|
;;;193    				}
;;;194    				else {
;;;195    					*xfer->pRXData8 = (uint8_t) (data & 0xFF);
000102  6861              LDR      r1,[r4,#4]
000104  700e              STRB     r6,[r1,#0]
;;;196    					xfer->pRXData8++;
000106  6860              LDR      r0,[r4,#4]
000108  1c40              ADDS     r0,r0,#1
00010a  6060              STR      r0,[r4,#4]
                  |L8.268|
;;;197    				}
;;;198    
;;;199    				xfer->dataRXferred++;
00010c  8aa0              LDRH     r0,[r4,#0x14]
00010e  1c40              ADDS     r0,r0,#1
000110  82a0              STRH     r0,[r4,#0x14]
;;;200    				xfer->rxCount--;
000112  8a20              LDRH     r0,[r4,#0x10]
000114  1e40              SUBS     r0,r0,#1
000116  8220              STRH     r0,[r4,#0x10]
                  |L8.280|
000118  4628              MOV      r0,r5                 ;176
00011a  f7fffffe          BL       Chip_SPI_GetStatus
00011e  07c0              LSLS     r0,r0,#31             ;176
000120  0fc0              LSRS     r0,r0,#31             ;176
000122  2800              CMP      r0,#0                 ;176
000124  d1d3              BNE      |L8.206|
;;;201    			}
;;;202    		}
;;;203    	}
;;;204    }
000126  bdf8              POP      {r3-r7,pc}
;;;205    
                          ENDP

                  |L8.296|
                          DCD      0x0f710000
                  |L8.300|
                          DCD      xmitOn
                  |L8.304|
                          DCD      0x0011ffff

                          AREA ||i.Chip_SPI_ClearStatus||, CODE, READONLY, ALIGN=1

                  Chip_SPI_ClearStatus PROC
;;;408     */
;;;409    STATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
000000  6081              STR      r1,[r0,#8]
;;;410    {
;;;411    	pSPI->STAT = Flag;
;;;412    }
000002  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.Chip_SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  Chip_SPI_GetStatus PROC
;;;395     */
;;;396    STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
000000  4601              MOV      r1,r0
;;;397    {
;;;398    	return pSPI->STAT & ~SPI_STAT_RESERVED;
000002  6888              LDR      r0,[r1,#8]
000004  05c0              LSLS     r0,r0,#23
000006  0dc0              LSRS     r0,r0,#23
;;;399    }
000008  4770              BX       lr
;;;400    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  xmitOn
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "lpc_chip_82x\\src\\spim_8xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_spim_8xx_c_dc608f0c____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___10_spim_8xx_c_dc608f0c____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_spim_8xx_c_dc608f0c____REVSH|
#line 480
|__asm___10_spim_8xx_c_dc608f0c____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
