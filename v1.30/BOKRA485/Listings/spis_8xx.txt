; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\spis_8xx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spis_8xx.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\spis_8xx.crf lpc_chip_82x\src\spis_8xx.c]
                          THUMB

                          AREA ||i.Chip_SPIS_FindSSEL||, CODE, READONLY, ALIGN=1

                  Chip_SPIS_FindSSEL PROC
;;;50     /* Determine SSEL associated with the current data value */
;;;51     static uint8_t Chip_SPIS_FindSSEL(LPC_SPI_T *pSPI, uint32_t data)
000000  b530              PUSH     {r4,r5,lr}
;;;52     {
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;53     	int i;
;;;54     	uint8_t ssel = 0;
000006  2000              MOVS     r0,#0
;;;55     
;;;56     	for (i = 0; i <= 3; i++) {
000008  2100              MOVS     r1,#0
00000a  e008              B        |L1.30|
                  |L1.12|
;;;57     		if ((data & SPI_RXDAT_RXSSELNUM_INACTIVE(i)) == 0) {
00000c  460d              MOV      r5,r1
00000e  3510              ADDS     r5,r5,#0x10
000010  2301              MOVS     r3,#1
000012  40ab              LSLS     r3,r3,r5
000014  4013              ANDS     r3,r3,r2
000016  2b00              CMP      r3,#0
000018  d100              BNE      |L1.28|
;;;58     			/* Signal is active on low */
;;;59     			ssel = (uint8_t) i;
00001a  b2c8              UXTB     r0,r1
                  |L1.28|
00001c  1c49              ADDS     r1,r1,#1              ;56
                  |L1.30|
00001e  2903              CMP      r1,#3                 ;56
000020  ddf4              BLE      |L1.12|
;;;60     		}
;;;61     	}
;;;62     
;;;63     	return ssel;
;;;64     }
000022  bd30              POP      {r4,r5,pc}
;;;65     
                          ENDP


                          AREA ||i.Chip_SPIS_XferBlocking||, CODE, READONLY, ALIGN=2

                  Chip_SPIS_XferBlocking PROC
;;;165    /* SPI slave transfer blocking function */
;;;166    uint32_t Chip_SPIS_XferBlocking(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;167    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;168    	uint32_t status = 0;
000006  2400              MOVS     r4,#0
;;;169    
;;;170    	/* Wait forever until deassertion event */
;;;171    	deasserted = false;
000008  2000              MOVS     r0,#0
00000a  4908              LDR      r1,|L2.44|
00000c  7008              STRB     r0,[r1,#0]
;;;172    	while ((!deasserted) && (status == 0)) {
00000e  e004              B        |L2.26|
                  |L2.16|
;;;173    		status = Chip_SPIS_XferHandler(pSPI, xfer);
000010  4631              MOV      r1,r6
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       Chip_SPIS_XferHandler
000018  4604              MOV      r4,r0
                  |L2.26|
00001a  4804              LDR      r0,|L2.44|
00001c  7800              LDRB     r0,[r0,#0]            ;172  ; deasserted
00001e  2800              CMP      r0,#0                 ;172
000020  d101              BNE      |L2.38|
000022  2c00              CMP      r4,#0                 ;172
000024  d0f4              BEQ      |L2.16|
                  |L2.38|
;;;174    	}
;;;175    
;;;176    	return status;
000026  4620              MOV      r0,r4
;;;177    }
000028  bd70              POP      {r4-r6,pc}
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      deasserted

                          AREA ||i.Chip_SPIS_XferHandler||, CODE, READONLY, ALIGN=2

                  Chip_SPIS_XferHandler PROC
;;;70     /* SPI slave transfer state change handler */
;;;71     uint32_t Chip_SPIS_XferHandler(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer)
000000  b5fe              PUSH     {r1-r7,lr}
;;;72     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;73     	uint32_t staterr, data;
;;;74     	uint8_t flen;
;;;75     
;;;76     	/* Get length of a receive value */
;;;77     	flen = ((pSPI->TXCTRL & ~SPI_TXCTRL_RESERVED) >> 24) & 0xF;
000006  6a28              LDR      r0,[r5,#0x20]
000008  4949              LDR      r1,|L3.304|
00000a  4008              ANDS     r0,r0,r1
00000c  0e00              LSRS     r0,r0,#24
00000e  9001              STR      r0,[sp,#4]
;;;78     
;;;79     	/* Get errors for later, we'll continue even if errors occur, but we notify
;;;80     	   caller on return */
;;;81     	staterr = Chip_SPI_GetStatus(pSPI) & (SPI_STAT_RXOV | SPI_STAT_TXUR);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       Chip_SPI_GetStatus
000016  210c              MOVS     r1,#0xc
000018  4008              ANDS     r0,r0,r1
00001a  4606              MOV      r6,r0
;;;82     	if (staterr != 0) {
00001c  2e00              CMP      r6,#0
00001e  d003              BEQ      |L3.40|
;;;83     		Chip_SPI_ClearStatus(pSPI, staterr);
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       Chip_SPI_ClearStatus
                  |L3.40|
;;;84     	}
;;;85     
;;;86     	/* Slave assertion */
;;;87     	if ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSA) != 0) {
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       Chip_SPI_GetStatus
00002e  2110              MOVS     r1,#0x10
000030  4008              ANDS     r0,r0,r1
000032  2800              CMP      r0,#0
000034  d00f              BEQ      |L3.86|
;;;88     		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSA);
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       Chip_SPI_ClearStatus
;;;89     
;;;90     		/* Determine SPI select. Read the data FIFO to get the slave number. Data
;;;91     		   should not be in the receive FIFO yet, only the statuses */
;;;92     		xfer->sselNum = Chip_SPIS_FindSSEL(pSPI, Chip_SPI_ReadRawRXFifo(pSPI));
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       Chip_SPI_ReadRawRXFifo
000042  4601              MOV      r1,r0
000044  9000              STR      r0,[sp,#0]
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       Chip_SPIS_FindSSEL
00004c  7520              STRB     r0,[r4,#0x14]
;;;93     
;;;94     		/* SSEL assertion callback */
;;;95     		xfer->pCB->slaveXferCSAssert(xfer);
00004e  6820              LDR      r0,[r4,#0]
000050  6801              LDR      r1,[r0,#0]
000052  4620              MOV      r0,r4
000054  4788              BLX      r1
                  |L3.86|
;;;96     	}
;;;97     
;;;98     	/* Slave de-assertion */
;;;99     	if ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSD) != 0) {
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       Chip_SPI_GetStatus
00005c  2120              MOVS     r1,#0x20
00005e  4008              ANDS     r0,r0,r1
000060  2800              CMP      r0,#0
000062  d009              BEQ      |L3.120|
;;;100    		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSD);
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       Chip_SPI_ClearStatus
;;;101    		deasserted = true;
00006a  2001              MOVS     r0,#1
00006c  4931              LDR      r1,|L3.308|
00006e  7008              STRB     r0,[r1,#0]
;;;102    		xfer->pCB->slaveXferCSDeAssert(xfer);
000070  6820              LDR      r0,[r4,#0]
000072  68c1              LDR      r1,[r0,#0xc]
000074  4620              MOV      r0,r4
000076  4788              BLX      r1
                  |L3.120|
;;;103    	}
;;;104    
;;;105    	/* Transmit data? */
;;;106    	while ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_TXRDY) != 0) {
000078  e026              B        |L3.200|
                  |L3.122|
;;;107    		if (xfer->txCount == 0) {
00007a  89e0              LDRH     r0,[r4,#0xe]
00007c  2800              CMP      r0,#0
00007e  d103              BNE      |L3.136|
;;;108    			/* Request a new buffer first */
;;;109    			xfer->pCB->slaveXferSend(xfer);
000080  6820              LDR      r0,[r4,#0]
000082  6841              LDR      r1,[r0,#4]
000084  4620              MOV      r0,r4
000086  4788              BLX      r1
                  |L3.136|
;;;110    		}
;;;111    
;;;112    		/* Send 0 on empty buffer or count */
;;;113    		if ((xfer->txCount == 0) || (xfer->pTXData8 == NULL)) {
000088  89e0              LDRH     r0,[r4,#0xe]
00008a  2800              CMP      r0,#0
00008c  d002              BEQ      |L3.148|
00008e  68a0              LDR      r0,[r4,#8]
000090  2800              CMP      r0,#0
000092  d101              BNE      |L3.152|
                  |L3.148|
;;;114    			data = 0;
000094  2700              MOVS     r7,#0
000096  e013              B        |L3.192|
                  |L3.152|
;;;115    		}
;;;116    		else {
;;;117    			/* Copy buffer to data */
;;;118    			if (flen > 8) {
000098  9801              LDR      r0,[sp,#4]
00009a  2808              CMP      r0,#8
00009c  dd05              BLE      |L3.170|
;;;119    				data = (uint32_t) *xfer->pTXData16;
00009e  68a0              LDR      r0,[r4,#8]
0000a0  8807              LDRH     r7,[r0,#0]
;;;120    				xfer->pTXData16++;
0000a2  68a0              LDR      r0,[r4,#8]
0000a4  1c80              ADDS     r0,r0,#2
0000a6  60a0              STR      r0,[r4,#8]
0000a8  e004              B        |L3.180|
                  |L3.170|
;;;121    			}
;;;122    			else {
;;;123    				data = (uint32_t) *xfer->pTXData8;
0000aa  68a0              LDR      r0,[r4,#8]
0000ac  7807              LDRB     r7,[r0,#0]
;;;124    				xfer->pTXData8++;
0000ae  68a0              LDR      r0,[r4,#8]
0000b0  1c40              ADDS     r0,r0,#1
0000b2  60a0              STR      r0,[r4,#8]
                  |L3.180|
;;;125    			}
;;;126    
;;;127    			xfer->dataTXferred++;
0000b4  8a60              LDRH     r0,[r4,#0x12]
0000b6  1c40              ADDS     r0,r0,#1
0000b8  8260              STRH     r0,[r4,#0x12]
;;;128    			xfer->txCount--;
0000ba  89e0              LDRH     r0,[r4,#0xe]
0000bc  1e40              SUBS     r0,r0,#1
0000be  81e0              STRH     r0,[r4,#0xe]
                  |L3.192|
;;;129    		}
;;;130    
;;;131    		Chip_SPI_WriteTXData(pSPI, data);
0000c0  b2b8              UXTH     r0,r7
0000c2  61e8              STR      r0,[r5,#0x1c]
0000c4  bf00              NOP      
0000c6  bf00              NOP      
                  |L3.200|
0000c8  4628              MOV      r0,r5                 ;106
0000ca  f7fffffe          BL       Chip_SPI_GetStatus
0000ce  2102              MOVS     r1,#2                 ;106
0000d0  4008              ANDS     r0,r0,r1              ;106
0000d2  2800              CMP      r0,#0                 ;106
0000d4  d1d1              BNE      |L3.122|
;;;132    	}
;;;133    
;;;134    	/* Data received? */
;;;135    	while ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_RXRDY) != 0) {
0000d6  e021              B        |L3.284|
                  |L3.216|
;;;136    		/* Get raw data and status */
;;;137    		data = Chip_SPI_ReadRawRXFifo(pSPI);
0000d8  4628              MOV      r0,r5
0000da  f7fffffe          BL       Chip_SPI_ReadRawRXFifo
0000de  4607              MOV      r7,r0
;;;138    
;;;139    		/* Only copy data when not ignoring receive */
;;;140    		if (xfer->pRXData8 != NULL) {
0000e0  6860              LDR      r0,[r4,#4]
0000e2  2800              CMP      r0,#0
0000e4  d01a              BEQ      |L3.284|
;;;141    			/* Enough size in current buffers? */
;;;142    			if (xfer->rxCount == 0) {
0000e6  89a0              LDRH     r0,[r4,#0xc]
0000e8  2800              CMP      r0,#0
0000ea  d103              BNE      |L3.244|
;;;143    				/* Request a new buffer first */
;;;144    				xfer->pCB->slaveXferRecv(xfer);
0000ec  6820              LDR      r0,[r4,#0]
0000ee  6881              LDR      r1,[r0,#8]
0000f0  4620              MOV      r0,r4
0000f2  4788              BLX      r1
                  |L3.244|
;;;145    			}
;;;146    
;;;147    			/* Copy data to buffer */
;;;148    			if (flen > 8) {
0000f4  9801              LDR      r0,[sp,#4]
0000f6  2808              CMP      r0,#8
0000f8  dd05              BLE      |L3.262|
;;;149    				*xfer->pRXData16 = (uint16_t) (data & 0xFFFF);
0000fa  6861              LDR      r1,[r4,#4]
0000fc  800f              STRH     r7,[r1,#0]
;;;150    				xfer->pRXData16++;
0000fe  6860              LDR      r0,[r4,#4]
000100  1c80              ADDS     r0,r0,#2
000102  6060              STR      r0,[r4,#4]
000104  e004              B        |L3.272|
                  |L3.262|
;;;151    			}
;;;152    			else {
;;;153    				*xfer->pRXData8 = (uint8_t) (data & 0xFF);
000106  6861              LDR      r1,[r4,#4]
000108  700f              STRB     r7,[r1,#0]
;;;154    				xfer->pRXData8++;
00010a  6860              LDR      r0,[r4,#4]
00010c  1c40              ADDS     r0,r0,#1
00010e  6060              STR      r0,[r4,#4]
                  |L3.272|
;;;155    			}
;;;156    
;;;157    			xfer->dataRXferred++;
000110  8a20              LDRH     r0,[r4,#0x10]
000112  1c40              ADDS     r0,r0,#1
000114  8220              STRH     r0,[r4,#0x10]
;;;158    			xfer->rxCount--;
000116  89a0              LDRH     r0,[r4,#0xc]
000118  1e40              SUBS     r0,r0,#1
00011a  81a0              STRH     r0,[r4,#0xc]
                  |L3.284|
00011c  4628              MOV      r0,r5                 ;135
00011e  f7fffffe          BL       Chip_SPI_GetStatus
000122  07c0              LSLS     r0,r0,#31             ;135
000124  0fc0              LSRS     r0,r0,#31             ;135
000126  2800              CMP      r0,#0                 ;135
000128  d1d6              BNE      |L3.216|
;;;159    		}
;;;160    	}
;;;161    
;;;162    	return staterr;
00012a  4630              MOV      r0,r6
;;;163    }
00012c  bdfe              POP      {r1-r7,pc}
;;;164    
                          ENDP

00012e  0000              DCW      0x0000
                  |L3.304|
                          DCD      0x0f710000
                  |L3.308|
                          DCD      deasserted

                          AREA ||i.Chip_SPI_ClearStatus||, CODE, READONLY, ALIGN=1

                  Chip_SPI_ClearStatus PROC
;;;408     */
;;;409    STATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
000000  6081              STR      r1,[r0,#8]
;;;410    {
;;;411    	pSPI->STAT = Flag;
;;;412    }
000002  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.Chip_SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  Chip_SPI_GetStatus PROC
;;;395     */
;;;396    STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
000000  4601              MOV      r1,r0
;;;397    {
;;;398    	return pSPI->STAT & ~SPI_STAT_RESERVED;
000002  6888              LDR      r0,[r1,#8]
000004  05c0              LSLS     r0,r0,#23
000006  0dc0              LSRS     r0,r0,#23
;;;399    }
000008  4770              BX       lr
;;;400    
                          ENDP


                          AREA ||i.Chip_SPI_ReadRawRXFifo||, CODE, READONLY, ALIGN=2

                  Chip_SPI_ReadRawRXFifo PROC
;;;475     */
;;;476    STATIC INLINE uint32_t Chip_SPI_ReadRawRXFifo(LPC_SPI_T *pSPI)
000000  4601              MOV      r1,r0
;;;477    {
;;;478    	return pSPI->RXDAT & ~SPI_RXDAT_RESERVED;
000002  6948              LDR      r0,[r1,#0x14]
000004  4a01              LDR      r2,|L6.12|
000006  4010              ANDS     r0,r0,r2
;;;479    }
000008  4770              BX       lr
;;;480    
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      0x0011ffff

                          AREA ||.data||, DATA, ALIGN=0

                  deasserted
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "lpc_chip_82x\\src\\spis_8xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_spis_8xx_c_d11d976b____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___10_spis_8xx_c_d11d976b____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_spis_8xx_c_d11d976b____REVSH|
#line 480
|__asm___10_spis_8xx_c_d11d976b____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
