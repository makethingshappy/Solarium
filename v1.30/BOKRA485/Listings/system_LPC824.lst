L 1 "lpc_chip_82x\system_LPC824.c"
N/*
N** ###################################################################
N**     Processors:          LPC824M201JDH20
N**                          LPC824M201JHI33
N**
N**     Compilers:           Keil ARM C/C++ Compiler
N**                          GNU C Compiler
N**                          IAR ANSI C/C++ Compiler for ARM
N**                          MCUXpresso Compiler
N**
N**     Reference manual:    LPC82x User manual Rev.1.2  5 October 2016
N**     Version:             rev. 1.1, 2018-02-25
N**     Build:               b180305
N**
N**     Abstract:
N**         Provides a system configuration function and a global variable that
N**         contains the system frequency. It configures the device and initializes
N**         the oscillator (PLL) that is part of the microcontroller device.
N**
N**     The Clear BSD License
N**     Copyright 2016 Freescale Semiconductor, Inc.
N**     Copyright 2016-2018 NXP
N**     All rights reserved.
N**
N**     Redistribution and use in source and binary forms, with or without
N**     modification, are permitted (subject to the limitations in the
N**     disclaimer below) provided that the following conditions are met:
N**
N**     * Redistributions of source code must retain the above copyright
N**       notice, this list of conditions and the following disclaimer.
N**
N**     * Redistributions in binary form must reproduce the above copyright
N**       notice, this list of conditions and the following disclaimer in the
N**       documentation and/or other materials provided with the distribution.
N**
N**     * Neither the name of the copyright holder nor the names of its
N**       contributors may be used to endorse or promote products derived from
N**       this software without specific prior written permission.
N**
N**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
N**     GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
N**     HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
N**     WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N**     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N**     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N**     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N**     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
N**     BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N**     WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
N**     OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
N**     IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N**
N**     http:                 www.nxp.com
N**     mail:                 support@nxp.com
N**
N**     Revisions:
N**     - rev. 1.0 (2018-02-09)
N**         Initial version.
N**     - rev. 1.1 (2018-02-25)
N**         Update some registers according to UM rev 1.2
N**
N** ###################################################################
N*/
N
N/*!
N * @file LPC824
N * @version 1.1
N * @date 2018-02-25
N * @brief Device specific configuration file for LPC824 (implementation file)
N *
N * Provides a system configuration function and a global variable that contains
N * the system frequency. It configures the device and initializes the oscillator
N * (PLL) that is part of the microcontroller device.
N */
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 78 "lpc_chip_82x\system_LPC824.c" 2
N#include "LPC824.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include\LPC824.h" 1
N/*
N** ###################################################################
N**     Processors:          LPC824M201JDH20
N**                          LPC824M201JHI33
N**
N**     Compilers:           Keil ARM C/C++ Compiler
N**                          GNU C Compiler
N**                          IAR ANSI C/C++ Compiler for ARM
N**                          MCUXpresso Compiler
N**
N**     Reference manual:    LPC82x User manual Rev.1.2  5 October 2016
N**     Version:             rev. 1.1, 2018-02-25
N**     Build:               b180309
N**
N**     Abstract:
N**         CMSIS Peripheral Access Layer for LPC824
N**
N**     The Clear BSD License
N**     Copyright 1997-2016 Freescale Semiconductor, Inc.
N**     Copyright 2016-2018 NXP
N**     All rights reserved.
N**
N**     Redistribution and use in source and binary forms, with or without
N**     modification, are permitted (subject to the limitations in the
N**     disclaimer below) provided that the following conditions are met:
N**
N**     * Redistributions of source code must retain the above copyright
N**       notice, this list of conditions and the following disclaimer.
N**
N**     * Redistributions in binary form must reproduce the above copyright
N**       notice, this list of conditions and the following disclaimer in the
N**       documentation and/or other materials provided with the distribution.
N**
N**     * Neither the name of the copyright holder nor the names of its
N**       contributors may be used to endorse or promote products derived from
N**       this software without specific prior written permission.
N**
N**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
N**     GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
N**     HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
N**     WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N**     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N**     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N**     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N**     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
N**     BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N**     WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
N**     OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
N**     IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N**
N**     http:                 www.nxp.com
N**     mail:                 support@nxp.com
N**
N**     Revisions:
N**     - rev. 1.0 (2018-02-09)
N**         Initial version.
N**     - rev. 1.1 (2018-02-25)
N**         Update some registers according to UM rev 1.2
N**
N** ###################################################################
N*/
N
N/*!
N * @file LPC824.h
N * @version 1.1
N * @date 2018-02-25
N * @brief CMSIS Peripheral Access Layer for LPC824
N *
N * CMSIS Peripheral Access Layer for LPC824
N */
N
N#ifndef _LPC824_H_
N#define _LPC824_H_                               /**< Symbol preventing repeated inclusion */
N
N/** Memory map major version (memory maps with equal major version number are
N * compatible) */
N#define MCU_MEM_MAP_VERSION 0x0100U
N/** Memory map minor version */
N#define MCU_MEM_MAP_VERSION_MINOR 0x0001U
N
N
N/* ----------------------------------------------------------------------------
N   -- Interrupt vector numbers
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Interrupt_vector_numbers Interrupt vector numbers
N * @{
N */
N
N/** Interrupt Number Definitions */
N#define NUMBER_OF_INT_VECTORS 48                 /**< Number of interrupts in the Vector table */
N
Ntypedef enum IRQn {
N  /* Auxiliary constants */
N  NotAvail_IRQn                = -128,             /**< Not available device specific interrupt */
N
N  /* Core interrupts */
N  NonMaskableInt_IRQn          = -14,              /**< Non Maskable Interrupt */
N  HardFault_IRQn               = -13,              /**< Cortex-M0 SV Hard Fault Interrupt */
N  SVCall_IRQn                  = -5,               /**< Cortex-M0 SV Call Interrupt */
N  PendSV_IRQn                  = -2,               /**< Cortex-M0 Pend SV Interrupt */
N  SysTick_IRQn                 = -1,               /**< Cortex-M0 System Tick Interrupt */
N
N  /* Device specific interrupts */
N  SPI0_IRQn                    = 0,                /**< SPI0 interrupt */
N  SPI1_IRQn                    = 1,                /**< SPI1 interrupt */
N  Reserved18_IRQn              = 2,                /**< Reserved interrupt */
N  USART0_IRQn                  = 3,                /**< USART0 interrupt */
N  USART1_IRQn                  = 4,                /**< USART1 interrupt */
N  USART2_IRQn                  = 5,                /**< USART2 interrupt */
N  Reserved22_IRQn              = 6,                /**< Reserved interrupt */
N  I2C1_IRQn                    = 7,                /**< I2C1 interrupt */
N  I2C0_IRQn                    = 8,                /**< I2C0 interrupt */
N  SCT0_IRQn                    = 9,                /**< State configurable timer interrupt */
N  MRT0_IRQn                    = 10,               /**< Multi-rate timer interrupt */
N  CMP_CAPT_IRQn                = 11,               /**< Analog comparator interrupt or Capacitive Touch interrupt */
N  WDT_IRQn                     = 12,               /**< Windowed watchdog timer interrupt */
N  BOD_IRQn                     = 13,               /**< BOD interrupts */
N  FLASH_IRQn                   = 14,               /**< flash interrupt */
N  WKT_IRQn                     = 15,               /**< Self-wake-up timer interrupt */
N  ADC0_SEQA_IRQn               = 16,               /**< ADC0 sequence A completion. */
N  ADC0_SEQB_IRQn               = 17,               /**< ADC0 sequence B completion. */
N  ADC0_THCMP_IRQn              = 18,               /**< ADC0 threshold compare and error. */
N  ADC0_OVR_IRQn                = 19,               /**< ADC0 overrun */
N  DMA0_IRQn                    = 20,               /**< DMA0 interrupt */
N  I2C2_IRQn                    = 21,               /**< I2C2 interrupt */
N  I2C3_IRQn                    = 22,               /**< I2C3 interrupt */
N  Reserved39_IRQn              = 23,               /**< Reserved interrupt */
N  PIN_INT0_IRQn                = 24,               /**< Pin interrupt 0 or pattern match engine slice 0 interrupt */
N  PIN_INT1_IRQn                = 25,               /**< Pin interrupt 1 or pattern match engine slice 1 interrupt */
N  PIN_INT2_IRQn                = 26,               /**< Pin interrupt 2 or pattern match engine slice 2 interrupt */
N  PIN_INT3_IRQn                = 27,               /**< Pin interrupt 3 or pattern match engine slice 3 interrupt */
N  PIN_INT4_IRQn                = 28,               /**< Pin interrupt 4 or pattern match engine slice 4 interrupt */
N  PIN_INT5_IRQn                = 29,               /**< Pin interrupt 5 or pattern match engine slice 5 interrupt */
N  PIN_INT6_IRQn                = 30,               /**< Pin interrupt 6 or pattern match engine slice 6 interrupt */
N  PIN_INT7_IRQn                = 31                /**< Pin interrupt 7 or pattern match engine slice 7 interrupt */
N} IRQn_Type;
N
N/*!
N * @}
N */ /* end of group Interrupt_vector_numbers */
N
N
N/* ----------------------------------------------------------------------------
N   -- Cortex M0 Core Configuration
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Cortex_Core_Configuration Cortex M0 Core Configuration
N * @{
N */
N
N#define __CM0PLUS_REV                  0x0000    /**< Core revision r0p0 */
N#define __MPU_PRESENT                  0         /**< Defines if an MPU is present or not */
N#define __VTOR_PRESENT                 1         /**< Defines if VTOR is present or not */
N#define __NVIC_PRIO_BITS               2         /**< Number of priority bits implemented in the NVIC */
N#define __Vendor_SysTickConfig         0         /**< Vendor specific implementation of SysTickConfig is defined */
N
N#include "core_cm0plus.h"              /* Core Peripheral Access Layer */
L 1 ".\_CMSIS\v5.20\Include\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V5.0.3
N * @date     09. August 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
N#define __CORE_CM0PLUS_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex-M0+
N  @{
N */
N
N#include "cmsis_version.h"
L 1 ".\_CMSIS\v5.20\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 1U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 ".\_CMSIS\v5.20\Include\core_cm0plus.h" 2
N 
N/*  CMSIS CM0+ definitions */
N#define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
N                                       __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) |                                        __CM0PLUS_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 ".\_CMSIS\v5.20\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 ".\_CMSIS\v5.20\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (ARM compiler V5) header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060300 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#else
S  (void)fpscr;
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 ".\_CMSIS\v5.20\Include\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S  
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 ".\_CMSIS\v5.20\Include\core_cm0plus.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
N#define __CORE_CM0PLUS_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000U
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex-M0+ */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N#else
S        uint32_t RESERVED0;
N#endif
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0 == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S} MPU_Type;
S
S#define MPU_TYPE_RALIASES                  1U
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0+ header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0 == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N/*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0+ */
N/*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0+ */
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N           If VTOR is not present address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S    uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S  uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (0 == 1U)
S
S#include "mpu_armv7.h"
S
N#endif
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 162 "C:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include\LPC824.h" 2
N#include "system_LPC824.h"             /* Device specific configuration file */
L 1 "C:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include\system_LPC824.h" 1
N/*
N** ###################################################################
N**     Processors:          LPC824M201JDH20
N**                          LPC824M201JHI33
N**
N**     Compilers:           Keil ARM C/C++ Compiler
N**                          GNU C Compiler
N**                          IAR ANSI C/C++ Compiler for ARM
N**                          MCUXpresso Compiler
N**
N**     Reference manual:    LPC82x User manual Rev.1.2  5 October 2016
N**     Version:             rev. 1.1, 2018-02-25
N**     Build:               b180305
N**
N**     Abstract:
N**         Provides a system configuration function and a global variable that
N**         contains the system frequency. It configures the device and initializes
N**         the oscillator (PLL) that is part of the microcontroller device.
N**
N**     The Clear BSD License
N**     Copyright 2016 Freescale Semiconductor, Inc.
N**     Copyright 2016-2018 NXP
N**     All rights reserved.
N**
N**     Redistribution and use in source and binary forms, with or without
N**     modification, are permitted (subject to the limitations in the
N**     disclaimer below) provided that the following conditions are met:
N**
N**     * Redistributions of source code must retain the above copyright
N**       notice, this list of conditions and the following disclaimer.
N**
N**     * Redistributions in binary form must reproduce the above copyright
N**       notice, this list of conditions and the following disclaimer in the
N**       documentation and/or other materials provided with the distribution.
N**
N**     * Neither the name of the copyright holder nor the names of its
N**       contributors may be used to endorse or promote products derived from
N**       this software without specific prior written permission.
N**
N**     NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
N**     GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
N**     HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
N**     WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N**     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
N**     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N**     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N**     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
N**     BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N**     WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
N**     OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
N**     IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N**
N**     http:                 www.nxp.com
N**     mail:                 support@nxp.com
N**
N**     Revisions:
N**     - rev. 1.0 (2018-02-09)
N**         Initial version.
N**     - rev. 1.1 (2018-02-25)
N**         Update some registers according to UM rev 1.2
N**
N** ###################################################################
N*/
N
N/*!
N * @file LPC824
N * @version 1.1
N * @date 2018-02-25
N * @brief Device specific configuration file for LPC824 (header file)
N *
N * Provides a system configuration function and a global variable that contains
N * the system frequency. It configures the device and initializes the oscillator
N * (PLL) that is part of the microcontroller device.
N */
N
N#ifndef _SYSTEM_LPC824_H_
N#define _SYSTEM_LPC824_H_                        /**< Symbol preventing repeated inclusion */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N#define DEFAULT_SYSTEM_CLOCK           12000000u           /* Default System clock value */
N#define CLK_RTC_32K_CLK                   32768u           /* RTC oscillator 32 kHz output (32k_clk */
N#define CLK_IRC_12MHZ                  12000000u           /* FRO 12 MHz (fro_12m) */
N#define CLK_OSC_IN                     12000000u           /* Oscillator input */
N#define EXT_CLK_IN                     0u                  /* ext clkin  */
N
N
Nextern uint32_t g_Sys_Pll_Freq;
N
N/**
N * @brief System clock frequency (core clock)
N *
N * The system clock frequency supplied to the SysTick timer and the processor
N * core clock. This variable can be used by the user application to setup the
N * SysTick timer or configure other parameters. It may also be used by debugger to
N * query the frequency of the debug timer or configure the trace clock speed
N * SystemCoreClock is initialized with a correct predefined value.
N */
Nextern uint32_t SystemCoreClock;
N
N/**
N * @brief Setup the microcontroller system.
N *
N * Typically this function configures the oscillator (PLL) that is part of the
N * microcontroller device. For systems with variable clock speed it also updates
N * the variable SystemCoreClock. SystemInit is called from startup_device file.
N */
Nvoid SystemInit (void);
N
N/**
N * @brief Updates the SystemCoreClock variable.
N *
N * It must be called whenever the core clock is changed during program
N * execution. SystemCoreClockUpdate() evaluates the clock register settings and calculates
N * the current core clock.
N */
Nvoid SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* _SYSTEM_LPC824_H_ */
L 163 "C:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include\LPC824.h" 2
N
N/*!
N * @}
N */ /* end of group Cortex_Core_Configuration */
N
N
N/* ----------------------------------------------------------------------------
N   -- Mapping Information
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Mapping_Information Mapping Information
N * @{
N */
N
N/** Mapping Information */
N/*!
N * @addtogroup dma_request
N * @{
N */
N
N/*******************************************************************************
N * Definitions
N ******************************************************************************/
N
N/*!
N * @brief Structure for the DMA hardware request
N *
N * Defines the structure for the DMA hardware request collections. The user can configure the
N * hardware request to trigger the DMA transfer accordingly. The index
N * of the hardware request varies according  to the to SoC.
N */
Ntypedef enum _dma_request_source
N{
N    kDmaRequestUSART0_RX_DMA        = 0U,          /**< USART0 RX DMA  */
N    kDmaRequestUSART0_TX_DMA        = 1U,          /**< USART0 TX DMA  */
N    kDmaRequestUSART1_RX_DMA        = 2U,          /**< USART1 RX DMA  */
N    kDmaRequestUSART1_TX_DMA        = 3U,          /**< USART1 TX DMA  */
N    kDmaRequestUSART2_RX_DMA        = 4U,          /**< USART2 RX DMA  */
N    kDmaRequestUSART2_TX_DMA        = 5U,          /**< USART2 TX DMA  */
N    kDmaRequestSPI0_RX_DMA          = 6U,          /**< SPI0 RX DMA  */
N    kDmaRequestSPI0_TX_DMA          = 7U,          /**< SPI0 TX DMA  */
N    kDmaRequestSPI1_RX_DMA          = 8U,          /**< SPI1 RX DMA  */
N    kDmaRequestSPI1_TX_DMA          = 9U,          /**< SPI1 TX DMA  */
N    kDmaRequestI2C0_SLV_DMA         = 10U,         /**< I2C0 SLAVE DMA  */
N    kDmaRequestI2C0_MST_DMA         = 11U,         /**< I2C0 MASTER DMA  */
N    kDmaRequestI2C1_SLV_DMA         = 12U,         /**< I2C1 SLAVE DMA  */
N    kDmaRequestI2C1_MST_DMA         = 13U,         /**< I2C1 MASTER DMA  */
N    kDmaRequestI2C2_SLV_DMA         = 14U,         /**< I2C2 SLAVE DMA  */
N    kDmaRequestI2C2_MST_DMA         = 15U,         /**< I2C2 MASTER DMA  */
N    kDmaRequestI2C3_SLV_DMA         = 16U,         /**< I2C3 SLAVE DMA  */
N    kDmaRequestI2C3_MST_DMA         = 17U,         /**< I2C3 MASTER DMA  */
N} dma_request_source_t;
N
N/* @} */
N
N
N/*!
N * @}
N */ /* end of group Mapping_Information */
N
N
N/* ----------------------------------------------------------------------------
N   -- Device Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Peripheral_access_layer Device Peripheral Access Layer
N * @{
N */
N
N
N/*
N** Start of section using anonymous unions
N*/
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #if (__ARMCC_VERSION >= 6010050)
X  #if (5060300 >= 6010050)
S    #pragma clang diagnostic push
N  #else
N    #pragma push
N    #pragma anon_unions
N  #endif
N#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma language=extended
S#else
S  #error Not supported compiler type
N#endif
N
N/* ----------------------------------------------------------------------------
N   -- ACOMP Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ACOMP_Peripheral_Access_Layer ACOMP Peripheral Access Layer
N * @{
N */
N
N/** ACOMP - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< Comparator control register, offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t LAD;                               /**< Voltage ladder register, offset: 0x4 */
X  volatile uint32_t LAD;                                
N} ACOMP_Type;
N
N/* ----------------------------------------------------------------------------
N   -- ACOMP Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ACOMP_Register_Masks ACOMP Register Masks
N * @{
N */
N
N/*! @name CTRL - Comparator control register */
N/*! @{ */
N#define ACOMP_CTRL_EDGESEL_MASK                  (0x18U)
N#define ACOMP_CTRL_EDGESEL_SHIFT                 (3U)
N#define ACOMP_CTRL_EDGESEL(x)                    (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_EDGESEL_SHIFT)) & ACOMP_CTRL_EDGESEL_MASK)
N#define ACOMP_CTRL_COMPSA_MASK                   (0x40U)
N#define ACOMP_CTRL_COMPSA_SHIFT                  (6U)
N#define ACOMP_CTRL_COMPSA(x)                     (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_COMPSA_SHIFT)) & ACOMP_CTRL_COMPSA_MASK)
N#define ACOMP_CTRL_COMP_VP_SEL_MASK              (0x700U)
N#define ACOMP_CTRL_COMP_VP_SEL_SHIFT             (8U)
N#define ACOMP_CTRL_COMP_VP_SEL(x)                (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_COMP_VP_SEL_SHIFT)) & ACOMP_CTRL_COMP_VP_SEL_MASK)
N#define ACOMP_CTRL_COMP_VM_SEL_MASK              (0x3800U)
N#define ACOMP_CTRL_COMP_VM_SEL_SHIFT             (11U)
N#define ACOMP_CTRL_COMP_VM_SEL(x)                (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_COMP_VM_SEL_SHIFT)) & ACOMP_CTRL_COMP_VM_SEL_MASK)
N#define ACOMP_CTRL_EDGECLR_MASK                  (0x100000U)
N#define ACOMP_CTRL_EDGECLR_SHIFT                 (20U)
N#define ACOMP_CTRL_EDGECLR(x)                    (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_EDGECLR_SHIFT)) & ACOMP_CTRL_EDGECLR_MASK)
N#define ACOMP_CTRL_COMPSTAT_MASK                 (0x200000U)
N#define ACOMP_CTRL_COMPSTAT_SHIFT                (21U)
N#define ACOMP_CTRL_COMPSTAT(x)                   (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_COMPSTAT_SHIFT)) & ACOMP_CTRL_COMPSTAT_MASK)
N#define ACOMP_CTRL_COMPEDGE_MASK                 (0x800000U)
N#define ACOMP_CTRL_COMPEDGE_SHIFT                (23U)
N#define ACOMP_CTRL_COMPEDGE(x)                   (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_COMPEDGE_SHIFT)) & ACOMP_CTRL_COMPEDGE_MASK)
N#define ACOMP_CTRL_HYS_MASK                      (0x6000000U)
N#define ACOMP_CTRL_HYS_SHIFT                     (25U)
N#define ACOMP_CTRL_HYS(x)                        (((uint32_t)(((uint32_t)(x)) << ACOMP_CTRL_HYS_SHIFT)) & ACOMP_CTRL_HYS_MASK)
N/*! @} */
N
N/*! @name LAD - Voltage ladder register */
N/*! @{ */
N#define ACOMP_LAD_LADEN_MASK                     (0x1U)
N#define ACOMP_LAD_LADEN_SHIFT                    (0U)
N#define ACOMP_LAD_LADEN(x)                       (((uint32_t)(((uint32_t)(x)) << ACOMP_LAD_LADEN_SHIFT)) & ACOMP_LAD_LADEN_MASK)
N#define ACOMP_LAD_LADSEL_MASK                    (0x3EU)
N#define ACOMP_LAD_LADSEL_SHIFT                   (1U)
N#define ACOMP_LAD_LADSEL(x)                      (((uint32_t)(((uint32_t)(x)) << ACOMP_LAD_LADSEL_SHIFT)) & ACOMP_LAD_LADSEL_MASK)
N#define ACOMP_LAD_LADREF_MASK                    (0x40U)
N#define ACOMP_LAD_LADREF_SHIFT                   (6U)
N#define ACOMP_LAD_LADREF(x)                      (((uint32_t)(((uint32_t)(x)) << ACOMP_LAD_LADREF_SHIFT)) & ACOMP_LAD_LADREF_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group ACOMP_Register_Masks */
N
N
N/* ACOMP - Peripheral instance base addresses */
N/** Peripheral ACOMP base address */
N#define ACOMP_BASE                               (0x40024000u)
N/** Peripheral ACOMP base pointer */
N#define ACOMP                                    ((ACOMP_Type *)ACOMP_BASE)
N/** Array initializer of ACOMP peripheral base addresses */
N#define ACOMP_BASE_ADDRS                         { ACOMP_BASE }
N/** Array initializer of ACOMP peripheral base pointers */
N#define ACOMP_BASE_PTRS                          { ACOMP }
N
N/*!
N * @}
N */ /* end of group ACOMP_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- ADC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ADC_Peripheral_Access_Layer ADC Peripheral Access Layer
N * @{
N */
N
N/** ADC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< ADC Control register. Contains the clock divide value, resolution selection, sampling time selection, and mode controls., offset: 0x0 */
X  volatile uint32_t CTRL;                               
N       uint8_t RESERVED_0[4];
N  __IO uint32_t SEQ_CTRL[2];                       /**< ADC Conversion Sequence-n control register: Controls triggering and channel selection for conversion sequence-n. Also specifies interrupt mode for sequence-n., array offset: 0x8, array step: 0x4 */
X  volatile uint32_t SEQ_CTRL[2];                        
N  __IO uint32_t SEQ_GDAT[2];                       /**< ADC Sequence-n Global Data register. This register contains the result of the most recent ADC conversion performed under sequence-n., array offset: 0x10, array step: 0x4 */
X  volatile uint32_t SEQ_GDAT[2];                        
N       uint8_t RESERVED_1[8];
N  __I  uint32_t DAT[12];                           /**< ADC Channel N Data register. This register contains the result of the most recent conversion completed on channel N., array offset: 0x20, array step: 0x4 */
X  volatile const  uint32_t DAT[12];                            
N  __IO uint32_t THR0_LOW;                          /**< ADC Low Compare Threshold register 0: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0., offset: 0x50 */
X  volatile uint32_t THR0_LOW;                           
N  __IO uint32_t THR1_LOW;                          /**< ADC Low Compare Threshold register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1., offset: 0x54 */
X  volatile uint32_t THR1_LOW;                           
N  __IO uint32_t THR0_HIGH;                         /**< ADC High Compare Threshold register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0., offset: 0x58 */
X  volatile uint32_t THR0_HIGH;                          
N  __IO uint32_t THR1_HIGH;                         /**< ADC High Compare Threshold register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1., offset: 0x5C */
X  volatile uint32_t THR1_HIGH;                          
N  __IO uint32_t CHAN_THRSEL;                       /**< ADC Channel-Threshold Select register. Specifies which set of threshold compare registers are to be used for each channel, offset: 0x60 */
X  volatile uint32_t CHAN_THRSEL;                        
N  __IO uint32_t INTEN;                             /**< ADC Interrupt Enable register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated., offset: 0x64 */
X  volatile uint32_t INTEN;                              
N  __IO uint32_t FLAGS;                             /**< ADC Flags register. Contains the four interrupt/DMA trigger flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers)., offset: 0x68 */
X  volatile uint32_t FLAGS;                              
N  __IO uint32_t TRM;                               /**< ADC Startup register., offset: 0x6C */
X  volatile uint32_t TRM;                                
N} ADC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- ADC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup ADC_Register_Masks ADC Register Masks
N * @{
N */
N
N/*! @name CTRL - ADC Control register. Contains the clock divide value, resolution selection, sampling time selection, and mode controls. */
N/*! @{ */
N#define ADC_CTRL_CLKDIV_MASK                     (0xFFU)
N#define ADC_CTRL_CLKDIV_SHIFT                    (0U)
N#define ADC_CTRL_CLKDIV(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_CLKDIV_SHIFT)) & ADC_CTRL_CLKDIV_MASK)
N#define ADC_CTRL_LPWRMODE_MASK                   (0x400U)
N#define ADC_CTRL_LPWRMODE_SHIFT                  (10U)
N#define ADC_CTRL_LPWRMODE(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_LPWRMODE_SHIFT)) & ADC_CTRL_LPWRMODE_MASK)
N#define ADC_CTRL_CALMODE_MASK                    (0x40000000U)
N#define ADC_CTRL_CALMODE_SHIFT                   (30U)
N#define ADC_CTRL_CALMODE(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_CTRL_CALMODE_SHIFT)) & ADC_CTRL_CALMODE_MASK)
N/*! @} */
N
N/*! @name SEQ_CTRL - ADC Conversion Sequence-n control register: Controls triggering and channel selection for conversion sequence-n. Also specifies interrupt mode for sequence-n. */
N/*! @{ */
N#define ADC_SEQ_CTRL_CHANNELS_MASK               (0xFFFU)
N#define ADC_SEQ_CTRL_CHANNELS_SHIFT              (0U)
N#define ADC_SEQ_CTRL_CHANNELS(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_CHANNELS_SHIFT)) & ADC_SEQ_CTRL_CHANNELS_MASK)
N#define ADC_SEQ_CTRL_TRIGGER_MASK                (0x7000U)
N#define ADC_SEQ_CTRL_TRIGGER_SHIFT               (12U)
N#define ADC_SEQ_CTRL_TRIGGER(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_TRIGGER_SHIFT)) & ADC_SEQ_CTRL_TRIGGER_MASK)
N#define ADC_SEQ_CTRL_TRIGPOL_MASK                (0x40000U)
N#define ADC_SEQ_CTRL_TRIGPOL_SHIFT               (18U)
N#define ADC_SEQ_CTRL_TRIGPOL(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_TRIGPOL_SHIFT)) & ADC_SEQ_CTRL_TRIGPOL_MASK)
N#define ADC_SEQ_CTRL_SYNCBYPASS_MASK             (0x80000U)
N#define ADC_SEQ_CTRL_SYNCBYPASS_SHIFT            (19U)
N#define ADC_SEQ_CTRL_SYNCBYPASS(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_SYNCBYPASS_SHIFT)) & ADC_SEQ_CTRL_SYNCBYPASS_MASK)
N#define ADC_SEQ_CTRL_START_MASK                  (0x4000000U)
N#define ADC_SEQ_CTRL_START_SHIFT                 (26U)
N#define ADC_SEQ_CTRL_START(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_START_SHIFT)) & ADC_SEQ_CTRL_START_MASK)
N#define ADC_SEQ_CTRL_BURST_MASK                  (0x8000000U)
N#define ADC_SEQ_CTRL_BURST_SHIFT                 (27U)
N#define ADC_SEQ_CTRL_BURST(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_BURST_SHIFT)) & ADC_SEQ_CTRL_BURST_MASK)
N#define ADC_SEQ_CTRL_SINGLESTEP_MASK             (0x10000000U)
N#define ADC_SEQ_CTRL_SINGLESTEP_SHIFT            (28U)
N#define ADC_SEQ_CTRL_SINGLESTEP(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_SINGLESTEP_SHIFT)) & ADC_SEQ_CTRL_SINGLESTEP_MASK)
N#define ADC_SEQ_CTRL_LOWPRIO_MASK                (0x20000000U)
N#define ADC_SEQ_CTRL_LOWPRIO_SHIFT               (29U)
N#define ADC_SEQ_CTRL_LOWPRIO(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_LOWPRIO_SHIFT)) & ADC_SEQ_CTRL_LOWPRIO_MASK)
N#define ADC_SEQ_CTRL_MODE_MASK                   (0x40000000U)
N#define ADC_SEQ_CTRL_MODE_SHIFT                  (30U)
N#define ADC_SEQ_CTRL_MODE(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_MODE_SHIFT)) & ADC_SEQ_CTRL_MODE_MASK)
N#define ADC_SEQ_CTRL_SEQ_ENA_MASK                (0x80000000U)
N#define ADC_SEQ_CTRL_SEQ_ENA_SHIFT               (31U)
N#define ADC_SEQ_CTRL_SEQ_ENA(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_CTRL_SEQ_ENA_SHIFT)) & ADC_SEQ_CTRL_SEQ_ENA_MASK)
N/*! @} */
N
N/* The count of ADC_SEQ_CTRL */
N#define ADC_SEQ_CTRL_COUNT                       (2U)
N
N/*! @name SEQ_GDAT - ADC Sequence-n Global Data register. This register contains the result of the most recent ADC conversion performed under sequence-n. */
N/*! @{ */
N#define ADC_SEQ_GDAT_RESULT_MASK                 (0xFFF0U)
N#define ADC_SEQ_GDAT_RESULT_SHIFT                (4U)
N#define ADC_SEQ_GDAT_RESULT(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_RESULT_SHIFT)) & ADC_SEQ_GDAT_RESULT_MASK)
N#define ADC_SEQ_GDAT_THCMPRANGE_MASK             (0x30000U)
N#define ADC_SEQ_GDAT_THCMPRANGE_SHIFT            (16U)
N#define ADC_SEQ_GDAT_THCMPRANGE(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_THCMPRANGE_SHIFT)) & ADC_SEQ_GDAT_THCMPRANGE_MASK)
N#define ADC_SEQ_GDAT_THCMPCROSS_MASK             (0xC0000U)
N#define ADC_SEQ_GDAT_THCMPCROSS_SHIFT            (18U)
N#define ADC_SEQ_GDAT_THCMPCROSS(x)               (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_THCMPCROSS_SHIFT)) & ADC_SEQ_GDAT_THCMPCROSS_MASK)
N#define ADC_SEQ_GDAT_CHN_MASK                    (0x3C000000U)
N#define ADC_SEQ_GDAT_CHN_SHIFT                   (26U)
N#define ADC_SEQ_GDAT_CHN(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_CHN_SHIFT)) & ADC_SEQ_GDAT_CHN_MASK)
N#define ADC_SEQ_GDAT_OVERRUN_MASK                (0x40000000U)
N#define ADC_SEQ_GDAT_OVERRUN_SHIFT               (30U)
N#define ADC_SEQ_GDAT_OVERRUN(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_OVERRUN_SHIFT)) & ADC_SEQ_GDAT_OVERRUN_MASK)
N#define ADC_SEQ_GDAT_DATAVALID_MASK              (0x80000000U)
N#define ADC_SEQ_GDAT_DATAVALID_SHIFT             (31U)
N#define ADC_SEQ_GDAT_DATAVALID(x)                (((uint32_t)(((uint32_t)(x)) << ADC_SEQ_GDAT_DATAVALID_SHIFT)) & ADC_SEQ_GDAT_DATAVALID_MASK)
N/*! @} */
N
N/* The count of ADC_SEQ_GDAT */
N#define ADC_SEQ_GDAT_COUNT                       (2U)
N
N/*! @name DAT - ADC Channel N Data register. This register contains the result of the most recent conversion completed on channel N. */
N/*! @{ */
N#define ADC_DAT_RESULT_MASK                      (0xFFF0U)
N#define ADC_DAT_RESULT_SHIFT                     (4U)
N#define ADC_DAT_RESULT(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_DAT_RESULT_SHIFT)) & ADC_DAT_RESULT_MASK)
N#define ADC_DAT_THCMPRANGE_MASK                  (0x30000U)
N#define ADC_DAT_THCMPRANGE_SHIFT                 (16U)
N#define ADC_DAT_THCMPRANGE(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_DAT_THCMPRANGE_SHIFT)) & ADC_DAT_THCMPRANGE_MASK)
N#define ADC_DAT_THCMPCROSS_MASK                  (0xC0000U)
N#define ADC_DAT_THCMPCROSS_SHIFT                 (18U)
N#define ADC_DAT_THCMPCROSS(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_DAT_THCMPCROSS_SHIFT)) & ADC_DAT_THCMPCROSS_MASK)
N#define ADC_DAT_CHANNEL_MASK                     (0x3C000000U)
N#define ADC_DAT_CHANNEL_SHIFT                    (26U)
N#define ADC_DAT_CHANNEL(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_DAT_CHANNEL_SHIFT)) & ADC_DAT_CHANNEL_MASK)
N#define ADC_DAT_OVERRUN_MASK                     (0x40000000U)
N#define ADC_DAT_OVERRUN_SHIFT                    (30U)
N#define ADC_DAT_OVERRUN(x)                       (((uint32_t)(((uint32_t)(x)) << ADC_DAT_OVERRUN_SHIFT)) & ADC_DAT_OVERRUN_MASK)
N#define ADC_DAT_DATAVALID_MASK                   (0x80000000U)
N#define ADC_DAT_DATAVALID_SHIFT                  (31U)
N#define ADC_DAT_DATAVALID(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_DAT_DATAVALID_SHIFT)) & ADC_DAT_DATAVALID_MASK)
N/*! @} */
N
N/* The count of ADC_DAT */
N#define ADC_DAT_COUNT                            (12U)
N
N/*! @name THR0_LOW - ADC Low Compare Threshold register 0: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0. */
N/*! @{ */
N#define ADC_THR0_LOW_THRLOW_MASK                 (0xFFF0U)
N#define ADC_THR0_LOW_THRLOW_SHIFT                (4U)
N#define ADC_THR0_LOW_THRLOW(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_THR0_LOW_THRLOW_SHIFT)) & ADC_THR0_LOW_THRLOW_MASK)
N/*! @} */
N
N/*! @name THR1_LOW - ADC Low Compare Threshold register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1. */
N/*! @{ */
N#define ADC_THR1_LOW_THRLOW_MASK                 (0xFFF0U)
N#define ADC_THR1_LOW_THRLOW_SHIFT                (4U)
N#define ADC_THR1_LOW_THRLOW(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_THR1_LOW_THRLOW_SHIFT)) & ADC_THR1_LOW_THRLOW_MASK)
N/*! @} */
N
N/*! @name THR0_HIGH - ADC High Compare Threshold register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0. */
N/*! @{ */
N#define ADC_THR0_HIGH_THRHIGH_MASK               (0xFFF0U)
N#define ADC_THR0_HIGH_THRHIGH_SHIFT              (4U)
N#define ADC_THR0_HIGH_THRHIGH(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_THR0_HIGH_THRHIGH_SHIFT)) & ADC_THR0_HIGH_THRHIGH_MASK)
N/*! @} */
N
N/*! @name THR1_HIGH - ADC High Compare Threshold register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1. */
N/*! @{ */
N#define ADC_THR1_HIGH_THRHIGH_MASK               (0xFFF0U)
N#define ADC_THR1_HIGH_THRHIGH_SHIFT              (4U)
N#define ADC_THR1_HIGH_THRHIGH(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_THR1_HIGH_THRHIGH_SHIFT)) & ADC_THR1_HIGH_THRHIGH_MASK)
N/*! @} */
N
N/*! @name CHAN_THRSEL - ADC Channel-Threshold Select register. Specifies which set of threshold compare registers are to be used for each channel */
N/*! @{ */
N#define ADC_CHAN_THRSEL_CH0_THRSEL_MASK          (0x1U)
N#define ADC_CHAN_THRSEL_CH0_THRSEL_SHIFT         (0U)
N#define ADC_CHAN_THRSEL_CH0_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH0_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH0_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH1_THRSEL_MASK          (0x2U)
N#define ADC_CHAN_THRSEL_CH1_THRSEL_SHIFT         (1U)
N#define ADC_CHAN_THRSEL_CH1_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH1_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH1_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH2_THRSEL_MASK          (0x4U)
N#define ADC_CHAN_THRSEL_CH2_THRSEL_SHIFT         (2U)
N#define ADC_CHAN_THRSEL_CH2_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH2_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH2_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH3_THRSEL_MASK          (0x8U)
N#define ADC_CHAN_THRSEL_CH3_THRSEL_SHIFT         (3U)
N#define ADC_CHAN_THRSEL_CH3_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH3_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH3_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH4_THRSEL_MASK          (0x10U)
N#define ADC_CHAN_THRSEL_CH4_THRSEL_SHIFT         (4U)
N#define ADC_CHAN_THRSEL_CH4_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH4_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH4_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH5_THRSEL_MASK          (0x20U)
N#define ADC_CHAN_THRSEL_CH5_THRSEL_SHIFT         (5U)
N#define ADC_CHAN_THRSEL_CH5_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH5_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH5_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH6_THRSEL_MASK          (0x40U)
N#define ADC_CHAN_THRSEL_CH6_THRSEL_SHIFT         (6U)
N#define ADC_CHAN_THRSEL_CH6_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH6_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH6_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH7_THRSEL_MASK          (0x80U)
N#define ADC_CHAN_THRSEL_CH7_THRSEL_SHIFT         (7U)
N#define ADC_CHAN_THRSEL_CH7_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH7_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH7_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH8_THRSEL_MASK          (0x100U)
N#define ADC_CHAN_THRSEL_CH8_THRSEL_SHIFT         (8U)
N#define ADC_CHAN_THRSEL_CH8_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH8_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH8_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH9_THRSEL_MASK          (0x200U)
N#define ADC_CHAN_THRSEL_CH9_THRSEL_SHIFT         (9U)
N#define ADC_CHAN_THRSEL_CH9_THRSEL(x)            (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH9_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH9_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH10_THRSEL_MASK         (0x400U)
N#define ADC_CHAN_THRSEL_CH10_THRSEL_SHIFT        (10U)
N#define ADC_CHAN_THRSEL_CH10_THRSEL(x)           (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH10_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH10_THRSEL_MASK)
N#define ADC_CHAN_THRSEL_CH11_THRSEL_MASK         (0x800U)
N#define ADC_CHAN_THRSEL_CH11_THRSEL_SHIFT        (11U)
N#define ADC_CHAN_THRSEL_CH11_THRSEL(x)           (((uint32_t)(((uint32_t)(x)) << ADC_CHAN_THRSEL_CH11_THRSEL_SHIFT)) & ADC_CHAN_THRSEL_CH11_THRSEL_MASK)
N/*! @} */
N
N/*! @name INTEN - ADC Interrupt Enable register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated. */
N/*! @{ */
N#define ADC_INTEN_SEQA_INTEN_MASK                (0x1U)
N#define ADC_INTEN_SEQA_INTEN_SHIFT               (0U)
N#define ADC_INTEN_SEQA_INTEN(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_SEQA_INTEN_SHIFT)) & ADC_INTEN_SEQA_INTEN_MASK)
N#define ADC_INTEN_SEQB_INTEN_MASK                (0x2U)
N#define ADC_INTEN_SEQB_INTEN_SHIFT               (1U)
N#define ADC_INTEN_SEQB_INTEN(x)                  (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_SEQB_INTEN_SHIFT)) & ADC_INTEN_SEQB_INTEN_MASK)
N#define ADC_INTEN_OVR_INTEN_MASK                 (0x4U)
N#define ADC_INTEN_OVR_INTEN_SHIFT                (2U)
N#define ADC_INTEN_OVR_INTEN(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_OVR_INTEN_SHIFT)) & ADC_INTEN_OVR_INTEN_MASK)
N#define ADC_INTEN_ADCMPINTEN0_MASK               (0x18U)
N#define ADC_INTEN_ADCMPINTEN0_SHIFT              (3U)
N#define ADC_INTEN_ADCMPINTEN0(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN0_SHIFT)) & ADC_INTEN_ADCMPINTEN0_MASK)
N#define ADC_INTEN_ADCMPINTEN1_MASK               (0x60U)
N#define ADC_INTEN_ADCMPINTEN1_SHIFT              (5U)
N#define ADC_INTEN_ADCMPINTEN1(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN1_SHIFT)) & ADC_INTEN_ADCMPINTEN1_MASK)
N#define ADC_INTEN_ADCMPINTEN2_MASK               (0x180U)
N#define ADC_INTEN_ADCMPINTEN2_SHIFT              (7U)
N#define ADC_INTEN_ADCMPINTEN2(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN2_SHIFT)) & ADC_INTEN_ADCMPINTEN2_MASK)
N#define ADC_INTEN_ADCMPINTEN3_MASK               (0x600U)
N#define ADC_INTEN_ADCMPINTEN3_SHIFT              (9U)
N#define ADC_INTEN_ADCMPINTEN3(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN3_SHIFT)) & ADC_INTEN_ADCMPINTEN3_MASK)
N#define ADC_INTEN_ADCMPINTEN4_MASK               (0x1800U)
N#define ADC_INTEN_ADCMPINTEN4_SHIFT              (11U)
N#define ADC_INTEN_ADCMPINTEN4(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN4_SHIFT)) & ADC_INTEN_ADCMPINTEN4_MASK)
N#define ADC_INTEN_ADCMPINTEN5_MASK               (0x6000U)
N#define ADC_INTEN_ADCMPINTEN5_SHIFT              (13U)
N#define ADC_INTEN_ADCMPINTEN5(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN5_SHIFT)) & ADC_INTEN_ADCMPINTEN5_MASK)
N#define ADC_INTEN_ADCMPINTEN6_MASK               (0x18000U)
N#define ADC_INTEN_ADCMPINTEN6_SHIFT              (15U)
N#define ADC_INTEN_ADCMPINTEN6(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN6_SHIFT)) & ADC_INTEN_ADCMPINTEN6_MASK)
N#define ADC_INTEN_ADCMPINTEN7_MASK               (0x60000U)
N#define ADC_INTEN_ADCMPINTEN7_SHIFT              (17U)
N#define ADC_INTEN_ADCMPINTEN7(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN7_SHIFT)) & ADC_INTEN_ADCMPINTEN7_MASK)
N#define ADC_INTEN_ADCMPINTEN8_MASK               (0x180000U)
N#define ADC_INTEN_ADCMPINTEN8_SHIFT              (19U)
N#define ADC_INTEN_ADCMPINTEN8(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN8_SHIFT)) & ADC_INTEN_ADCMPINTEN8_MASK)
N#define ADC_INTEN_ADCMPINTEN9_MASK               (0x600000U)
N#define ADC_INTEN_ADCMPINTEN9_SHIFT              (21U)
N#define ADC_INTEN_ADCMPINTEN9(x)                 (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN9_SHIFT)) & ADC_INTEN_ADCMPINTEN9_MASK)
N#define ADC_INTEN_ADCMPINTEN10_MASK              (0x1800000U)
N#define ADC_INTEN_ADCMPINTEN10_SHIFT             (23U)
N#define ADC_INTEN_ADCMPINTEN10(x)                (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN10_SHIFT)) & ADC_INTEN_ADCMPINTEN10_MASK)
N#define ADC_INTEN_ADCMPINTEN11_MASK              (0x6000000U)
N#define ADC_INTEN_ADCMPINTEN11_SHIFT             (25U)
N#define ADC_INTEN_ADCMPINTEN11(x)                (((uint32_t)(((uint32_t)(x)) << ADC_INTEN_ADCMPINTEN11_SHIFT)) & ADC_INTEN_ADCMPINTEN11_MASK)
N/*! @} */
N
N/*! @name FLAGS - ADC Flags register. Contains the four interrupt/DMA trigger flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers). */
N/*! @{ */
N#define ADC_FLAGS_THCMP0_MASK                    (0x1U)
N#define ADC_FLAGS_THCMP0_SHIFT                   (0U)
N#define ADC_FLAGS_THCMP0(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP0_SHIFT)) & ADC_FLAGS_THCMP0_MASK)
N#define ADC_FLAGS_THCMP1_MASK                    (0x2U)
N#define ADC_FLAGS_THCMP1_SHIFT                   (1U)
N#define ADC_FLAGS_THCMP1(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP1_SHIFT)) & ADC_FLAGS_THCMP1_MASK)
N#define ADC_FLAGS_THCMP2_MASK                    (0x4U)
N#define ADC_FLAGS_THCMP2_SHIFT                   (2U)
N#define ADC_FLAGS_THCMP2(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP2_SHIFT)) & ADC_FLAGS_THCMP2_MASK)
N#define ADC_FLAGS_THCMP3_MASK                    (0x8U)
N#define ADC_FLAGS_THCMP3_SHIFT                   (3U)
N#define ADC_FLAGS_THCMP3(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP3_SHIFT)) & ADC_FLAGS_THCMP3_MASK)
N#define ADC_FLAGS_THCMP4_MASK                    (0x10U)
N#define ADC_FLAGS_THCMP4_SHIFT                   (4U)
N#define ADC_FLAGS_THCMP4(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP4_SHIFT)) & ADC_FLAGS_THCMP4_MASK)
N#define ADC_FLAGS_THCMP5_MASK                    (0x20U)
N#define ADC_FLAGS_THCMP5_SHIFT                   (5U)
N#define ADC_FLAGS_THCMP5(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP5_SHIFT)) & ADC_FLAGS_THCMP5_MASK)
N#define ADC_FLAGS_THCMP6_MASK                    (0x40U)
N#define ADC_FLAGS_THCMP6_SHIFT                   (6U)
N#define ADC_FLAGS_THCMP6(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP6_SHIFT)) & ADC_FLAGS_THCMP6_MASK)
N#define ADC_FLAGS_THCMP7_MASK                    (0x80U)
N#define ADC_FLAGS_THCMP7_SHIFT                   (7U)
N#define ADC_FLAGS_THCMP7(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP7_SHIFT)) & ADC_FLAGS_THCMP7_MASK)
N#define ADC_FLAGS_THCMP8_MASK                    (0x100U)
N#define ADC_FLAGS_THCMP8_SHIFT                   (8U)
N#define ADC_FLAGS_THCMP8(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP8_SHIFT)) & ADC_FLAGS_THCMP8_MASK)
N#define ADC_FLAGS_THCMP9_MASK                    (0x200U)
N#define ADC_FLAGS_THCMP9_SHIFT                   (9U)
N#define ADC_FLAGS_THCMP9(x)                      (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP9_SHIFT)) & ADC_FLAGS_THCMP9_MASK)
N#define ADC_FLAGS_THCMP10_MASK                   (0x400U)
N#define ADC_FLAGS_THCMP10_SHIFT                  (10U)
N#define ADC_FLAGS_THCMP10(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP10_SHIFT)) & ADC_FLAGS_THCMP10_MASK)
N#define ADC_FLAGS_THCMP11_MASK                   (0x800U)
N#define ADC_FLAGS_THCMP11_SHIFT                  (11U)
N#define ADC_FLAGS_THCMP11(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP11_SHIFT)) & ADC_FLAGS_THCMP11_MASK)
N#define ADC_FLAGS_OVERRUN0_MASK                  (0x1000U)
N#define ADC_FLAGS_OVERRUN0_SHIFT                 (12U)
N#define ADC_FLAGS_OVERRUN0(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN0_SHIFT)) & ADC_FLAGS_OVERRUN0_MASK)
N#define ADC_FLAGS_OVERRUN1_MASK                  (0x2000U)
N#define ADC_FLAGS_OVERRUN1_SHIFT                 (13U)
N#define ADC_FLAGS_OVERRUN1(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN1_SHIFT)) & ADC_FLAGS_OVERRUN1_MASK)
N#define ADC_FLAGS_OVERRUN2_MASK                  (0x4000U)
N#define ADC_FLAGS_OVERRUN2_SHIFT                 (14U)
N#define ADC_FLAGS_OVERRUN2(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN2_SHIFT)) & ADC_FLAGS_OVERRUN2_MASK)
N#define ADC_FLAGS_OVERRUN3_MASK                  (0x8000U)
N#define ADC_FLAGS_OVERRUN3_SHIFT                 (15U)
N#define ADC_FLAGS_OVERRUN3(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN3_SHIFT)) & ADC_FLAGS_OVERRUN3_MASK)
N#define ADC_FLAGS_OVERRUN4_MASK                  (0x10000U)
N#define ADC_FLAGS_OVERRUN4_SHIFT                 (16U)
N#define ADC_FLAGS_OVERRUN4(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN4_SHIFT)) & ADC_FLAGS_OVERRUN4_MASK)
N#define ADC_FLAGS_OVERRUN5_MASK                  (0x20000U)
N#define ADC_FLAGS_OVERRUN5_SHIFT                 (17U)
N#define ADC_FLAGS_OVERRUN5(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN5_SHIFT)) & ADC_FLAGS_OVERRUN5_MASK)
N#define ADC_FLAGS_OVERRUN6_MASK                  (0x40000U)
N#define ADC_FLAGS_OVERRUN6_SHIFT                 (18U)
N#define ADC_FLAGS_OVERRUN6(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN6_SHIFT)) & ADC_FLAGS_OVERRUN6_MASK)
N#define ADC_FLAGS_OVERRUN7_MASK                  (0x80000U)
N#define ADC_FLAGS_OVERRUN7_SHIFT                 (19U)
N#define ADC_FLAGS_OVERRUN7(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN7_SHIFT)) & ADC_FLAGS_OVERRUN7_MASK)
N#define ADC_FLAGS_OVERRUN8_MASK                  (0x100000U)
N#define ADC_FLAGS_OVERRUN8_SHIFT                 (20U)
N#define ADC_FLAGS_OVERRUN8(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN8_SHIFT)) & ADC_FLAGS_OVERRUN8_MASK)
N#define ADC_FLAGS_OVERRUN9_MASK                  (0x200000U)
N#define ADC_FLAGS_OVERRUN9_SHIFT                 (21U)
N#define ADC_FLAGS_OVERRUN9(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN9_SHIFT)) & ADC_FLAGS_OVERRUN9_MASK)
N#define ADC_FLAGS_OVERRUN10_MASK                 (0x400000U)
N#define ADC_FLAGS_OVERRUN10_SHIFT                (22U)
N#define ADC_FLAGS_OVERRUN10(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN10_SHIFT)) & ADC_FLAGS_OVERRUN10_MASK)
N#define ADC_FLAGS_OVERRUN11_MASK                 (0x800000U)
N#define ADC_FLAGS_OVERRUN11_SHIFT                (23U)
N#define ADC_FLAGS_OVERRUN11(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVERRUN11_SHIFT)) & ADC_FLAGS_OVERRUN11_MASK)
N#define ADC_FLAGS_SEQA_OVR_MASK                  (0x1000000U)
N#define ADC_FLAGS_SEQA_OVR_SHIFT                 (24U)
N#define ADC_FLAGS_SEQA_OVR(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQA_OVR_SHIFT)) & ADC_FLAGS_SEQA_OVR_MASK)
N#define ADC_FLAGS_SEQB_OVR_MASK                  (0x2000000U)
N#define ADC_FLAGS_SEQB_OVR_SHIFT                 (25U)
N#define ADC_FLAGS_SEQB_OVR(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQB_OVR_SHIFT)) & ADC_FLAGS_SEQB_OVR_MASK)
N#define ADC_FLAGS_SEQA_INT_MASK                  (0x10000000U)
N#define ADC_FLAGS_SEQA_INT_SHIFT                 (28U)
N#define ADC_FLAGS_SEQA_INT(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQA_INT_SHIFT)) & ADC_FLAGS_SEQA_INT_MASK)
N#define ADC_FLAGS_SEQB_INT_MASK                  (0x20000000U)
N#define ADC_FLAGS_SEQB_INT_SHIFT                 (29U)
N#define ADC_FLAGS_SEQB_INT(x)                    (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_SEQB_INT_SHIFT)) & ADC_FLAGS_SEQB_INT_MASK)
N#define ADC_FLAGS_THCMP_INT_MASK                 (0x40000000U)
N#define ADC_FLAGS_THCMP_INT_SHIFT                (30U)
N#define ADC_FLAGS_THCMP_INT(x)                   (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_THCMP_INT_SHIFT)) & ADC_FLAGS_THCMP_INT_MASK)
N#define ADC_FLAGS_OVR_INT_MASK                   (0x80000000U)
N#define ADC_FLAGS_OVR_INT_SHIFT                  (31U)
N#define ADC_FLAGS_OVR_INT(x)                     (((uint32_t)(((uint32_t)(x)) << ADC_FLAGS_OVR_INT_SHIFT)) & ADC_FLAGS_OVR_INT_MASK)
N/*! @} */
N
N/*! @name TRM - ADC Startup register. */
N/*! @{ */
N#define ADC_TRM_VRANGE_MASK                      (0x20U)
N#define ADC_TRM_VRANGE_SHIFT                     (5U)
N#define ADC_TRM_VRANGE(x)                        (((uint32_t)(((uint32_t)(x)) << ADC_TRM_VRANGE_SHIFT)) & ADC_TRM_VRANGE_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group ADC_Register_Masks */
N
N
N/* ADC - Peripheral instance base addresses */
N/** Peripheral ADC0 base address */
N#define ADC0_BASE                                (0x4001C000u)
N/** Peripheral ADC0 base pointer */
N#define ADC0                                     ((ADC_Type *)ADC0_BASE)
N/** Array initializer of ADC peripheral base addresses */
N#define ADC_BASE_ADDRS                           { ADC0_BASE }
N/** Array initializer of ADC peripheral base pointers */
N#define ADC_BASE_PTRS                            { ADC0 }
N/** Interrupt vectors for the ADC peripheral type */
N#define ADC_SEQ_IRQS                             { ADC0_SEQA_IRQn, ADC0_SEQB_IRQn }
N#define ADC_THCMP_IRQS                           { ADC0_THCMP_IRQn }
N
N/*!
N * @}
N */ /* end of group ADC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- CRC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CRC_Peripheral_Access_Layer CRC Peripheral Access Layer
N * @{
N */
N
N/** CRC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t MODE;                              /**< CRC mode register, offset: 0x0 */
X  volatile uint32_t MODE;                               
N  __IO uint32_t SEED;                              /**< CRC seed register, offset: 0x4 */
X  volatile uint32_t SEED;                               
N  union {                                          /* offset: 0x8 */
N    __I  uint32_t SUM;                               /**< CRC checksum register, offset: 0x8 */
X    volatile const  uint32_t SUM;                                
N    __O  uint32_t WR_DATA;                           /**< CRC data register, offset: 0x8 */
X    volatile  uint32_t WR_DATA;                            
N  };
N} CRC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- CRC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup CRC_Register_Masks CRC Register Masks
N * @{
N */
N
N/*! @name MODE - CRC mode register */
N/*! @{ */
N#define CRC_MODE_CRC_POLY_MASK                   (0x3U)
N#define CRC_MODE_CRC_POLY_SHIFT                  (0U)
N#define CRC_MODE_CRC_POLY(x)                     (((uint32_t)(((uint32_t)(x)) << CRC_MODE_CRC_POLY_SHIFT)) & CRC_MODE_CRC_POLY_MASK)
N#define CRC_MODE_BIT_RVS_WR_MASK                 (0x4U)
N#define CRC_MODE_BIT_RVS_WR_SHIFT                (2U)
N#define CRC_MODE_BIT_RVS_WR(x)                   (((uint32_t)(((uint32_t)(x)) << CRC_MODE_BIT_RVS_WR_SHIFT)) & CRC_MODE_BIT_RVS_WR_MASK)
N#define CRC_MODE_CMPL_WR_MASK                    (0x8U)
N#define CRC_MODE_CMPL_WR_SHIFT                   (3U)
N#define CRC_MODE_CMPL_WR(x)                      (((uint32_t)(((uint32_t)(x)) << CRC_MODE_CMPL_WR_SHIFT)) & CRC_MODE_CMPL_WR_MASK)
N#define CRC_MODE_BIT_RVS_SUM_MASK                (0x10U)
N#define CRC_MODE_BIT_RVS_SUM_SHIFT               (4U)
N#define CRC_MODE_BIT_RVS_SUM(x)                  (((uint32_t)(((uint32_t)(x)) << CRC_MODE_BIT_RVS_SUM_SHIFT)) & CRC_MODE_BIT_RVS_SUM_MASK)
N#define CRC_MODE_CMPL_SUM_MASK                   (0x20U)
N#define CRC_MODE_CMPL_SUM_SHIFT                  (5U)
N#define CRC_MODE_CMPL_SUM(x)                     (((uint32_t)(((uint32_t)(x)) << CRC_MODE_CMPL_SUM_SHIFT)) & CRC_MODE_CMPL_SUM_MASK)
N/*! @} */
N
N/*! @name SEED - CRC seed register */
N/*! @{ */
N#define CRC_SEED_CRC_SEED_MASK                   (0xFFFFFFFFU)
N#define CRC_SEED_CRC_SEED_SHIFT                  (0U)
N#define CRC_SEED_CRC_SEED(x)                     (((uint32_t)(((uint32_t)(x)) << CRC_SEED_CRC_SEED_SHIFT)) & CRC_SEED_CRC_SEED_MASK)
N/*! @} */
N
N/*! @name SUM - CRC checksum register */
N/*! @{ */
N#define CRC_SUM_CRC_SUM_MASK                     (0xFFFFFFFFU)
N#define CRC_SUM_CRC_SUM_SHIFT                    (0U)
N#define CRC_SUM_CRC_SUM(x)                       (((uint32_t)(((uint32_t)(x)) << CRC_SUM_CRC_SUM_SHIFT)) & CRC_SUM_CRC_SUM_MASK)
N/*! @} */
N
N/*! @name WR_DATA - CRC data register */
N/*! @{ */
N#define CRC_WR_DATA_CRC_WR_DATA_MASK             (0xFFFFFFFFU)
N#define CRC_WR_DATA_CRC_WR_DATA_SHIFT            (0U)
N#define CRC_WR_DATA_CRC_WR_DATA(x)               (((uint32_t)(((uint32_t)(x)) << CRC_WR_DATA_CRC_WR_DATA_SHIFT)) & CRC_WR_DATA_CRC_WR_DATA_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group CRC_Register_Masks */
N
N
N/* CRC - Peripheral instance base addresses */
N/** Peripheral CRC base address */
N#define CRC_BASE                                 (0x50000000u)
N/** Peripheral CRC base pointer */
N#define CRC                                      ((CRC_Type *)CRC_BASE)
N/** Array initializer of CRC peripheral base addresses */
N#define CRC_BASE_ADDRS                           { CRC_BASE }
N/** Array initializer of CRC peripheral base pointers */
N#define CRC_BASE_PTRS                            { CRC }
N
N/*!
N * @}
N */ /* end of group CRC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- DMA Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup DMA_Peripheral_Access_Layer DMA Peripheral Access Layer
N * @{
N */
N
N/** DMA - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< DMA control., offset: 0x0 */
X  volatile uint32_t CTRL;                               
N  __I  uint32_t INTSTAT;                           /**< Interrupt status., offset: 0x4 */
X  volatile const  uint32_t INTSTAT;                            
N  __IO uint32_t SRAMBASE;                          /**< SRAM address of the channel configuration table., offset: 0x8 */
X  volatile uint32_t SRAMBASE;                           
N       uint8_t RESERVED_0[20];
N  struct {                                         /* offset: 0x20, array step: 0x5C */
N    __IO uint32_t ENABLESET;                         /**< Channel Enable read and Set for all DMA channels., array offset: 0x20, array step: 0x5C */
X    volatile uint32_t ENABLESET;                          
N         uint8_t RESERVED_0[4];
N    __IO uint32_t ENABLECLR;                         /**< Channel Enable Clear for all DMA channels., array offset: 0x28, array step: 0x5C */
X    volatile uint32_t ENABLECLR;                          
N         uint8_t RESERVED_1[4];
N    __I  uint32_t ACTIVE;                            /**< Channel Active status for all DMA channels., array offset: 0x30, array step: 0x5C */
X    volatile const  uint32_t ACTIVE;                             
N         uint8_t RESERVED_2[4];
N    __I  uint32_t BUSY;                              /**< Channel Busy status for all DMA channels., array offset: 0x38, array step: 0x5C */
X    volatile const  uint32_t BUSY;                               
N         uint8_t RESERVED_3[4];
N    __IO uint32_t ERRINT;                            /**< Error Interrupt status for all DMA channels., array offset: 0x40, array step: 0x5C */
X    volatile uint32_t ERRINT;                             
N         uint8_t RESERVED_4[4];
N    __IO uint32_t INTENSET;                          /**< Interrupt Enable read and Set for all DMA channels., array offset: 0x48, array step: 0x5C */
X    volatile uint32_t INTENSET;                           
N         uint8_t RESERVED_5[4];
N    __IO uint32_t INTENCLR;                          /**< Interrupt Enable Clear for all DMA channels., array offset: 0x50, array step: 0x5C */
X    volatile uint32_t INTENCLR;                           
N         uint8_t RESERVED_6[4];
N    __IO uint32_t INTA;                              /**< Interrupt A status for all DMA channels., array offset: 0x58, array step: 0x5C */
X    volatile uint32_t INTA;                               
N         uint8_t RESERVED_7[4];
N    __IO uint32_t INTB;                              /**< Interrupt B status for all DMA channels., array offset: 0x60, array step: 0x5C */
X    volatile uint32_t INTB;                               
N         uint8_t RESERVED_8[4];
N    __IO uint32_t SETVALID;                          /**< Set ValidPending control bits for all DMA channels., array offset: 0x68, array step: 0x5C */
X    volatile uint32_t SETVALID;                           
N         uint8_t RESERVED_9[4];
N    __IO uint32_t SETTRIG;                           /**< Set Trigger control bits for all DMA channels., array offset: 0x70, array step: 0x5C */
X    volatile uint32_t SETTRIG;                            
N         uint8_t RESERVED_10[4];
N    __IO uint32_t ABORT;                             /**< Channel Abort control for all DMA channels., array offset: 0x78, array step: 0x5C */
X    volatile uint32_t ABORT;                              
N  } COMMON[1];
N       uint8_t RESERVED_1[900];
N  struct {                                         /* offset: 0x400, array step: 0x10 */
N    __IO uint32_t CFG;                               /**< Configuration register for DMA channel ., array offset: 0x400, array step: 0x10 */
X    volatile uint32_t CFG;                                
N    __I  uint32_t CTLSTAT;                           /**< Control and status register for DMA channel ., array offset: 0x404, array step: 0x10 */
X    volatile const  uint32_t CTLSTAT;                            
N    __IO uint32_t XFERCFG;                           /**< Transfer configuration register for DMA channel ., array offset: 0x408, array step: 0x10 */
X    volatile uint32_t XFERCFG;                            
N         uint8_t RESERVED_0[4];
N  } CHANNEL[18];
N} DMA_Type;
N
N/* ----------------------------------------------------------------------------
N   -- DMA Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup DMA_Register_Masks DMA Register Masks
N * @{
N */
N
N/*! @name CTRL - DMA control. */
N/*! @{ */
N#define DMA_CTRL_ENABLE_MASK                     (0x1U)
N#define DMA_CTRL_ENABLE_SHIFT                    (0U)
N#define DMA_CTRL_ENABLE(x)                       (((uint32_t)(((uint32_t)(x)) << DMA_CTRL_ENABLE_SHIFT)) & DMA_CTRL_ENABLE_MASK)
N/*! @} */
N
N/*! @name INTSTAT - Interrupt status. */
N/*! @{ */
N#define DMA_INTSTAT_ACTIVEINT_MASK               (0x2U)
N#define DMA_INTSTAT_ACTIVEINT_SHIFT              (1U)
N#define DMA_INTSTAT_ACTIVEINT(x)                 (((uint32_t)(((uint32_t)(x)) << DMA_INTSTAT_ACTIVEINT_SHIFT)) & DMA_INTSTAT_ACTIVEINT_MASK)
N#define DMA_INTSTAT_ACTIVEERRINT_MASK            (0x4U)
N#define DMA_INTSTAT_ACTIVEERRINT_SHIFT           (2U)
N#define DMA_INTSTAT_ACTIVEERRINT(x)              (((uint32_t)(((uint32_t)(x)) << DMA_INTSTAT_ACTIVEERRINT_SHIFT)) & DMA_INTSTAT_ACTIVEERRINT_MASK)
N/*! @} */
N
N/*! @name SRAMBASE - SRAM address of the channel configuration table. */
N/*! @{ */
N#define DMA_SRAMBASE_OFFSET_MASK                 (0xFFFFFE00U)
N#define DMA_SRAMBASE_OFFSET_SHIFT                (9U)
N#define DMA_SRAMBASE_OFFSET(x)                   (((uint32_t)(((uint32_t)(x)) << DMA_SRAMBASE_OFFSET_SHIFT)) & DMA_SRAMBASE_OFFSET_MASK)
N/*! @} */
N
N/*! @name COMMON_ENABLESET - Channel Enable read and Set for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_ENABLESET_ENA_MASK            (0x3FFFFU)
N#define DMA_COMMON_ENABLESET_ENA_SHIFT           (0U)
N#define DMA_COMMON_ENABLESET_ENA(x)              (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ENABLESET_ENA_SHIFT)) & DMA_COMMON_ENABLESET_ENA_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_ENABLESET */
N#define DMA_COMMON_ENABLESET_COUNT               (1U)
N
N/*! @name COMMON_ENABLECLR - Channel Enable Clear for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_ENABLECLR_CLR_MASK            (0x3FFFFU)
N#define DMA_COMMON_ENABLECLR_CLR_SHIFT           (0U)
N#define DMA_COMMON_ENABLECLR_CLR(x)              (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ENABLECLR_CLR_SHIFT)) & DMA_COMMON_ENABLECLR_CLR_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_ENABLECLR */
N#define DMA_COMMON_ENABLECLR_COUNT               (1U)
N
N/*! @name COMMON_ACTIVE - Channel Active status for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_ACTIVE_ACT_MASK               (0x3FFFFU)
N#define DMA_COMMON_ACTIVE_ACT_SHIFT              (0U)
N#define DMA_COMMON_ACTIVE_ACT(x)                 (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ACTIVE_ACT_SHIFT)) & DMA_COMMON_ACTIVE_ACT_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_ACTIVE */
N#define DMA_COMMON_ACTIVE_COUNT                  (1U)
N
N/*! @name COMMON_BUSY - Channel Busy status for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_BUSY_BSY_MASK                 (0x3FFFFU)
N#define DMA_COMMON_BUSY_BSY_SHIFT                (0U)
N#define DMA_COMMON_BUSY_BSY(x)                   (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_BUSY_BSY_SHIFT)) & DMA_COMMON_BUSY_BSY_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_BUSY */
N#define DMA_COMMON_BUSY_COUNT                    (1U)
N
N/*! @name COMMON_ERRINT - Error Interrupt status for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_ERRINT_ERR_MASK               (0x3FFFFU)
N#define DMA_COMMON_ERRINT_ERR_SHIFT              (0U)
N#define DMA_COMMON_ERRINT_ERR(x)                 (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ERRINT_ERR_SHIFT)) & DMA_COMMON_ERRINT_ERR_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_ERRINT */
N#define DMA_COMMON_ERRINT_COUNT                  (1U)
N
N/*! @name COMMON_INTENSET - Interrupt Enable read and Set for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_INTENSET_INTEN_MASK           (0x3FFFFU)
N#define DMA_COMMON_INTENSET_INTEN_SHIFT          (0U)
N#define DMA_COMMON_INTENSET_INTEN(x)             (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTENSET_INTEN_SHIFT)) & DMA_COMMON_INTENSET_INTEN_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_INTENSET */
N#define DMA_COMMON_INTENSET_COUNT                (1U)
N
N/*! @name COMMON_INTENCLR - Interrupt Enable Clear for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_INTENCLR_CLR_MASK             (0x3FFFFU)
N#define DMA_COMMON_INTENCLR_CLR_SHIFT            (0U)
N#define DMA_COMMON_INTENCLR_CLR(x)               (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTENCLR_CLR_SHIFT)) & DMA_COMMON_INTENCLR_CLR_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_INTENCLR */
N#define DMA_COMMON_INTENCLR_COUNT                (1U)
N
N/*! @name COMMON_INTA - Interrupt A status for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_INTA_IA_MASK                  (0x3FFFFU)
N#define DMA_COMMON_INTA_IA_SHIFT                 (0U)
N#define DMA_COMMON_INTA_IA(x)                    (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTA_IA_SHIFT)) & DMA_COMMON_INTA_IA_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_INTA */
N#define DMA_COMMON_INTA_COUNT                    (1U)
N
N/*! @name COMMON_INTB - Interrupt B status for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_INTB_IB_MASK                  (0x3FFFFU)
N#define DMA_COMMON_INTB_IB_SHIFT                 (0U)
N#define DMA_COMMON_INTB_IB(x)                    (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_INTB_IB_SHIFT)) & DMA_COMMON_INTB_IB_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_INTB */
N#define DMA_COMMON_INTB_COUNT                    (1U)
N
N/*! @name COMMON_SETVALID - Set ValidPending control bits for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_SETVALID_SV_MASK              (0x3FFFFU)
N#define DMA_COMMON_SETVALID_SV_SHIFT             (0U)
N#define DMA_COMMON_SETVALID_SV(x)                (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_SETVALID_SV_SHIFT)) & DMA_COMMON_SETVALID_SV_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_SETVALID */
N#define DMA_COMMON_SETVALID_COUNT                (1U)
N
N/*! @name COMMON_SETTRIG - Set Trigger control bits for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_SETTRIG_TRIG_MASK             (0x3FFFFU)
N#define DMA_COMMON_SETTRIG_TRIG_SHIFT            (0U)
N#define DMA_COMMON_SETTRIG_TRIG(x)               (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_SETTRIG_TRIG_SHIFT)) & DMA_COMMON_SETTRIG_TRIG_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_SETTRIG */
N#define DMA_COMMON_SETTRIG_COUNT                 (1U)
N
N/*! @name COMMON_ABORT - Channel Abort control for all DMA channels. */
N/*! @{ */
N#define DMA_COMMON_ABORT_ABORTCTRL_MASK          (0x3FFFFU)
N#define DMA_COMMON_ABORT_ABORTCTRL_SHIFT         (0U)
N#define DMA_COMMON_ABORT_ABORTCTRL(x)            (((uint32_t)(((uint32_t)(x)) << DMA_COMMON_ABORT_ABORTCTRL_SHIFT)) & DMA_COMMON_ABORT_ABORTCTRL_MASK)
N/*! @} */
N
N/* The count of DMA_COMMON_ABORT */
N#define DMA_COMMON_ABORT_COUNT                   (1U)
N
N/*! @name CHANNEL_CFG - Configuration register for DMA channel . */
N/*! @{ */
N#define DMA_CHANNEL_CFG_PERIPHREQEN_MASK         (0x1U)
N#define DMA_CHANNEL_CFG_PERIPHREQEN_SHIFT        (0U)
N#define DMA_CHANNEL_CFG_PERIPHREQEN(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_PERIPHREQEN_SHIFT)) & DMA_CHANNEL_CFG_PERIPHREQEN_MASK)
N#define DMA_CHANNEL_CFG_HWTRIGEN_MASK            (0x2U)
N#define DMA_CHANNEL_CFG_HWTRIGEN_SHIFT           (1U)
N#define DMA_CHANNEL_CFG_HWTRIGEN(x)              (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_HWTRIGEN_SHIFT)) & DMA_CHANNEL_CFG_HWTRIGEN_MASK)
N#define DMA_CHANNEL_CFG_TRIGPOL_MASK             (0x10U)
N#define DMA_CHANNEL_CFG_TRIGPOL_SHIFT            (4U)
N#define DMA_CHANNEL_CFG_TRIGPOL(x)               (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_TRIGPOL_SHIFT)) & DMA_CHANNEL_CFG_TRIGPOL_MASK)
N#define DMA_CHANNEL_CFG_TRIGTYPE_MASK            (0x20U)
N#define DMA_CHANNEL_CFG_TRIGTYPE_SHIFT           (5U)
N#define DMA_CHANNEL_CFG_TRIGTYPE(x)              (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_TRIGTYPE_SHIFT)) & DMA_CHANNEL_CFG_TRIGTYPE_MASK)
N#define DMA_CHANNEL_CFG_TRIGBURST_MASK           (0x40U)
N#define DMA_CHANNEL_CFG_TRIGBURST_SHIFT          (6U)
N#define DMA_CHANNEL_CFG_TRIGBURST(x)             (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_TRIGBURST_SHIFT)) & DMA_CHANNEL_CFG_TRIGBURST_MASK)
N#define DMA_CHANNEL_CFG_BURSTPOWER_MASK          (0xF00U)
N#define DMA_CHANNEL_CFG_BURSTPOWER_SHIFT         (8U)
N#define DMA_CHANNEL_CFG_BURSTPOWER(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_BURSTPOWER_SHIFT)) & DMA_CHANNEL_CFG_BURSTPOWER_MASK)
N#define DMA_CHANNEL_CFG_SRCBURSTWRAP_MASK        (0x4000U)
N#define DMA_CHANNEL_CFG_SRCBURSTWRAP_SHIFT       (14U)
N#define DMA_CHANNEL_CFG_SRCBURSTWRAP(x)          (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_SRCBURSTWRAP_SHIFT)) & DMA_CHANNEL_CFG_SRCBURSTWRAP_MASK)
N#define DMA_CHANNEL_CFG_DSTBURSTWRAP_MASK        (0x8000U)
N#define DMA_CHANNEL_CFG_DSTBURSTWRAP_SHIFT       (15U)
N#define DMA_CHANNEL_CFG_DSTBURSTWRAP(x)          (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_DSTBURSTWRAP_SHIFT)) & DMA_CHANNEL_CFG_DSTBURSTWRAP_MASK)
N#define DMA_CHANNEL_CFG_CHPRIORITY_MASK          (0x70000U)
N#define DMA_CHANNEL_CFG_CHPRIORITY_SHIFT         (16U)
N#define DMA_CHANNEL_CFG_CHPRIORITY(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CFG_CHPRIORITY_SHIFT)) & DMA_CHANNEL_CFG_CHPRIORITY_MASK)
N/*! @} */
N
N/* The count of DMA_CHANNEL_CFG */
N#define DMA_CHANNEL_CFG_COUNT                    (18U)
N
N/*! @name CHANNEL_CTLSTAT - Control and status register for DMA channel . */
N/*! @{ */
N#define DMA_CHANNEL_CTLSTAT_VALIDPENDING_MASK    (0x1U)
N#define DMA_CHANNEL_CTLSTAT_VALIDPENDING_SHIFT   (0U)
N#define DMA_CHANNEL_CTLSTAT_VALIDPENDING(x)      (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CTLSTAT_VALIDPENDING_SHIFT)) & DMA_CHANNEL_CTLSTAT_VALIDPENDING_MASK)
N#define DMA_CHANNEL_CTLSTAT_TRIG_MASK            (0x4U)
N#define DMA_CHANNEL_CTLSTAT_TRIG_SHIFT           (2U)
N#define DMA_CHANNEL_CTLSTAT_TRIG(x)              (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_CTLSTAT_TRIG_SHIFT)) & DMA_CHANNEL_CTLSTAT_TRIG_MASK)
N/*! @} */
N
N/* The count of DMA_CHANNEL_CTLSTAT */
N#define DMA_CHANNEL_CTLSTAT_COUNT                (18U)
N
N/*! @name CHANNEL_XFERCFG - Transfer configuration register for DMA channel . */
N/*! @{ */
N#define DMA_CHANNEL_XFERCFG_CFGVALID_MASK        (0x1U)
N#define DMA_CHANNEL_XFERCFG_CFGVALID_SHIFT       (0U)
N#define DMA_CHANNEL_XFERCFG_CFGVALID(x)          (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_CFGVALID_SHIFT)) & DMA_CHANNEL_XFERCFG_CFGVALID_MASK)
N#define DMA_CHANNEL_XFERCFG_RELOAD_MASK          (0x2U)
N#define DMA_CHANNEL_XFERCFG_RELOAD_SHIFT         (1U)
N#define DMA_CHANNEL_XFERCFG_RELOAD(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_RELOAD_SHIFT)) & DMA_CHANNEL_XFERCFG_RELOAD_MASK)
N#define DMA_CHANNEL_XFERCFG_SWTRIG_MASK          (0x4U)
N#define DMA_CHANNEL_XFERCFG_SWTRIG_SHIFT         (2U)
N#define DMA_CHANNEL_XFERCFG_SWTRIG(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SWTRIG_SHIFT)) & DMA_CHANNEL_XFERCFG_SWTRIG_MASK)
N#define DMA_CHANNEL_XFERCFG_CLRTRIG_MASK         (0x8U)
N#define DMA_CHANNEL_XFERCFG_CLRTRIG_SHIFT        (3U)
N#define DMA_CHANNEL_XFERCFG_CLRTRIG(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_CLRTRIG_SHIFT)) & DMA_CHANNEL_XFERCFG_CLRTRIG_MASK)
N#define DMA_CHANNEL_XFERCFG_SETINTA_MASK         (0x10U)
N#define DMA_CHANNEL_XFERCFG_SETINTA_SHIFT        (4U)
N#define DMA_CHANNEL_XFERCFG_SETINTA(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SETINTA_SHIFT)) & DMA_CHANNEL_XFERCFG_SETINTA_MASK)
N#define DMA_CHANNEL_XFERCFG_SETINTB_MASK         (0x20U)
N#define DMA_CHANNEL_XFERCFG_SETINTB_SHIFT        (5U)
N#define DMA_CHANNEL_XFERCFG_SETINTB(x)           (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SETINTB_SHIFT)) & DMA_CHANNEL_XFERCFG_SETINTB_MASK)
N#define DMA_CHANNEL_XFERCFG_WIDTH_MASK           (0x300U)
N#define DMA_CHANNEL_XFERCFG_WIDTH_SHIFT          (8U)
N#define DMA_CHANNEL_XFERCFG_WIDTH(x)             (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_WIDTH_SHIFT)) & DMA_CHANNEL_XFERCFG_WIDTH_MASK)
N#define DMA_CHANNEL_XFERCFG_SRCINC_MASK          (0x3000U)
N#define DMA_CHANNEL_XFERCFG_SRCINC_SHIFT         (12U)
N#define DMA_CHANNEL_XFERCFG_SRCINC(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_SRCINC_SHIFT)) & DMA_CHANNEL_XFERCFG_SRCINC_MASK)
N#define DMA_CHANNEL_XFERCFG_DSTINC_MASK          (0xC000U)
N#define DMA_CHANNEL_XFERCFG_DSTINC_SHIFT         (14U)
N#define DMA_CHANNEL_XFERCFG_DSTINC(x)            (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_DSTINC_SHIFT)) & DMA_CHANNEL_XFERCFG_DSTINC_MASK)
N#define DMA_CHANNEL_XFERCFG_XFERCOUNT_MASK       (0x3FF0000U)
N#define DMA_CHANNEL_XFERCFG_XFERCOUNT_SHIFT      (16U)
N#define DMA_CHANNEL_XFERCFG_XFERCOUNT(x)         (((uint32_t)(((uint32_t)(x)) << DMA_CHANNEL_XFERCFG_XFERCOUNT_SHIFT)) & DMA_CHANNEL_XFERCFG_XFERCOUNT_MASK)
N/*! @} */
N
N/* The count of DMA_CHANNEL_XFERCFG */
N#define DMA_CHANNEL_XFERCFG_COUNT                (18U)
N
N
N/*!
N * @}
N */ /* end of group DMA_Register_Masks */
N
N
N/* DMA - Peripheral instance base addresses */
N/** Peripheral DMA0 base address */
N#define DMA0_BASE                                (0x50008000u)
N/** Peripheral DMA0 base pointer */
N#define DMA0                                     ((DMA_Type *)DMA0_BASE)
N/** Array initializer of DMA peripheral base addresses */
N#define DMA_BASE_ADDRS                           { DMA0_BASE }
N/** Array initializer of DMA peripheral base pointers */
N#define DMA_BASE_PTRS                            { DMA0 }
N/** Interrupt vectors for the DMA peripheral type */
N#define DMA_IRQS                                 { DMA0_IRQn }
N
N/*!
N * @}
N */ /* end of group DMA_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- FLASH_CTRL Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup FLASH_CTRL_Peripheral_Access_Layer FLASH_CTRL Peripheral Access Layer
N * @{
N */
N
N/** FLASH_CTRL - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[16];
N  __IO uint32_t FLASHCFG;                          /**< Flash configuration register, offset: 0x10 */
X  volatile uint32_t FLASHCFG;                           
N       uint8_t RESERVED_1[12];
N  __IO uint32_t FMSSTART;                          /**< Flash signature start address register, offset: 0x20 */
X  volatile uint32_t FMSSTART;                           
N  __IO uint32_t FMSSTOP;                           /**< Flash signaure stop address register, offset: 0x24 */
X  volatile uint32_t FMSSTOP;                            
N       uint8_t RESERVED_2[4];
N  __I  uint32_t FMSW0;                             /**< Flash signature generation result register returns the flash signature produced by the embedded signature generator.., offset: 0x2C */
X  volatile const  uint32_t FMSW0;                              
N       uint8_t RESERVED_3[4016];
N  __I  uint32_t FMSTAT;                            /**< Flash signature generation status bit, offset: 0xFE0 */
X  volatile const  uint32_t FMSTAT;                             
N       uint8_t RESERVED_4[4];
N  __O  uint32_t FMSTATCLR;                         /**< Clear FLASH signature generation status bit, offset: 0xFE8 */
X  volatile  uint32_t FMSTATCLR;                          
N} FLASH_CTRL_Type;
N
N/* ----------------------------------------------------------------------------
N   -- FLASH_CTRL Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup FLASH_CTRL_Register_Masks FLASH_CTRL Register Masks
N * @{
N */
N
N/*! @name FLASHCFG - Flash configuration register */
N/*! @{ */
N#define FLASH_CTRL_FLASHCFG_FLASHTIM_MASK        (0x3U)
N#define FLASH_CTRL_FLASHCFG_FLASHTIM_SHIFT       (0U)
N#define FLASH_CTRL_FLASHCFG_FLASHTIM(x)          (((uint32_t)(((uint32_t)(x)) << FLASH_CTRL_FLASHCFG_FLASHTIM_SHIFT)) & FLASH_CTRL_FLASHCFG_FLASHTIM_MASK)
N/*! @} */
N
N/*! @name FMSSTART - Flash signature start address register */
N/*! @{ */
N#define FLASH_CTRL_FMSSTART_START_MASK           (0x1FFFFU)
N#define FLASH_CTRL_FMSSTART_START_SHIFT          (0U)
N#define FLASH_CTRL_FMSSTART_START(x)             (((uint32_t)(((uint32_t)(x)) << FLASH_CTRL_FMSSTART_START_SHIFT)) & FLASH_CTRL_FMSSTART_START_MASK)
N/*! @} */
N
N/*! @name FMSSTOP - Flash signaure stop address register */
N/*! @{ */
N#define FLASH_CTRL_FMSSTOP_STOPA_MASK            (0x1FFFFU)
N#define FLASH_CTRL_FMSSTOP_STOPA_SHIFT           (0U)
N#define FLASH_CTRL_FMSSTOP_STOPA(x)              (((uint32_t)(((uint32_t)(x)) << FLASH_CTRL_FMSSTOP_STOPA_SHIFT)) & FLASH_CTRL_FMSSTOP_STOPA_MASK)
N#define FLASH_CTRL_FMSSTOP_STRTBIST_MASK         (0x80000000U)
N#define FLASH_CTRL_FMSSTOP_STRTBIST_SHIFT        (31U)
N#define FLASH_CTRL_FMSSTOP_STRTBIST(x)           (((uint32_t)(((uint32_t)(x)) << FLASH_CTRL_FMSSTOP_STRTBIST_SHIFT)) & FLASH_CTRL_FMSSTOP_STRTBIST_MASK)
N/*! @} */
N
N/*! @name FMSW0 - Flash signature generation result register returns the flash signature produced by the embedded signature generator.. */
N/*! @{ */
N#define FLASH_CTRL_FMSW0_SIG_MASK                (0xFFFFFFFFU)
N#define FLASH_CTRL_FMSW0_SIG_SHIFT               (0U)
N#define FLASH_CTRL_FMSW0_SIG(x)                  (((uint32_t)(((uint32_t)(x)) << FLASH_CTRL_FMSW0_SIG_SHIFT)) & FLASH_CTRL_FMSW0_SIG_MASK)
N/*! @} */
N
N/*! @name FMSTAT - Flash signature generation status bit */
N/*! @{ */
N#define FLASH_CTRL_FMSTAT_SIGNATURE_DONE_MASK    (0x2U)
N#define FLASH_CTRL_FMSTAT_SIGNATURE_DONE_SHIFT   (1U)
N#define FLASH_CTRL_FMSTAT_SIGNATURE_DONE(x)      (((uint32_t)(((uint32_t)(x)) << FLASH_CTRL_FMSTAT_SIGNATURE_DONE_SHIFT)) & FLASH_CTRL_FMSTAT_SIGNATURE_DONE_MASK)
N/*! @} */
N
N/*! @name FMSTATCLR - Clear FLASH signature generation status bit */
N/*! @{ */
N#define FLASH_CTRL_FMSTATCLR_SIGNATURE_DONE_CLR_MASK (0x2U)
N#define FLASH_CTRL_FMSTATCLR_SIGNATURE_DONE_CLR_SHIFT (1U)
N#define FLASH_CTRL_FMSTATCLR_SIGNATURE_DONE_CLR(x) (((uint32_t)(((uint32_t)(x)) << FLASH_CTRL_FMSTATCLR_SIGNATURE_DONE_CLR_SHIFT)) & FLASH_CTRL_FMSTATCLR_SIGNATURE_DONE_CLR_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group FLASH_CTRL_Register_Masks */
N
N
N/* FLASH_CTRL - Peripheral instance base addresses */
N/** Peripheral FLASH_CTRL base address */
N#define FLASH_CTRL_BASE                          (0x40040000u)
N/** Peripheral FLASH_CTRL base pointer */
N#define FLASH_CTRL                               ((FLASH_CTRL_Type *)FLASH_CTRL_BASE)
N/** Array initializer of FLASH_CTRL peripheral base addresses */
N#define FLASH_CTRL_BASE_ADDRS                    { FLASH_CTRL_BASE }
N/** Array initializer of FLASH_CTRL peripheral base pointers */
N#define FLASH_CTRL_BASE_PTRS                     { FLASH_CTRL }
N
N/*!
N * @}
N */ /* end of group FLASH_CTRL_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- GPIO Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer
N * @{
N */
N
N/** GPIO - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t B[1][29];                           /**< Byte pin registers for all port 0 and 1 GPIO pins, array offset: 0x0, array step: index*0x1D, index2*0x1 */
X  volatile uint8_t B[1][29];                            
N       uint8_t RESERVED_0[4067];
N  __IO uint32_t W[1][29];                          /**< Word pin registers for all port 0 and 1 GPIO pins, array offset: 0x1000, array step: index*0x74, index2*0x4 */
X  volatile uint32_t W[1][29];                           
N       uint8_t RESERVED_1[3980];
N  __IO uint32_t DIR[1];                            /**< Direction registers, array offset: 0x2000, array step: 0x4 */
X  volatile uint32_t DIR[1];                             
N       uint8_t RESERVED_2[124];
N  __IO uint32_t MASK[1];                           /**< Mask register, array offset: 0x2080, array step: 0x4 */
X  volatile uint32_t MASK[1];                            
N       uint8_t RESERVED_3[124];
N  __IO uint32_t PIN[1];                            /**< Port pin register, array offset: 0x2100, array step: 0x4 */
X  volatile uint32_t PIN[1];                             
N       uint8_t RESERVED_4[124];
N  __IO uint32_t MPIN[1];                           /**< Masked port register, array offset: 0x2180, array step: 0x4 */
X  volatile uint32_t MPIN[1];                            
N       uint8_t RESERVED_5[124];
N  __IO uint32_t SET[1];                            /**< Write: Set register for port Read: output bits for port, array offset: 0x2200, array step: 0x4 */
X  volatile uint32_t SET[1];                             
N       uint8_t RESERVED_6[124];
N  __O  uint32_t CLR[1];                            /**< Clear port, array offset: 0x2280, array step: 0x4 */
X  volatile  uint32_t CLR[1];                             
N       uint8_t RESERVED_7[124];
N  __O  uint32_t NOT[1];                            /**< Toggle port, array offset: 0x2300, array step: 0x4 */
X  volatile  uint32_t NOT[1];                             
N       uint8_t RESERVED_8[124];
N  __O  uint32_t DIRSET[1];                         /**< Set pin direction bits for port, array offset: 0x2380, array step: 0x4 */
X  volatile  uint32_t DIRSET[1];                          
N       uint8_t RESERVED_9[124];
N  __O  uint32_t DIRCLR[1];                         /**< Clear pin direction bits for port, array offset: 0x2400, array step: 0x4 */
X  volatile  uint32_t DIRCLR[1];                          
N       uint8_t RESERVED_10[124];
N  __O  uint32_t DIRNOT[1];                         /**< Toggle pin direction bits for port, array offset: 0x2480, array step: 0x4 */
X  volatile  uint32_t DIRNOT[1];                          
N} GPIO_Type;
N
N/* ----------------------------------------------------------------------------
N   -- GPIO Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup GPIO_Register_Masks GPIO Register Masks
N * @{
N */
N
N/*! @name B - Byte pin registers for all port 0 and 1 GPIO pins */
N/*! @{ */
N#define GPIO_B_PBYTE_MASK                        (0x1U)
N#define GPIO_B_PBYTE_SHIFT                       (0U)
N#define GPIO_B_PBYTE(x)                          (((uint8_t)(((uint8_t)(x)) << GPIO_B_PBYTE_SHIFT)) & GPIO_B_PBYTE_MASK)
N/*! @} */
N
N/* The count of GPIO_B */
N#define GPIO_B_COUNT                             (1U)
N
N/* The count of GPIO_B */
N#define GPIO_B_COUNT2                            (29U)
N
N/*! @name W - Word pin registers for all port 0 and 1 GPIO pins */
N/*! @{ */
N#define GPIO_W_PWORD_MASK                        (0xFFFFFFFFU)
N#define GPIO_W_PWORD_SHIFT                       (0U)
N#define GPIO_W_PWORD(x)                          (((uint32_t)(((uint32_t)(x)) << GPIO_W_PWORD_SHIFT)) & GPIO_W_PWORD_MASK)
N/*! @} */
N
N/* The count of GPIO_W */
N#define GPIO_W_COUNT                             (1U)
N
N/* The count of GPIO_W */
N#define GPIO_W_COUNT2                            (29U)
N
N/*! @name DIR - Direction registers */
N/*! @{ */
N#define GPIO_DIR_DIRP_MASK                       (0x1FFFFFFFU)
N#define GPIO_DIR_DIRP_SHIFT                      (0U)
N#define GPIO_DIR_DIRP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_DIR_DIRP_SHIFT)) & GPIO_DIR_DIRP_MASK)
N/*! @} */
N
N/* The count of GPIO_DIR */
N#define GPIO_DIR_COUNT                           (1U)
N
N/*! @name MASK - Mask register */
N/*! @{ */
N#define GPIO_MASK_MASKP_MASK                     (0x1FFFFFFFU)
N#define GPIO_MASK_MASKP_SHIFT                    (0U)
N#define GPIO_MASK_MASKP(x)                       (((uint32_t)(((uint32_t)(x)) << GPIO_MASK_MASKP_SHIFT)) & GPIO_MASK_MASKP_MASK)
N/*! @} */
N
N/* The count of GPIO_MASK */
N#define GPIO_MASK_COUNT                          (1U)
N
N/*! @name PIN - Port pin register */
N/*! @{ */
N#define GPIO_PIN_PORT_MASK                       (0x1FFFFFFFU)
N#define GPIO_PIN_PORT_SHIFT                      (0U)
N#define GPIO_PIN_PORT(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_PIN_PORT_SHIFT)) & GPIO_PIN_PORT_MASK)
N/*! @} */
N
N/* The count of GPIO_PIN */
N#define GPIO_PIN_COUNT                           (1U)
N
N/*! @name MPIN - Masked port register */
N/*! @{ */
N#define GPIO_MPIN_MPORTP_MASK                    (0x1FFFFFFFU)
N#define GPIO_MPIN_MPORTP_SHIFT                   (0U)
N#define GPIO_MPIN_MPORTP(x)                      (((uint32_t)(((uint32_t)(x)) << GPIO_MPIN_MPORTP_SHIFT)) & GPIO_MPIN_MPORTP_MASK)
N/*! @} */
N
N/* The count of GPIO_MPIN */
N#define GPIO_MPIN_COUNT                          (1U)
N
N/*! @name SET - Write: Set register for port Read: output bits for port */
N/*! @{ */
N#define GPIO_SET_SETP_MASK                       (0x1FFFFFFFU)
N#define GPIO_SET_SETP_SHIFT                      (0U)
N#define GPIO_SET_SETP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_SET_SETP_SHIFT)) & GPIO_SET_SETP_MASK)
N/*! @} */
N
N/* The count of GPIO_SET */
N#define GPIO_SET_COUNT                           (1U)
N
N/*! @name CLR - Clear port */
N/*! @{ */
N#define GPIO_CLR_CLRP_MASK                       (0x1FFFFFFFU)
N#define GPIO_CLR_CLRP_SHIFT                      (0U)
N#define GPIO_CLR_CLRP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_CLR_CLRP_SHIFT)) & GPIO_CLR_CLRP_MASK)
N/*! @} */
N
N/* The count of GPIO_CLR */
N#define GPIO_CLR_COUNT                           (1U)
N
N/*! @name NOT - Toggle port */
N/*! @{ */
N#define GPIO_NOT_NOTP_MASK                       (0x1FFFFFFFU)
N#define GPIO_NOT_NOTP_SHIFT                      (0U)
N#define GPIO_NOT_NOTP(x)                         (((uint32_t)(((uint32_t)(x)) << GPIO_NOT_NOTP_SHIFT)) & GPIO_NOT_NOTP_MASK)
N/*! @} */
N
N/* The count of GPIO_NOT */
N#define GPIO_NOT_COUNT                           (1U)
N
N/*! @name DIRSET - Set pin direction bits for port */
N/*! @{ */
N#define GPIO_DIRSET_DIRSETP_MASK                 (0x1FFFFFFFU)
N#define GPIO_DIRSET_DIRSETP_SHIFT                (0U)
N#define GPIO_DIRSET_DIRSETP(x)                   (((uint32_t)(((uint32_t)(x)) << GPIO_DIRSET_DIRSETP_SHIFT)) & GPIO_DIRSET_DIRSETP_MASK)
N/*! @} */
N
N/* The count of GPIO_DIRSET */
N#define GPIO_DIRSET_COUNT                        (1U)
N
N/*! @name DIRCLR - Clear pin direction bits for port */
N/*! @{ */
N#define GPIO_DIRCLR_DIRCLRP_MASK                 (0x1FFFFFFFU)
N#define GPIO_DIRCLR_DIRCLRP_SHIFT                (0U)
N#define GPIO_DIRCLR_DIRCLRP(x)                   (((uint32_t)(((uint32_t)(x)) << GPIO_DIRCLR_DIRCLRP_SHIFT)) & GPIO_DIRCLR_DIRCLRP_MASK)
N/*! @} */
N
N/* The count of GPIO_DIRCLR */
N#define GPIO_DIRCLR_COUNT                        (1U)
N
N/*! @name DIRNOT - Toggle pin direction bits for port */
N/*! @{ */
N#define GPIO_DIRNOT_DIRNOTP_MASK                 (0x1FFFFFFFU)
N#define GPIO_DIRNOT_DIRNOTP_SHIFT                (0U)
N#define GPIO_DIRNOT_DIRNOTP(x)                   (((uint32_t)(((uint32_t)(x)) << GPIO_DIRNOT_DIRNOTP_SHIFT)) & GPIO_DIRNOT_DIRNOTP_MASK)
N/*! @} */
N
N/* The count of GPIO_DIRNOT */
N#define GPIO_DIRNOT_COUNT                        (1U)
N
N
N/*!
N * @}
N */ /* end of group GPIO_Register_Masks */
N
N
N/* GPIO - Peripheral instance base addresses */
N/** Peripheral GPIO base address */
N#define GPIO_BASE                                (0xA0000000u)
N/** Peripheral GPIO base pointer */
N#define GPIO                                     ((GPIO_Type *)GPIO_BASE)
N/** Array initializer of GPIO peripheral base addresses */
N#define GPIO_BASE_ADDRS                          { GPIO_BASE }
N/** Array initializer of GPIO peripheral base pointers */
N#define GPIO_BASE_PTRS                           { GPIO }
N
N/*!
N * @}
N */ /* end of group GPIO_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- I2C Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup I2C_Peripheral_Access_Layer I2C Peripheral Access Layer
N * @{
N */
N
N/** I2C - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CFG;                               /**< Configuration for shared functions., offset: 0x0 */
X  volatile uint32_t CFG;                                
N  __IO uint32_t STAT;                              /**< Status register for Master, Slave, and Monitor functions., offset: 0x4 */
X  volatile uint32_t STAT;                               
N  __IO uint32_t INTENSET;                          /**< Interrupt Enable Set and read register., offset: 0x8 */
X  volatile uint32_t INTENSET;                           
N  __O  uint32_t INTENCLR;                          /**< Interrupt Enable Clear register., offset: 0xC */
X  volatile  uint32_t INTENCLR;                           
N  __IO uint32_t TIMEOUT;                           /**< Time-out value register., offset: 0x10 */
X  volatile uint32_t TIMEOUT;                            
N  __IO uint32_t CLKDIV;                            /**< Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register, and controls some timing of the Slave function., offset: 0x14 */
X  volatile uint32_t CLKDIV;                             
N  __I  uint32_t INTSTAT;                           /**< Interrupt Status register for Master, Slave, and Monitor functions., offset: 0x18 */
X  volatile const  uint32_t INTSTAT;                            
N       uint8_t RESERVED_0[4];
N  __IO uint32_t MSTCTL;                            /**< Master control register., offset: 0x20 */
X  volatile uint32_t MSTCTL;                             
N  __IO uint32_t MSTTIME;                           /**< Master timing configuration., offset: 0x24 */
X  volatile uint32_t MSTTIME;                            
N  __IO uint32_t MSTDAT;                            /**< Combined Master receiver and transmitter data register., offset: 0x28 */
X  volatile uint32_t MSTDAT;                             
N       uint8_t RESERVED_1[20];
N  __IO uint32_t SLVCTL;                            /**< Slave control register., offset: 0x40 */
X  volatile uint32_t SLVCTL;                             
N  __IO uint32_t SLVDAT;                            /**< Combined Slave receiver and transmitter data register., offset: 0x44 */
X  volatile uint32_t SLVDAT;                             
N  __IO uint32_t SLVADR[4];                         /**< Slave address register., array offset: 0x48, array step: 0x4 */
X  volatile uint32_t SLVADR[4];                          
N  __IO uint32_t SLVQUAL0;                          /**< Slave Qualification for address 0., offset: 0x58 */
X  volatile uint32_t SLVQUAL0;                           
N       uint8_t RESERVED_2[36];
N  __I  uint32_t MONRXDAT;                          /**< Monitor receiver data register., offset: 0x80 */
X  volatile const  uint32_t MONRXDAT;                           
N} I2C_Type;
N
N/* ----------------------------------------------------------------------------
N   -- I2C Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup I2C_Register_Masks I2C Register Masks
N * @{
N */
N
N/*! @name CFG - Configuration for shared functions. */
N/*! @{ */
N#define I2C_CFG_MSTEN_MASK                       (0x1U)
N#define I2C_CFG_MSTEN_SHIFT                      (0U)
N#define I2C_CFG_MSTEN(x)                         (((uint32_t)(((uint32_t)(x)) << I2C_CFG_MSTEN_SHIFT)) & I2C_CFG_MSTEN_MASK)
N#define I2C_CFG_SLVEN_MASK                       (0x2U)
N#define I2C_CFG_SLVEN_SHIFT                      (1U)
N#define I2C_CFG_SLVEN(x)                         (((uint32_t)(((uint32_t)(x)) << I2C_CFG_SLVEN_SHIFT)) & I2C_CFG_SLVEN_MASK)
N#define I2C_CFG_MONEN_MASK                       (0x4U)
N#define I2C_CFG_MONEN_SHIFT                      (2U)
N#define I2C_CFG_MONEN(x)                         (((uint32_t)(((uint32_t)(x)) << I2C_CFG_MONEN_SHIFT)) & I2C_CFG_MONEN_MASK)
N#define I2C_CFG_TIMEOUTEN_MASK                   (0x8U)
N#define I2C_CFG_TIMEOUTEN_SHIFT                  (3U)
N#define I2C_CFG_TIMEOUTEN(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_CFG_TIMEOUTEN_SHIFT)) & I2C_CFG_TIMEOUTEN_MASK)
N#define I2C_CFG_MONCLKSTR_MASK                   (0x10U)
N#define I2C_CFG_MONCLKSTR_SHIFT                  (4U)
N#define I2C_CFG_MONCLKSTR(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_CFG_MONCLKSTR_SHIFT)) & I2C_CFG_MONCLKSTR_MASK)
N/*! @} */
N
N/*! @name STAT - Status register for Master, Slave, and Monitor functions. */
N/*! @{ */
N#define I2C_STAT_MSTPENDING_MASK                 (0x1U)
N#define I2C_STAT_MSTPENDING_SHIFT                (0U)
N#define I2C_STAT_MSTPENDING(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTPENDING_SHIFT)) & I2C_STAT_MSTPENDING_MASK)
N#define I2C_STAT_MSTSTATE_MASK                   (0xEU)
N#define I2C_STAT_MSTSTATE_SHIFT                  (1U)
N#define I2C_STAT_MSTSTATE(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTSTATE_SHIFT)) & I2C_STAT_MSTSTATE_MASK)
N#define I2C_STAT_MSTARBLOSS_MASK                 (0x10U)
N#define I2C_STAT_MSTARBLOSS_SHIFT                (4U)
N#define I2C_STAT_MSTARBLOSS(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTARBLOSS_SHIFT)) & I2C_STAT_MSTARBLOSS_MASK)
N#define I2C_STAT_MSTSTSTPERR_MASK                (0x40U)
N#define I2C_STAT_MSTSTSTPERR_SHIFT               (6U)
N#define I2C_STAT_MSTSTSTPERR(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MSTSTSTPERR_SHIFT)) & I2C_STAT_MSTSTSTPERR_MASK)
N#define I2C_STAT_SLVPENDING_MASK                 (0x100U)
N#define I2C_STAT_SLVPENDING_SHIFT                (8U)
N#define I2C_STAT_SLVPENDING(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVPENDING_SHIFT)) & I2C_STAT_SLVPENDING_MASK)
N#define I2C_STAT_SLVSTATE_MASK                   (0x600U)
N#define I2C_STAT_SLVSTATE_SHIFT                  (9U)
N#define I2C_STAT_SLVSTATE(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVSTATE_SHIFT)) & I2C_STAT_SLVSTATE_MASK)
N#define I2C_STAT_SLVNOTSTR_MASK                  (0x800U)
N#define I2C_STAT_SLVNOTSTR_SHIFT                 (11U)
N#define I2C_STAT_SLVNOTSTR(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVNOTSTR_SHIFT)) & I2C_STAT_SLVNOTSTR_MASK)
N#define I2C_STAT_SLVIDX_MASK                     (0x3000U)
N#define I2C_STAT_SLVIDX_SHIFT                    (12U)
N#define I2C_STAT_SLVIDX(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVIDX_SHIFT)) & I2C_STAT_SLVIDX_MASK)
N#define I2C_STAT_SLVSEL_MASK                     (0x4000U)
N#define I2C_STAT_SLVSEL_SHIFT                    (14U)
N#define I2C_STAT_SLVSEL(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVSEL_SHIFT)) & I2C_STAT_SLVSEL_MASK)
N#define I2C_STAT_SLVDESEL_MASK                   (0x8000U)
N#define I2C_STAT_SLVDESEL_SHIFT                  (15U)
N#define I2C_STAT_SLVDESEL(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SLVDESEL_SHIFT)) & I2C_STAT_SLVDESEL_MASK)
N#define I2C_STAT_MONRDY_MASK                     (0x10000U)
N#define I2C_STAT_MONRDY_SHIFT                    (16U)
N#define I2C_STAT_MONRDY(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONRDY_SHIFT)) & I2C_STAT_MONRDY_MASK)
N#define I2C_STAT_MONOV_MASK                      (0x20000U)
N#define I2C_STAT_MONOV_SHIFT                     (17U)
N#define I2C_STAT_MONOV(x)                        (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONOV_SHIFT)) & I2C_STAT_MONOV_MASK)
N#define I2C_STAT_MONACTIVE_MASK                  (0x40000U)
N#define I2C_STAT_MONACTIVE_SHIFT                 (18U)
N#define I2C_STAT_MONACTIVE(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONACTIVE_SHIFT)) & I2C_STAT_MONACTIVE_MASK)
N#define I2C_STAT_MONIDLE_MASK                    (0x80000U)
N#define I2C_STAT_MONIDLE_SHIFT                   (19U)
N#define I2C_STAT_MONIDLE(x)                      (((uint32_t)(((uint32_t)(x)) << I2C_STAT_MONIDLE_SHIFT)) & I2C_STAT_MONIDLE_MASK)
N#define I2C_STAT_EVENTTIMEOUT_MASK               (0x1000000U)
N#define I2C_STAT_EVENTTIMEOUT_SHIFT              (24U)
N#define I2C_STAT_EVENTTIMEOUT(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_STAT_EVENTTIMEOUT_SHIFT)) & I2C_STAT_EVENTTIMEOUT_MASK)
N#define I2C_STAT_SCLTIMEOUT_MASK                 (0x2000000U)
N#define I2C_STAT_SCLTIMEOUT_SHIFT                (25U)
N#define I2C_STAT_SCLTIMEOUT(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_STAT_SCLTIMEOUT_SHIFT)) & I2C_STAT_SCLTIMEOUT_MASK)
N/*! @} */
N
N/*! @name INTENSET - Interrupt Enable Set and read register. */
N/*! @{ */
N#define I2C_INTENSET_MSTPENDINGEN_MASK           (0x1U)
N#define I2C_INTENSET_MSTPENDINGEN_SHIFT          (0U)
N#define I2C_INTENSET_MSTPENDINGEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MSTPENDINGEN_SHIFT)) & I2C_INTENSET_MSTPENDINGEN_MASK)
N#define I2C_INTENSET_MSTARBLOSSEN_MASK           (0x10U)
N#define I2C_INTENSET_MSTARBLOSSEN_SHIFT          (4U)
N#define I2C_INTENSET_MSTARBLOSSEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MSTARBLOSSEN_SHIFT)) & I2C_INTENSET_MSTARBLOSSEN_MASK)
N#define I2C_INTENSET_MSTSTSTPERREN_MASK          (0x40U)
N#define I2C_INTENSET_MSTSTSTPERREN_SHIFT         (6U)
N#define I2C_INTENSET_MSTSTSTPERREN(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MSTSTSTPERREN_SHIFT)) & I2C_INTENSET_MSTSTSTPERREN_MASK)
N#define I2C_INTENSET_SLVPENDINGEN_MASK           (0x100U)
N#define I2C_INTENSET_SLVPENDINGEN_SHIFT          (8U)
N#define I2C_INTENSET_SLVPENDINGEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SLVPENDINGEN_SHIFT)) & I2C_INTENSET_SLVPENDINGEN_MASK)
N#define I2C_INTENSET_SLVNOTSTREN_MASK            (0x800U)
N#define I2C_INTENSET_SLVNOTSTREN_SHIFT           (11U)
N#define I2C_INTENSET_SLVNOTSTREN(x)              (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SLVNOTSTREN_SHIFT)) & I2C_INTENSET_SLVNOTSTREN_MASK)
N#define I2C_INTENSET_SLVDESELEN_MASK             (0x8000U)
N#define I2C_INTENSET_SLVDESELEN_SHIFT            (15U)
N#define I2C_INTENSET_SLVDESELEN(x)               (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SLVDESELEN_SHIFT)) & I2C_INTENSET_SLVDESELEN_MASK)
N#define I2C_INTENSET_MONRDYEN_MASK               (0x10000U)
N#define I2C_INTENSET_MONRDYEN_SHIFT              (16U)
N#define I2C_INTENSET_MONRDYEN(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MONRDYEN_SHIFT)) & I2C_INTENSET_MONRDYEN_MASK)
N#define I2C_INTENSET_MONOVEN_MASK                (0x20000U)
N#define I2C_INTENSET_MONOVEN_SHIFT               (17U)
N#define I2C_INTENSET_MONOVEN(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MONOVEN_SHIFT)) & I2C_INTENSET_MONOVEN_MASK)
N#define I2C_INTENSET_MONIDLEEN_MASK              (0x80000U)
N#define I2C_INTENSET_MONIDLEEN_SHIFT             (19U)
N#define I2C_INTENSET_MONIDLEEN(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_MONIDLEEN_SHIFT)) & I2C_INTENSET_MONIDLEEN_MASK)
N#define I2C_INTENSET_EVENTTIMEOUTEN_MASK         (0x1000000U)
N#define I2C_INTENSET_EVENTTIMEOUTEN_SHIFT        (24U)
N#define I2C_INTENSET_EVENTTIMEOUTEN(x)           (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_EVENTTIMEOUTEN_SHIFT)) & I2C_INTENSET_EVENTTIMEOUTEN_MASK)
N#define I2C_INTENSET_SCLTIMEOUTEN_MASK           (0x2000000U)
N#define I2C_INTENSET_SCLTIMEOUTEN_SHIFT          (25U)
N#define I2C_INTENSET_SCLTIMEOUTEN(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENSET_SCLTIMEOUTEN_SHIFT)) & I2C_INTENSET_SCLTIMEOUTEN_MASK)
N/*! @} */
N
N/*! @name INTENCLR - Interrupt Enable Clear register. */
N/*! @{ */
N#define I2C_INTENCLR_MSTPENDINGCLR_MASK          (0x1U)
N#define I2C_INTENCLR_MSTPENDINGCLR_SHIFT         (0U)
N#define I2C_INTENCLR_MSTPENDINGCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MSTPENDINGCLR_SHIFT)) & I2C_INTENCLR_MSTPENDINGCLR_MASK)
N#define I2C_INTENCLR_MSTARBLOSSCLR_MASK          (0x10U)
N#define I2C_INTENCLR_MSTARBLOSSCLR_SHIFT         (4U)
N#define I2C_INTENCLR_MSTARBLOSSCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MSTARBLOSSCLR_SHIFT)) & I2C_INTENCLR_MSTARBLOSSCLR_MASK)
N#define I2C_INTENCLR_MSTSTSTPERRCLR_MASK         (0x40U)
N#define I2C_INTENCLR_MSTSTSTPERRCLR_SHIFT        (6U)
N#define I2C_INTENCLR_MSTSTSTPERRCLR(x)           (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MSTSTSTPERRCLR_SHIFT)) & I2C_INTENCLR_MSTSTSTPERRCLR_MASK)
N#define I2C_INTENCLR_SLVPENDINGCLR_MASK          (0x100U)
N#define I2C_INTENCLR_SLVPENDINGCLR_SHIFT         (8U)
N#define I2C_INTENCLR_SLVPENDINGCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SLVPENDINGCLR_SHIFT)) & I2C_INTENCLR_SLVPENDINGCLR_MASK)
N#define I2C_INTENCLR_SLVNOTSTRCLR_MASK           (0x800U)
N#define I2C_INTENCLR_SLVNOTSTRCLR_SHIFT          (11U)
N#define I2C_INTENCLR_SLVNOTSTRCLR(x)             (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SLVNOTSTRCLR_SHIFT)) & I2C_INTENCLR_SLVNOTSTRCLR_MASK)
N#define I2C_INTENCLR_SLVDESELCLR_MASK            (0x8000U)
N#define I2C_INTENCLR_SLVDESELCLR_SHIFT           (15U)
N#define I2C_INTENCLR_SLVDESELCLR(x)              (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SLVDESELCLR_SHIFT)) & I2C_INTENCLR_SLVDESELCLR_MASK)
N#define I2C_INTENCLR_MONRDYCLR_MASK              (0x10000U)
N#define I2C_INTENCLR_MONRDYCLR_SHIFT             (16U)
N#define I2C_INTENCLR_MONRDYCLR(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MONRDYCLR_SHIFT)) & I2C_INTENCLR_MONRDYCLR_MASK)
N#define I2C_INTENCLR_MONOVCLR_MASK               (0x20000U)
N#define I2C_INTENCLR_MONOVCLR_SHIFT              (17U)
N#define I2C_INTENCLR_MONOVCLR(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MONOVCLR_SHIFT)) & I2C_INTENCLR_MONOVCLR_MASK)
N#define I2C_INTENCLR_MONIDLECLR_MASK             (0x80000U)
N#define I2C_INTENCLR_MONIDLECLR_SHIFT            (19U)
N#define I2C_INTENCLR_MONIDLECLR(x)               (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_MONIDLECLR_SHIFT)) & I2C_INTENCLR_MONIDLECLR_MASK)
N#define I2C_INTENCLR_EVENTTIMEOUTCLR_MASK        (0x1000000U)
N#define I2C_INTENCLR_EVENTTIMEOUTCLR_SHIFT       (24U)
N#define I2C_INTENCLR_EVENTTIMEOUTCLR(x)          (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_EVENTTIMEOUTCLR_SHIFT)) & I2C_INTENCLR_EVENTTIMEOUTCLR_MASK)
N#define I2C_INTENCLR_SCLTIMEOUTCLR_MASK          (0x2000000U)
N#define I2C_INTENCLR_SCLTIMEOUTCLR_SHIFT         (25U)
N#define I2C_INTENCLR_SCLTIMEOUTCLR(x)            (((uint32_t)(((uint32_t)(x)) << I2C_INTENCLR_SCLTIMEOUTCLR_SHIFT)) & I2C_INTENCLR_SCLTIMEOUTCLR_MASK)
N/*! @} */
N
N/*! @name TIMEOUT - Time-out value register. */
N/*! @{ */
N#define I2C_TIMEOUT_TOMIN_MASK                   (0xFU)
N#define I2C_TIMEOUT_TOMIN_SHIFT                  (0U)
N#define I2C_TIMEOUT_TOMIN(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_TIMEOUT_TOMIN_SHIFT)) & I2C_TIMEOUT_TOMIN_MASK)
N#define I2C_TIMEOUT_TO_MASK                      (0xFFF0U)
N#define I2C_TIMEOUT_TO_SHIFT                     (4U)
N#define I2C_TIMEOUT_TO(x)                        (((uint32_t)(((uint32_t)(x)) << I2C_TIMEOUT_TO_SHIFT)) & I2C_TIMEOUT_TO_MASK)
N/*! @} */
N
N/*! @name CLKDIV - Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register, and controls some timing of the Slave function. */
N/*! @{ */
N#define I2C_CLKDIV_DIVVAL_MASK                   (0xFFFFU)
N#define I2C_CLKDIV_DIVVAL_SHIFT                  (0U)
N#define I2C_CLKDIV_DIVVAL(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_CLKDIV_DIVVAL_SHIFT)) & I2C_CLKDIV_DIVVAL_MASK)
N/*! @} */
N
N/*! @name INTSTAT - Interrupt Status register for Master, Slave, and Monitor functions. */
N/*! @{ */
N#define I2C_INTSTAT_MSTPENDING_MASK              (0x1U)
N#define I2C_INTSTAT_MSTPENDING_SHIFT             (0U)
N#define I2C_INTSTAT_MSTPENDING(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MSTPENDING_SHIFT)) & I2C_INTSTAT_MSTPENDING_MASK)
N#define I2C_INTSTAT_MSTARBLOSS_MASK              (0x10U)
N#define I2C_INTSTAT_MSTARBLOSS_SHIFT             (4U)
N#define I2C_INTSTAT_MSTARBLOSS(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MSTARBLOSS_SHIFT)) & I2C_INTSTAT_MSTARBLOSS_MASK)
N#define I2C_INTSTAT_MSTSTSTPERR_MASK             (0x40U)
N#define I2C_INTSTAT_MSTSTSTPERR_SHIFT            (6U)
N#define I2C_INTSTAT_MSTSTSTPERR(x)               (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MSTSTSTPERR_SHIFT)) & I2C_INTSTAT_MSTSTSTPERR_MASK)
N#define I2C_INTSTAT_SLVPENDING_MASK              (0x100U)
N#define I2C_INTSTAT_SLVPENDING_SHIFT             (8U)
N#define I2C_INTSTAT_SLVPENDING(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SLVPENDING_SHIFT)) & I2C_INTSTAT_SLVPENDING_MASK)
N#define I2C_INTSTAT_SLVNOTSTR_MASK               (0x800U)
N#define I2C_INTSTAT_SLVNOTSTR_SHIFT              (11U)
N#define I2C_INTSTAT_SLVNOTSTR(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SLVNOTSTR_SHIFT)) & I2C_INTSTAT_SLVNOTSTR_MASK)
N#define I2C_INTSTAT_SLVDESEL_MASK                (0x8000U)
N#define I2C_INTSTAT_SLVDESEL_SHIFT               (15U)
N#define I2C_INTSTAT_SLVDESEL(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SLVDESEL_SHIFT)) & I2C_INTSTAT_SLVDESEL_MASK)
N#define I2C_INTSTAT_MONRDY_MASK                  (0x10000U)
N#define I2C_INTSTAT_MONRDY_SHIFT                 (16U)
N#define I2C_INTSTAT_MONRDY(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MONRDY_SHIFT)) & I2C_INTSTAT_MONRDY_MASK)
N#define I2C_INTSTAT_MONOV_MASK                   (0x20000U)
N#define I2C_INTSTAT_MONOV_SHIFT                  (17U)
N#define I2C_INTSTAT_MONOV(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MONOV_SHIFT)) & I2C_INTSTAT_MONOV_MASK)
N#define I2C_INTSTAT_MONIDLE_MASK                 (0x80000U)
N#define I2C_INTSTAT_MONIDLE_SHIFT                (19U)
N#define I2C_INTSTAT_MONIDLE(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_MONIDLE_SHIFT)) & I2C_INTSTAT_MONIDLE_MASK)
N#define I2C_INTSTAT_EVENTTIMEOUT_MASK            (0x1000000U)
N#define I2C_INTSTAT_EVENTTIMEOUT_SHIFT           (24U)
N#define I2C_INTSTAT_EVENTTIMEOUT(x)              (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_EVENTTIMEOUT_SHIFT)) & I2C_INTSTAT_EVENTTIMEOUT_MASK)
N#define I2C_INTSTAT_SCLTIMEOUT_MASK              (0x2000000U)
N#define I2C_INTSTAT_SCLTIMEOUT_SHIFT             (25U)
N#define I2C_INTSTAT_SCLTIMEOUT(x)                (((uint32_t)(((uint32_t)(x)) << I2C_INTSTAT_SCLTIMEOUT_SHIFT)) & I2C_INTSTAT_SCLTIMEOUT_MASK)
N/*! @} */
N
N/*! @name MSTCTL - Master control register. */
N/*! @{ */
N#define I2C_MSTCTL_MSTCONTINUE_MASK              (0x1U)
N#define I2C_MSTCTL_MSTCONTINUE_SHIFT             (0U)
N#define I2C_MSTCTL_MSTCONTINUE(x)                (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTCONTINUE_SHIFT)) & I2C_MSTCTL_MSTCONTINUE_MASK)
N#define I2C_MSTCTL_MSTSTART_MASK                 (0x2U)
N#define I2C_MSTCTL_MSTSTART_SHIFT                (1U)
N#define I2C_MSTCTL_MSTSTART(x)                   (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTSTART_SHIFT)) & I2C_MSTCTL_MSTSTART_MASK)
N#define I2C_MSTCTL_MSTSTOP_MASK                  (0x4U)
N#define I2C_MSTCTL_MSTSTOP_SHIFT                 (2U)
N#define I2C_MSTCTL_MSTSTOP(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTSTOP_SHIFT)) & I2C_MSTCTL_MSTSTOP_MASK)
N#define I2C_MSTCTL_MSTDMA_MASK                   (0x8U)
N#define I2C_MSTCTL_MSTDMA_SHIFT                  (3U)
N#define I2C_MSTCTL_MSTDMA(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_MSTCTL_MSTDMA_SHIFT)) & I2C_MSTCTL_MSTDMA_MASK)
N/*! @} */
N
N/*! @name MSTTIME - Master timing configuration. */
N/*! @{ */
N#define I2C_MSTTIME_MSTSCLLOW_MASK               (0x7U)
N#define I2C_MSTTIME_MSTSCLLOW_SHIFT              (0U)
N#define I2C_MSTTIME_MSTSCLLOW(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_MSTTIME_MSTSCLLOW_SHIFT)) & I2C_MSTTIME_MSTSCLLOW_MASK)
N#define I2C_MSTTIME_MSTSCLHIGH_MASK              (0x70U)
N#define I2C_MSTTIME_MSTSCLHIGH_SHIFT             (4U)
N#define I2C_MSTTIME_MSTSCLHIGH(x)                (((uint32_t)(((uint32_t)(x)) << I2C_MSTTIME_MSTSCLHIGH_SHIFT)) & I2C_MSTTIME_MSTSCLHIGH_MASK)
N/*! @} */
N
N/*! @name MSTDAT - Combined Master receiver and transmitter data register. */
N/*! @{ */
N#define I2C_MSTDAT_DATA_MASK                     (0xFFU)
N#define I2C_MSTDAT_DATA_SHIFT                    (0U)
N#define I2C_MSTDAT_DATA(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_MSTDAT_DATA_SHIFT)) & I2C_MSTDAT_DATA_MASK)
N/*! @} */
N
N/*! @name SLVCTL - Slave control register. */
N/*! @{ */
N#define I2C_SLVCTL_SLVCONTINUE_MASK              (0x1U)
N#define I2C_SLVCTL_SLVCONTINUE_SHIFT             (0U)
N#define I2C_SLVCTL_SLVCONTINUE(x)                (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_SLVCONTINUE_SHIFT)) & I2C_SLVCTL_SLVCONTINUE_MASK)
N#define I2C_SLVCTL_SLVNACK_MASK                  (0x2U)
N#define I2C_SLVCTL_SLVNACK_SHIFT                 (1U)
N#define I2C_SLVCTL_SLVNACK(x)                    (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_SLVNACK_SHIFT)) & I2C_SLVCTL_SLVNACK_MASK)
N#define I2C_SLVCTL_SLVDMA_MASK                   (0x8U)
N#define I2C_SLVCTL_SLVDMA_SHIFT                  (3U)
N#define I2C_SLVCTL_SLVDMA(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_SLVCTL_SLVDMA_SHIFT)) & I2C_SLVCTL_SLVDMA_MASK)
N/*! @} */
N
N/*! @name SLVDAT - Combined Slave receiver and transmitter data register. */
N/*! @{ */
N#define I2C_SLVDAT_DATA_MASK                     (0xFFU)
N#define I2C_SLVDAT_DATA_SHIFT                    (0U)
N#define I2C_SLVDAT_DATA(x)                       (((uint32_t)(((uint32_t)(x)) << I2C_SLVDAT_DATA_SHIFT)) & I2C_SLVDAT_DATA_MASK)
N/*! @} */
N
N/*! @name SLVADR - Slave address register. */
N/*! @{ */
N#define I2C_SLVADR_SADISABLE_MASK                (0x1U)
N#define I2C_SLVADR_SADISABLE_SHIFT               (0U)
N#define I2C_SLVADR_SADISABLE(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_SLVADR_SADISABLE_SHIFT)) & I2C_SLVADR_SADISABLE_MASK)
N#define I2C_SLVADR_SLVADR_MASK                   (0xFEU)
N#define I2C_SLVADR_SLVADR_SHIFT                  (1U)
N#define I2C_SLVADR_SLVADR(x)                     (((uint32_t)(((uint32_t)(x)) << I2C_SLVADR_SLVADR_SHIFT)) & I2C_SLVADR_SLVADR_MASK)
N/*! @} */
N
N/* The count of I2C_SLVADR */
N#define I2C_SLVADR_COUNT                         (4U)
N
N/*! @name SLVQUAL0 - Slave Qualification for address 0. */
N/*! @{ */
N#define I2C_SLVQUAL0_QUALMODE0_MASK              (0x1U)
N#define I2C_SLVQUAL0_QUALMODE0_SHIFT             (0U)
N#define I2C_SLVQUAL0_QUALMODE0(x)                (((uint32_t)(((uint32_t)(x)) << I2C_SLVQUAL0_QUALMODE0_SHIFT)) & I2C_SLVQUAL0_QUALMODE0_MASK)
N#define I2C_SLVQUAL0_SLVQUAL0_MASK               (0xFEU)
N#define I2C_SLVQUAL0_SLVQUAL0_SHIFT              (1U)
N#define I2C_SLVQUAL0_SLVQUAL0(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_SLVQUAL0_SLVQUAL0_SHIFT)) & I2C_SLVQUAL0_SLVQUAL0_MASK)
N/*! @} */
N
N/*! @name MONRXDAT - Monitor receiver data register. */
N/*! @{ */
N#define I2C_MONRXDAT_MONRXDAT_MASK               (0xFFU)
N#define I2C_MONRXDAT_MONRXDAT_SHIFT              (0U)
N#define I2C_MONRXDAT_MONRXDAT(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONRXDAT_SHIFT)) & I2C_MONRXDAT_MONRXDAT_MASK)
N#define I2C_MONRXDAT_MONSTART_MASK               (0x100U)
N#define I2C_MONRXDAT_MONSTART_SHIFT              (8U)
N#define I2C_MONRXDAT_MONSTART(x)                 (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONSTART_SHIFT)) & I2C_MONRXDAT_MONSTART_MASK)
N#define I2C_MONRXDAT_MONRESTART_MASK             (0x200U)
N#define I2C_MONRXDAT_MONRESTART_SHIFT            (9U)
N#define I2C_MONRXDAT_MONRESTART(x)               (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONRESTART_SHIFT)) & I2C_MONRXDAT_MONRESTART_MASK)
N#define I2C_MONRXDAT_MONNACK_MASK                (0x400U)
N#define I2C_MONRXDAT_MONNACK_SHIFT               (10U)
N#define I2C_MONRXDAT_MONNACK(x)                  (((uint32_t)(((uint32_t)(x)) << I2C_MONRXDAT_MONNACK_SHIFT)) & I2C_MONRXDAT_MONNACK_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group I2C_Register_Masks */
N
N
N/* I2C - Peripheral instance base addresses */
N/** Peripheral I2C0 base address */
N#define I2C0_BASE                                (0x40050000u)
N/** Peripheral I2C0 base pointer */
N#define I2C0                                     ((I2C_Type *)I2C0_BASE)
N/** Peripheral I2C1 base address */
N#define I2C1_BASE                                (0x40054000u)
N/** Peripheral I2C1 base pointer */
N#define I2C1                                     ((I2C_Type *)I2C1_BASE)
N/** Peripheral I2C2 base address */
N#define I2C2_BASE                                (0x40070000u)
N/** Peripheral I2C2 base pointer */
N#define I2C2                                     ((I2C_Type *)I2C2_BASE)
N/** Peripheral I2C3 base address */
N#define I2C3_BASE                                (0x40074000u)
N/** Peripheral I2C3 base pointer */
N#define I2C3                                     ((I2C_Type *)I2C3_BASE)
N/** Array initializer of I2C peripheral base addresses */
N#define I2C_BASE_ADDRS                           { I2C0_BASE, I2C1_BASE, I2C2_BASE, I2C3_BASE }
N/** Array initializer of I2C peripheral base pointers */
N#define I2C_BASE_PTRS                            { I2C0, I2C1, I2C2, I2C3 }
N/** Interrupt vectors for the I2C peripheral type */
N#define I2C_IRQS                                 { I2C0_IRQn, I2C1_IRQn, I2C2_IRQn, I2C3_IRQn }
N
N/*!
N * @}
N */ /* end of group I2C_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- INPUTMUX Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup INPUTMUX_Peripheral_Access_Layer INPUTMUX Peripheral Access Layer
N * @{
N */
N
N/** INPUTMUX - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t DMA_ITRIG_INMUX[18];               /**< Trigger select register for DMA channel, array offset: 0x0, array step: 0x4 */
X  volatile uint32_t DMA_ITRIG_INMUX[18];                
N       uint8_t RESERVED_0[16312];
N  __IO uint32_t DMA_INMUX_INMUX[2];                /**< Input mux register for DMA trigger input 20. Selects from 18 DMA trigger outputs, array offset: 0x4000, array step: 0x4 */
X  volatile uint32_t DMA_INMUX_INMUX[2];                 
N       uint8_t RESERVED_1[24];
N  __IO uint32_t SCT0_INMUX[4];                     /**< input select register for SCT, array offset: 0x4020, array step: 0x4 */
X  volatile uint32_t SCT0_INMUX[4];                      
N} INPUTMUX_Type;
N
N/* ----------------------------------------------------------------------------
N   -- INPUTMUX Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup INPUTMUX_Register_Masks INPUTMUX Register Masks
N * @{
N */
N
N/*! @name DMA_ITRIG_INMUX - Trigger select register for DMA channel */
N/*! @{ */
N#define INPUTMUX_DMA_ITRIG_INMUX_INP_MASK        (0xFU)
N#define INPUTMUX_DMA_ITRIG_INMUX_INP_SHIFT       (0U)
N#define INPUTMUX_DMA_ITRIG_INMUX_INP(x)          (((uint32_t)(((uint32_t)(x)) << INPUTMUX_DMA_ITRIG_INMUX_INP_SHIFT)) & INPUTMUX_DMA_ITRIG_INMUX_INP_MASK)
N/*! @} */
N
N/* The count of INPUTMUX_DMA_ITRIG_INMUX */
N#define INPUTMUX_DMA_ITRIG_INMUX_COUNT           (18U)
N
N/*! @name DMA_INMUX_INMUX - Input mux register for DMA trigger input 20. Selects from 18 DMA trigger outputs */
N/*! @{ */
N#define INPUTMUX_DMA_INMUX_INMUX_INP_MASK        (0x1FU)
N#define INPUTMUX_DMA_INMUX_INMUX_INP_SHIFT       (0U)
N#define INPUTMUX_DMA_INMUX_INMUX_INP(x)          (((uint32_t)(((uint32_t)(x)) << INPUTMUX_DMA_INMUX_INMUX_INP_SHIFT)) & INPUTMUX_DMA_INMUX_INMUX_INP_MASK)
N/*! @} */
N
N/* The count of INPUTMUX_DMA_INMUX_INMUX */
N#define INPUTMUX_DMA_INMUX_INMUX_COUNT           (2U)
N
N/*! @name SCT0_INMUX - input select register for SCT */
N/*! @{ */
N#define INPUTMUX_SCT0_INMUX_INP_N_MASK           (0xFU)
N#define INPUTMUX_SCT0_INMUX_INP_N_SHIFT          (0U)
N#define INPUTMUX_SCT0_INMUX_INP_N(x)             (((uint32_t)(((uint32_t)(x)) << INPUTMUX_SCT0_INMUX_INP_N_SHIFT)) & INPUTMUX_SCT0_INMUX_INP_N_MASK)
N/*! @} */
N
N/* The count of INPUTMUX_SCT0_INMUX */
N#define INPUTMUX_SCT0_INMUX_COUNT                (4U)
N
N
N/*!
N * @}
N */ /* end of group INPUTMUX_Register_Masks */
N
N
N/* INPUTMUX - Peripheral instance base addresses */
N/** Peripheral INPUTMUX base address */
N#define INPUTMUX_BASE                            (0x40028000u)
N/** Peripheral INPUTMUX base pointer */
N#define INPUTMUX                                 ((INPUTMUX_Type *)INPUTMUX_BASE)
N/** Array initializer of INPUTMUX peripheral base addresses */
N#define INPUTMUX_BASE_ADDRS                      { INPUTMUX_BASE }
N/** Array initializer of INPUTMUX peripheral base pointers */
N#define INPUTMUX_BASE_PTRS                       { INPUTMUX }
N
N/*!
N * @}
N */ /* end of group INPUTMUX_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- IOCON Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup IOCON_Peripheral_Access_Layer IOCON Peripheral Access Layer
N * @{
N */
N
N/** IOCON - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t PIO[30];                           /**< Digital I/O control for port 0 pins PIO0..Digital I/O control for port 0 pins PIO29, array offset: 0x0, array step: 0x4 */
X  volatile uint32_t PIO[30];                            
N} IOCON_Type;
N
N/* ----------------------------------------------------------------------------
N   -- IOCON Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup IOCON_Register_Masks IOCON Register Masks
N * @{
N */
N
N/*! @name PIO - Digital I/O control for port 0 pins PIO0..Digital I/O control for port 0 pins PIO29 */
N/*! @{ */
N#define IOCON_PIO_MODE_MASK                      (0x18U)
N#define IOCON_PIO_MODE_SHIFT                     (3U)
N#define IOCON_PIO_MODE(x)                        (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_MODE_SHIFT)) & IOCON_PIO_MODE_MASK)
N#define IOCON_PIO_HYS_MASK                       (0x20U)
N#define IOCON_PIO_HYS_SHIFT                      (5U)
N#define IOCON_PIO_HYS(x)                         (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_HYS_SHIFT)) & IOCON_PIO_HYS_MASK)
N#define IOCON_PIO_INV_MASK                       (0x40U)
N#define IOCON_PIO_INV_SHIFT                      (6U)
N#define IOCON_PIO_INV(x)                         (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_INV_SHIFT)) & IOCON_PIO_INV_MASK)
N#define IOCON_PIO_I2CMODE_MASK                   (0x300U)
N#define IOCON_PIO_I2CMODE_SHIFT                  (8U)
N#define IOCON_PIO_I2CMODE(x)                     (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_I2CMODE_SHIFT)) & IOCON_PIO_I2CMODE_MASK)
N#define IOCON_PIO_OD_MASK                        (0x400U)
N#define IOCON_PIO_OD_SHIFT                       (10U)
N#define IOCON_PIO_OD(x)                          (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_OD_SHIFT)) & IOCON_PIO_OD_MASK)
N#define IOCON_PIO_S_MODE_MASK                    (0x1800U)
N#define IOCON_PIO_S_MODE_SHIFT                   (11U)
N#define IOCON_PIO_S_MODE(x)                      (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_S_MODE_SHIFT)) & IOCON_PIO_S_MODE_MASK)
N#define IOCON_PIO_CLK_DIV_MASK                   (0xE000U)
N#define IOCON_PIO_CLK_DIV_SHIFT                  (13U)
N#define IOCON_PIO_CLK_DIV(x)                     (((uint32_t)(((uint32_t)(x)) << IOCON_PIO_CLK_DIV_SHIFT)) & IOCON_PIO_CLK_DIV_MASK)
N/*! @} */
N
N/* The count of IOCON_PIO */
N#define IOCON_PIO_COUNT                          (30U)
N
N
N/*!
N * @}
N */ /* end of group IOCON_Register_Masks */
N
N
N/* IOCON - Peripheral instance base addresses */
N/** Peripheral IOCON base address */
N#define IOCON_BASE                               (0x40044000u)
N/** Peripheral IOCON base pointer */
N#define IOCON                                    ((IOCON_Type *)IOCON_BASE)
N/** Array initializer of IOCON peripheral base addresses */
N#define IOCON_BASE_ADDRS                         { IOCON_BASE }
N/** Array initializer of IOCON peripheral base pointers */
N#define IOCON_BASE_PTRS                          { IOCON }
N
N#define    IOCON_INDEX_PIO0_17       (0 )
N#define    IOCON_INDEX_PIO0_13       (1 )
N#define    IOCON_INDEX_PIO0_12       (2 )
N#define    IOCON_INDEX_PIO0_5        (3 )
N#define    IOCON_INDEX_PIO0_4        (4 )
N#define    IOCON_INDEX_PIO0_3        (5 )
N#define    IOCON_INDEX_PIO0_2        (6 )
N#define    IOCON_INDEX_PIO0_11       (7 )
N#define    IOCON_INDEX_PIO0_10       (8 )
N#define    IOCON_INDEX_PIO0_16       (9 )
N#define    IOCON_INDEX_PIO0_15       (10)
N#define    IOCON_INDEX_PIO0_1        (11)
N#define    IOCON_INDEX_PIO0_9        (13)
N#define    IOCON_INDEX_PIO0_8        (14)
N#define    IOCON_INDEX_PIO0_7        (15)
N#define    IOCON_INDEX_PIO0_6        (16)
N#define    IOCON_INDEX_PIO0_0        (17)
N#define    IOCON_INDEX_PIO0_14       (18)
N#define    IOCON_INDEX_PIO0_28       (20)
N#define    IOCON_INDEX_PIO0_27       (21)
N#define    IOCON_INDEX_PIO0_26       (22)
N#define    IOCON_INDEX_PIO0_25       (23)
N#define    IOCON_INDEX_PIO0_24       (24)
N#define    IOCON_INDEX_PIO0_23       (25)
N#define    IOCON_INDEX_PIO0_22       (26)
N#define    IOCON_INDEX_PIO0_21       (27)
N#define    IOCON_INDEX_PIO0_20       (28)
N#define    IOCON_INDEX_PIO0_19       (29)
N#define    IOCON_INDEX_PIO0_18       (30)
N
N
N/*!
N * @}
N */ /* end of group IOCON_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- MRT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup MRT_Peripheral_Access_Layer MRT Peripheral Access Layer
N * @{
N */
N
N/** MRT - Register Layout Typedef */
Ntypedef struct {
N  struct {                                         /* offset: 0x0, array step: 0x10 */
N    __IO uint32_t INTVAL;                            /**< MRT Time interval value register. This value is loaded into the TIMER register., array offset: 0x0, array step: 0x10 */
X    volatile uint32_t INTVAL;                             
N    __I  uint32_t TIMER;                             /**< MRT Timer register. This register reads the value of the down-counter., array offset: 0x4, array step: 0x10 */
X    volatile const  uint32_t TIMER;                              
N    __IO uint32_t CTRL;                              /**< MRT Control register. This register controls the MRT modes., array offset: 0x8, array step: 0x10 */
X    volatile uint32_t CTRL;                               
N    __IO uint32_t STAT;                              /**< MRT Status register., array offset: 0xC, array step: 0x10 */
X    volatile uint32_t STAT;                               
N  } CHANNEL[4];
N       uint8_t RESERVED_0[176];
N  __I  uint32_t MODCFG;                            /**< Module Configuration register. This register provides information about this particular MRT instance., offset: 0xF0 */
X  volatile const  uint32_t MODCFG;                             
N  __I  uint32_t IDLE_CH;                           /**< Idle channel register. This register returns the number of the first idle channel., offset: 0xF4 */
X  volatile const  uint32_t IDLE_CH;                            
N  __IO uint32_t IRQ_FLAG;                          /**< Global interrupt flag register, offset: 0xF8 */
X  volatile uint32_t IRQ_FLAG;                           
N} MRT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- MRT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup MRT_Register_Masks MRT Register Masks
N * @{
N */
N
N/*! @name CHANNEL_INTVAL - MRT Time interval value register. This value is loaded into the TIMER register. */
N/*! @{ */
N#define MRT_CHANNEL_INTVAL_IVALUE_MASK           (0x7FFFFFFFU)
N#define MRT_CHANNEL_INTVAL_IVALUE_SHIFT          (0U)
N#define MRT_CHANNEL_INTVAL_IVALUE(x)             (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_INTVAL_IVALUE_SHIFT)) & MRT_CHANNEL_INTVAL_IVALUE_MASK)
N#define MRT_CHANNEL_INTVAL_LOAD_MASK             (0x80000000U)
N#define MRT_CHANNEL_INTVAL_LOAD_SHIFT            (31U)
N#define MRT_CHANNEL_INTVAL_LOAD(x)               (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_INTVAL_LOAD_SHIFT)) & MRT_CHANNEL_INTVAL_LOAD_MASK)
N/*! @} */
N
N/* The count of MRT_CHANNEL_INTVAL */
N#define MRT_CHANNEL_INTVAL_COUNT                 (4U)
N
N/*! @name CHANNEL_TIMER - MRT Timer register. This register reads the value of the down-counter. */
N/*! @{ */
N#define MRT_CHANNEL_TIMER_VALUE_MASK             (0x7FFFFFFFU)
N#define MRT_CHANNEL_TIMER_VALUE_SHIFT            (0U)
N#define MRT_CHANNEL_TIMER_VALUE(x)               (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_TIMER_VALUE_SHIFT)) & MRT_CHANNEL_TIMER_VALUE_MASK)
N/*! @} */
N
N/* The count of MRT_CHANNEL_TIMER */
N#define MRT_CHANNEL_TIMER_COUNT                  (4U)
N
N/*! @name CHANNEL_CTRL - MRT Control register. This register controls the MRT modes. */
N/*! @{ */
N#define MRT_CHANNEL_CTRL_INTEN_MASK              (0x1U)
N#define MRT_CHANNEL_CTRL_INTEN_SHIFT             (0U)
N#define MRT_CHANNEL_CTRL_INTEN(x)                (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_CTRL_INTEN_SHIFT)) & MRT_CHANNEL_CTRL_INTEN_MASK)
N#define MRT_CHANNEL_CTRL_MODE_MASK               (0x6U)
N#define MRT_CHANNEL_CTRL_MODE_SHIFT              (1U)
N#define MRT_CHANNEL_CTRL_MODE(x)                 (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_CTRL_MODE_SHIFT)) & MRT_CHANNEL_CTRL_MODE_MASK)
N/*! @} */
N
N/* The count of MRT_CHANNEL_CTRL */
N#define MRT_CHANNEL_CTRL_COUNT                   (4U)
N
N/*! @name CHANNEL_STAT - MRT Status register. */
N/*! @{ */
N#define MRT_CHANNEL_STAT_INTFLAG_MASK            (0x1U)
N#define MRT_CHANNEL_STAT_INTFLAG_SHIFT           (0U)
N#define MRT_CHANNEL_STAT_INTFLAG(x)              (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_STAT_INTFLAG_SHIFT)) & MRT_CHANNEL_STAT_INTFLAG_MASK)
N#define MRT_CHANNEL_STAT_RUN_MASK                (0x2U)
N#define MRT_CHANNEL_STAT_RUN_SHIFT               (1U)
N#define MRT_CHANNEL_STAT_RUN(x)                  (((uint32_t)(((uint32_t)(x)) << MRT_CHANNEL_STAT_RUN_SHIFT)) & MRT_CHANNEL_STAT_RUN_MASK)
N/*! @} */
N
N/* The count of MRT_CHANNEL_STAT */
N#define MRT_CHANNEL_STAT_COUNT                   (4U)
N
N/*! @name MODCFG - Module Configuration register. This register provides information about this particular MRT instance. */
N/*! @{ */
N#define MRT_MODCFG_NOC_MASK                      (0xFU)
N#define MRT_MODCFG_NOC_SHIFT                     (0U)
N#define MRT_MODCFG_NOC(x)                        (((uint32_t)(((uint32_t)(x)) << MRT_MODCFG_NOC_SHIFT)) & MRT_MODCFG_NOC_MASK)
N#define MRT_MODCFG_NOB_MASK                      (0x1F0U)
N#define MRT_MODCFG_NOB_SHIFT                     (4U)
N#define MRT_MODCFG_NOB(x)                        (((uint32_t)(((uint32_t)(x)) << MRT_MODCFG_NOB_SHIFT)) & MRT_MODCFG_NOB_MASK)
N/*! @} */
N
N/*! @name IDLE_CH - Idle channel register. This register returns the number of the first idle channel. */
N/*! @{ */
N#define MRT_IDLE_CH_CHAN_MASK                    (0xF0U)
N#define MRT_IDLE_CH_CHAN_SHIFT                   (4U)
N#define MRT_IDLE_CH_CHAN(x)                      (((uint32_t)(((uint32_t)(x)) << MRT_IDLE_CH_CHAN_SHIFT)) & MRT_IDLE_CH_CHAN_MASK)
N/*! @} */
N
N/*! @name IRQ_FLAG - Global interrupt flag register */
N/*! @{ */
N#define MRT_IRQ_FLAG_GFLAG0_MASK                 (0x1U)
N#define MRT_IRQ_FLAG_GFLAG0_SHIFT                (0U)
N#define MRT_IRQ_FLAG_GFLAG0(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG0_SHIFT)) & MRT_IRQ_FLAG_GFLAG0_MASK)
N#define MRT_IRQ_FLAG_GFLAG1_MASK                 (0x2U)
N#define MRT_IRQ_FLAG_GFLAG1_SHIFT                (1U)
N#define MRT_IRQ_FLAG_GFLAG1(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG1_SHIFT)) & MRT_IRQ_FLAG_GFLAG1_MASK)
N#define MRT_IRQ_FLAG_GFLAG2_MASK                 (0x4U)
N#define MRT_IRQ_FLAG_GFLAG2_SHIFT                (2U)
N#define MRT_IRQ_FLAG_GFLAG2(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG2_SHIFT)) & MRT_IRQ_FLAG_GFLAG2_MASK)
N#define MRT_IRQ_FLAG_GFLAG3_MASK                 (0x8U)
N#define MRT_IRQ_FLAG_GFLAG3_SHIFT                (3U)
N#define MRT_IRQ_FLAG_GFLAG3(x)                   (((uint32_t)(((uint32_t)(x)) << MRT_IRQ_FLAG_GFLAG3_SHIFT)) & MRT_IRQ_FLAG_GFLAG3_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group MRT_Register_Masks */
N
N
N/* MRT - Peripheral instance base addresses */
N/** Peripheral MRT0 base address */
N#define MRT0_BASE                                (0x40004000u)
N/** Peripheral MRT0 base pointer */
N#define MRT0                                     ((MRT_Type *)MRT0_BASE)
N/** Array initializer of MRT peripheral base addresses */
N#define MRT_BASE_ADDRS                           { MRT0_BASE }
N/** Array initializer of MRT peripheral base pointers */
N#define MRT_BASE_PTRS                            { MRT0 }
N
N/*!
N * @}
N */ /* end of group MRT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- MTB Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup MTB_Peripheral_Access_Layer MTB Peripheral Access Layer
N * @{
N */
N
N/** MTB - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t POSITION;                          /**< POSITION Register, offset: 0x0 */
X  volatile uint32_t POSITION;                           
N  __IO uint32_t MASTER;                            /**< MASTER Register, offset: 0x4 */
X  volatile uint32_t MASTER;                             
N  __IO uint32_t FLOW;                              /**< FLOW Register, offset: 0x8 */
X  volatile uint32_t FLOW;                               
N  __I  uint32_t BASE;                              /**< Indicates where the SRAM is located in the processor memory map. This register is provided to enable auto discovery of the MTB SRAM location, by a debug agent., offset: 0xC */
X  volatile const  uint32_t BASE;                               
N} MTB_Type;
N
N/* ----------------------------------------------------------------------------
N   -- MTB Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup MTB_Register_Masks MTB Register Masks
N * @{
N */
N
N/*! @name POSITION - POSITION Register */
N/*! @{ */
N#define MTB_POSITION_WRAP_MASK                   (0x4U)
N#define MTB_POSITION_WRAP_SHIFT                  (2U)
N#define MTB_POSITION_WRAP(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_POSITION_WRAP_SHIFT)) & MTB_POSITION_WRAP_MASK)
N#define MTB_POSITION_POINTER_MASK                (0xFFFFFFF8U)
N#define MTB_POSITION_POINTER_SHIFT               (3U)
N#define MTB_POSITION_POINTER(x)                  (((uint32_t)(((uint32_t)(x)) << MTB_POSITION_POINTER_SHIFT)) & MTB_POSITION_POINTER_MASK)
N/*! @} */
N
N/*! @name MASTER - MASTER Register */
N/*! @{ */
N#define MTB_MASTER_MASK_MASK                     (0x1FU)
N#define MTB_MASTER_MASK_SHIFT                    (0U)
N#define MTB_MASTER_MASK(x)                       (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_MASK_SHIFT)) & MTB_MASTER_MASK_MASK)
N#define MTB_MASTER_TSTARTEN_MASK                 (0x20U)
N#define MTB_MASTER_TSTARTEN_SHIFT                (5U)
N#define MTB_MASTER_TSTARTEN(x)                   (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_TSTARTEN_SHIFT)) & MTB_MASTER_TSTARTEN_MASK)
N#define MTB_MASTER_TSTOPEN_MASK                  (0x40U)
N#define MTB_MASTER_TSTOPEN_SHIFT                 (6U)
N#define MTB_MASTER_TSTOPEN(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_TSTOPEN_SHIFT)) & MTB_MASTER_TSTOPEN_MASK)
N#define MTB_MASTER_SFRWPRIV_MASK                 (0x80U)
N#define MTB_MASTER_SFRWPRIV_SHIFT                (7U)
N#define MTB_MASTER_SFRWPRIV(x)                   (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_SFRWPRIV_SHIFT)) & MTB_MASTER_SFRWPRIV_MASK)
N#define MTB_MASTER_RAMPRIV_MASK                  (0x100U)
N#define MTB_MASTER_RAMPRIV_SHIFT                 (8U)
N#define MTB_MASTER_RAMPRIV(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_RAMPRIV_SHIFT)) & MTB_MASTER_RAMPRIV_MASK)
N#define MTB_MASTER_HALTREQ_MASK                  (0x200U)
N#define MTB_MASTER_HALTREQ_SHIFT                 (9U)
N#define MTB_MASTER_HALTREQ(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_HALTREQ_SHIFT)) & MTB_MASTER_HALTREQ_MASK)
N#define MTB_MASTER_EN_MASK                       (0x80000000U)
N#define MTB_MASTER_EN_SHIFT                      (31U)
N#define MTB_MASTER_EN(x)                         (((uint32_t)(((uint32_t)(x)) << MTB_MASTER_EN_SHIFT)) & MTB_MASTER_EN_MASK)
N/*! @} */
N
N/*! @name FLOW - FLOW Register */
N/*! @{ */
N#define MTB_FLOW_AUTOSTOP_MASK                   (0x1U)
N#define MTB_FLOW_AUTOSTOP_SHIFT                  (0U)
N#define MTB_FLOW_AUTOSTOP(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_FLOW_AUTOSTOP_SHIFT)) & MTB_FLOW_AUTOSTOP_MASK)
N#define MTB_FLOW_AUTOHALT_MASK                   (0x2U)
N#define MTB_FLOW_AUTOHALT_SHIFT                  (1U)
N#define MTB_FLOW_AUTOHALT(x)                     (((uint32_t)(((uint32_t)(x)) << MTB_FLOW_AUTOHALT_SHIFT)) & MTB_FLOW_AUTOHALT_MASK)
N#define MTB_FLOW_WATERMARK_MASK                  (0xFFFFFFF8U)
N#define MTB_FLOW_WATERMARK_SHIFT                 (3U)
N#define MTB_FLOW_WATERMARK(x)                    (((uint32_t)(((uint32_t)(x)) << MTB_FLOW_WATERMARK_SHIFT)) & MTB_FLOW_WATERMARK_MASK)
N/*! @} */
N
N/*! @name BASE - Indicates where the SRAM is located in the processor memory map. This register is provided to enable auto discovery of the MTB SRAM location, by a debug agent. */
N/*! @{ */
N#define MTB_BASE_BASE_MASK                       (0xFFFFFFFFU)
N#define MTB_BASE_BASE_SHIFT                      (0U)
N#define MTB_BASE_BASE(x)                         (((uint32_t)(((uint32_t)(x)) << MTB_BASE_BASE_SHIFT)) & MTB_BASE_BASE_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group MTB_Register_Masks */
N
N
N/* MTB - Peripheral instance base addresses */
N/** Peripheral MTB_SFR base address */
N#define MTB_SFR_BASE                             (0x14000000u)
N/** Peripheral MTB_SFR base pointer */
N#define MTB_SFR                                  ((MTB_Type *)MTB_SFR_BASE)
N/** Array initializer of MTB peripheral base addresses */
N#define MTB_BASE_ADDRS                           { MTB_SFR_BASE }
N/** Array initializer of MTB peripheral base pointers */
N#define MTB_BASE_PTRS                            { MTB_SFR }
N
N/*!
N * @}
N */ /* end of group MTB_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- PINT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup PINT_Peripheral_Access_Layer PINT Peripheral Access Layer
N * @{
N */
N
N/** PINT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t ISEL;                              /**< Pin Interrupt Mode register, offset: 0x0 */
X  volatile uint32_t ISEL;                               
N  __IO uint32_t IENR;                              /**< Pin interrupt level or rising edge interrupt enable register, offset: 0x4 */
X  volatile uint32_t IENR;                               
N  __O  uint32_t SIENR;                             /**< Pin interrupt level or rising edge interrupt set register, offset: 0x8 */
X  volatile  uint32_t SIENR;                              
N  __O  uint32_t CIENR;                             /**< Pin interrupt level (rising edge interrupt) clear register, offset: 0xC */
X  volatile  uint32_t CIENR;                              
N  __IO uint32_t IENF;                              /**< Pin interrupt active level or falling edge interrupt enable register, offset: 0x10 */
X  volatile uint32_t IENF;                               
N  __O  uint32_t SIENF;                             /**< Pin interrupt active level or falling edge interrupt set register, offset: 0x14 */
X  volatile  uint32_t SIENF;                              
N  __O  uint32_t CIENF;                             /**< Pin interrupt active level or falling edge interrupt clear register, offset: 0x18 */
X  volatile  uint32_t CIENF;                              
N  __IO uint32_t RISE;                              /**< Pin interrupt rising edge register, offset: 0x1C */
X  volatile uint32_t RISE;                               
N  __IO uint32_t FALL;                              /**< Pin interrupt falling edge register, offset: 0x20 */
X  volatile uint32_t FALL;                               
N  __IO uint32_t IST;                               /**< Pin interrupt status register, offset: 0x24 */
X  volatile uint32_t IST;                                
N  __IO uint32_t PMCTRL;                            /**< Pattern match interrupt control register, offset: 0x28 */
X  volatile uint32_t PMCTRL;                             
N  __IO uint32_t PMSRC;                             /**< Pattern match interrupt bit-slice source register, offset: 0x2C */
X  volatile uint32_t PMSRC;                              
N  __IO uint32_t PMCFG;                             /**< Pattern match interrupt bit slice configuration register, offset: 0x30 */
X  volatile uint32_t PMCFG;                              
N} PINT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- PINT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup PINT_Register_Masks PINT Register Masks
N * @{
N */
N
N/*! @name ISEL - Pin Interrupt Mode register */
N/*! @{ */
N#define PINT_ISEL_PMODE_MASK                     (0xFFU)
N#define PINT_ISEL_PMODE_SHIFT                    (0U)
N#define PINT_ISEL_PMODE(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_ISEL_PMODE_SHIFT)) & PINT_ISEL_PMODE_MASK)
N/*! @} */
N
N/*! @name IENR - Pin interrupt level or rising edge interrupt enable register */
N/*! @{ */
N#define PINT_IENR_ENRL_MASK                      (0xFFU)
N#define PINT_IENR_ENRL_SHIFT                     (0U)
N#define PINT_IENR_ENRL(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_IENR_ENRL_SHIFT)) & PINT_IENR_ENRL_MASK)
N/*! @} */
N
N/*! @name SIENR - Pin interrupt level or rising edge interrupt set register */
N/*! @{ */
N#define PINT_SIENR_SETENRL_MASK                  (0xFFU)
N#define PINT_SIENR_SETENRL_SHIFT                 (0U)
N#define PINT_SIENR_SETENRL(x)                    (((uint32_t)(((uint32_t)(x)) << PINT_SIENR_SETENRL_SHIFT)) & PINT_SIENR_SETENRL_MASK)
N/*! @} */
N
N/*! @name CIENR - Pin interrupt level (rising edge interrupt) clear register */
N/*! @{ */
N#define PINT_CIENR_CENRL_MASK                    (0xFFU)
N#define PINT_CIENR_CENRL_SHIFT                   (0U)
N#define PINT_CIENR_CENRL(x)                      (((uint32_t)(((uint32_t)(x)) << PINT_CIENR_CENRL_SHIFT)) & PINT_CIENR_CENRL_MASK)
N/*! @} */
N
N/*! @name IENF - Pin interrupt active level or falling edge interrupt enable register */
N/*! @{ */
N#define PINT_IENF_ENAF_MASK                      (0xFFU)
N#define PINT_IENF_ENAF_SHIFT                     (0U)
N#define PINT_IENF_ENAF(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_IENF_ENAF_SHIFT)) & PINT_IENF_ENAF_MASK)
N/*! @} */
N
N/*! @name SIENF - Pin interrupt active level or falling edge interrupt set register */
N/*! @{ */
N#define PINT_SIENF_SETENAF_MASK                  (0xFFU)
N#define PINT_SIENF_SETENAF_SHIFT                 (0U)
N#define PINT_SIENF_SETENAF(x)                    (((uint32_t)(((uint32_t)(x)) << PINT_SIENF_SETENAF_SHIFT)) & PINT_SIENF_SETENAF_MASK)
N/*! @} */
N
N/*! @name CIENF - Pin interrupt active level or falling edge interrupt clear register */
N/*! @{ */
N#define PINT_CIENF_CENAF_MASK                    (0xFFU)
N#define PINT_CIENF_CENAF_SHIFT                   (0U)
N#define PINT_CIENF_CENAF(x)                      (((uint32_t)(((uint32_t)(x)) << PINT_CIENF_CENAF_SHIFT)) & PINT_CIENF_CENAF_MASK)
N/*! @} */
N
N/*! @name RISE - Pin interrupt rising edge register */
N/*! @{ */
N#define PINT_RISE_RDET_MASK                      (0xFFU)
N#define PINT_RISE_RDET_SHIFT                     (0U)
N#define PINT_RISE_RDET(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_RISE_RDET_SHIFT)) & PINT_RISE_RDET_MASK)
N/*! @} */
N
N/*! @name FALL - Pin interrupt falling edge register */
N/*! @{ */
N#define PINT_FALL_FDET_MASK                      (0xFFU)
N#define PINT_FALL_FDET_SHIFT                     (0U)
N#define PINT_FALL_FDET(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_FALL_FDET_SHIFT)) & PINT_FALL_FDET_MASK)
N/*! @} */
N
N/*! @name IST - Pin interrupt status register */
N/*! @{ */
N#define PINT_IST_PSTAT_MASK                      (0xFFU)
N#define PINT_IST_PSTAT_SHIFT                     (0U)
N#define PINT_IST_PSTAT(x)                        (((uint32_t)(((uint32_t)(x)) << PINT_IST_PSTAT_SHIFT)) & PINT_IST_PSTAT_MASK)
N/*! @} */
N
N/*! @name PMCTRL - Pattern match interrupt control register */
N/*! @{ */
N#define PINT_PMCTRL_SEL_PMATCH_MASK              (0x1U)
N#define PINT_PMCTRL_SEL_PMATCH_SHIFT             (0U)
N#define PINT_PMCTRL_SEL_PMATCH(x)                (((uint32_t)(((uint32_t)(x)) << PINT_PMCTRL_SEL_PMATCH_SHIFT)) & PINT_PMCTRL_SEL_PMATCH_MASK)
N#define PINT_PMCTRL_ENA_RXEV_MASK                (0x2U)
N#define PINT_PMCTRL_ENA_RXEV_SHIFT               (1U)
N#define PINT_PMCTRL_ENA_RXEV(x)                  (((uint32_t)(((uint32_t)(x)) << PINT_PMCTRL_ENA_RXEV_SHIFT)) & PINT_PMCTRL_ENA_RXEV_MASK)
N#define PINT_PMCTRL_PMAT_MASK                    (0xFF000000U)
N#define PINT_PMCTRL_PMAT_SHIFT                   (24U)
N#define PINT_PMCTRL_PMAT(x)                      (((uint32_t)(((uint32_t)(x)) << PINT_PMCTRL_PMAT_SHIFT)) & PINT_PMCTRL_PMAT_MASK)
N/*! @} */
N
N/*! @name PMSRC - Pattern match interrupt bit-slice source register */
N/*! @{ */
N#define PINT_PMSRC_SRC0_MASK                     (0x700U)
N#define PINT_PMSRC_SRC0_SHIFT                    (8U)
N#define PINT_PMSRC_SRC0(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC0_SHIFT)) & PINT_PMSRC_SRC0_MASK)
N#define PINT_PMSRC_SRC1_MASK                     (0x3800U)
N#define PINT_PMSRC_SRC1_SHIFT                    (11U)
N#define PINT_PMSRC_SRC1(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC1_SHIFT)) & PINT_PMSRC_SRC1_MASK)
N#define PINT_PMSRC_SRC2_MASK                     (0x1C000U)
N#define PINT_PMSRC_SRC2_SHIFT                    (14U)
N#define PINT_PMSRC_SRC2(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC2_SHIFT)) & PINT_PMSRC_SRC2_MASK)
N#define PINT_PMSRC_SRC3_MASK                     (0xE0000U)
N#define PINT_PMSRC_SRC3_SHIFT                    (17U)
N#define PINT_PMSRC_SRC3(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC3_SHIFT)) & PINT_PMSRC_SRC3_MASK)
N#define PINT_PMSRC_SRC4_MASK                     (0x700000U)
N#define PINT_PMSRC_SRC4_SHIFT                    (20U)
N#define PINT_PMSRC_SRC4(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC4_SHIFT)) & PINT_PMSRC_SRC4_MASK)
N#define PINT_PMSRC_SRC5_MASK                     (0x3800000U)
N#define PINT_PMSRC_SRC5_SHIFT                    (23U)
N#define PINT_PMSRC_SRC5(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC5_SHIFT)) & PINT_PMSRC_SRC5_MASK)
N#define PINT_PMSRC_SRC6_MASK                     (0x1C000000U)
N#define PINT_PMSRC_SRC6_SHIFT                    (26U)
N#define PINT_PMSRC_SRC6(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC6_SHIFT)) & PINT_PMSRC_SRC6_MASK)
N#define PINT_PMSRC_SRC7_MASK                     (0xE0000000U)
N#define PINT_PMSRC_SRC7_SHIFT                    (29U)
N#define PINT_PMSRC_SRC7(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMSRC_SRC7_SHIFT)) & PINT_PMSRC_SRC7_MASK)
N/*! @} */
N
N/*! @name PMCFG - Pattern match interrupt bit slice configuration register */
N/*! @{ */
N#define PINT_PMCFG_PROD_ENDPTS0_MASK             (0x1U)
N#define PINT_PMCFG_PROD_ENDPTS0_SHIFT            (0U)
N#define PINT_PMCFG_PROD_ENDPTS0(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS0_SHIFT)) & PINT_PMCFG_PROD_ENDPTS0_MASK)
N#define PINT_PMCFG_PROD_ENDPTS1_MASK             (0x2U)
N#define PINT_PMCFG_PROD_ENDPTS1_SHIFT            (1U)
N#define PINT_PMCFG_PROD_ENDPTS1(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS1_SHIFT)) & PINT_PMCFG_PROD_ENDPTS1_MASK)
N#define PINT_PMCFG_PROD_ENDPTS2_MASK             (0x4U)
N#define PINT_PMCFG_PROD_ENDPTS2_SHIFT            (2U)
N#define PINT_PMCFG_PROD_ENDPTS2(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS2_SHIFT)) & PINT_PMCFG_PROD_ENDPTS2_MASK)
N#define PINT_PMCFG_PROD_ENDPTS3_MASK             (0x8U)
N#define PINT_PMCFG_PROD_ENDPTS3_SHIFT            (3U)
N#define PINT_PMCFG_PROD_ENDPTS3(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS3_SHIFT)) & PINT_PMCFG_PROD_ENDPTS3_MASK)
N#define PINT_PMCFG_PROD_ENDPTS4_MASK             (0x10U)
N#define PINT_PMCFG_PROD_ENDPTS4_SHIFT            (4U)
N#define PINT_PMCFG_PROD_ENDPTS4(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS4_SHIFT)) & PINT_PMCFG_PROD_ENDPTS4_MASK)
N#define PINT_PMCFG_PROD_ENDPTS5_MASK             (0x20U)
N#define PINT_PMCFG_PROD_ENDPTS5_SHIFT            (5U)
N#define PINT_PMCFG_PROD_ENDPTS5(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS5_SHIFT)) & PINT_PMCFG_PROD_ENDPTS5_MASK)
N#define PINT_PMCFG_PROD_ENDPTS6_MASK             (0x40U)
N#define PINT_PMCFG_PROD_ENDPTS6_SHIFT            (6U)
N#define PINT_PMCFG_PROD_ENDPTS6(x)               (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_PROD_ENDPTS6_SHIFT)) & PINT_PMCFG_PROD_ENDPTS6_MASK)
N#define PINT_PMCFG_CFG0_MASK                     (0x700U)
N#define PINT_PMCFG_CFG0_SHIFT                    (8U)
N#define PINT_PMCFG_CFG0(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG0_SHIFT)) & PINT_PMCFG_CFG0_MASK)
N#define PINT_PMCFG_CFG1_MASK                     (0x3800U)
N#define PINT_PMCFG_CFG1_SHIFT                    (11U)
N#define PINT_PMCFG_CFG1(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG1_SHIFT)) & PINT_PMCFG_CFG1_MASK)
N#define PINT_PMCFG_CFG2_MASK                     (0x1C000U)
N#define PINT_PMCFG_CFG2_SHIFT                    (14U)
N#define PINT_PMCFG_CFG2(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG2_SHIFT)) & PINT_PMCFG_CFG2_MASK)
N#define PINT_PMCFG_CFG3_MASK                     (0xE0000U)
N#define PINT_PMCFG_CFG3_SHIFT                    (17U)
N#define PINT_PMCFG_CFG3(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG3_SHIFT)) & PINT_PMCFG_CFG3_MASK)
N#define PINT_PMCFG_CFG4_MASK                     (0x700000U)
N#define PINT_PMCFG_CFG4_SHIFT                    (20U)
N#define PINT_PMCFG_CFG4(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG4_SHIFT)) & PINT_PMCFG_CFG4_MASK)
N#define PINT_PMCFG_CFG5_MASK                     (0x3800000U)
N#define PINT_PMCFG_CFG5_SHIFT                    (23U)
N#define PINT_PMCFG_CFG5(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG5_SHIFT)) & PINT_PMCFG_CFG5_MASK)
N#define PINT_PMCFG_CFG6_MASK                     (0x1C000000U)
N#define PINT_PMCFG_CFG6_SHIFT                    (26U)
N#define PINT_PMCFG_CFG6(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG6_SHIFT)) & PINT_PMCFG_CFG6_MASK)
N#define PINT_PMCFG_CFG7_MASK                     (0xE0000000U)
N#define PINT_PMCFG_CFG7_SHIFT                    (29U)
N#define PINT_PMCFG_CFG7(x)                       (((uint32_t)(((uint32_t)(x)) << PINT_PMCFG_CFG7_SHIFT)) & PINT_PMCFG_CFG7_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group PINT_Register_Masks */
N
N
N/* PINT - Peripheral instance base addresses */
N/** Peripheral PINT base address */
N#define PINT_BASE                                (0xA0004000u)
N/** Peripheral PINT base pointer */
N#define PINT                                     ((PINT_Type *)PINT_BASE)
N/** Array initializer of PINT peripheral base addresses */
N#define PINT_BASE_ADDRS                          { PINT_BASE }
N/** Array initializer of PINT peripheral base pointers */
N#define PINT_BASE_PTRS                           { PINT }
N/** Interrupt vectors for the PINT peripheral type */
N#define PINT_IRQS                                { PIN_INT0_IRQn, PIN_INT1_IRQn, PIN_INT2_IRQn, PIN_INT3_IRQn, PIN_INT4_IRQn, PIN_INT5_IRQn, PIN_INT6_IRQn, PIN_INT7_IRQn }
N
N/*!
N * @}
N */ /* end of group PINT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- PMU Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup PMU_Peripheral_Access_Layer PMU Peripheral Access Layer
N * @{
N */
N
N/** PMU - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t PCON;                              /**< Power control register, offset: 0x0 */
X  volatile uint32_t PCON;                               
N  __IO uint32_t GPREG[4];                          /**< General purpose register N, array offset: 0x4, array step: 0x4 */
X  volatile uint32_t GPREG[4];                           
N  __IO uint32_t DPDCTRL;                           /**< Deep power-down control register. Also includes bits for general purpose storage., offset: 0x14 */
X  volatile uint32_t DPDCTRL;                            
N} PMU_Type;
N
N/* ----------------------------------------------------------------------------
N   -- PMU Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup PMU_Register_Masks PMU Register Masks
N * @{
N */
N
N/*! @name PCON - Power control register */
N/*! @{ */
N#define PMU_PCON_PM_MASK                         (0x7U)
N#define PMU_PCON_PM_SHIFT                        (0U)
N#define PMU_PCON_PM(x)                           (((uint32_t)(((uint32_t)(x)) << PMU_PCON_PM_SHIFT)) & PMU_PCON_PM_MASK)
N#define PMU_PCON_NODPD_MASK                      (0x8U)
N#define PMU_PCON_NODPD_SHIFT                     (3U)
N#define PMU_PCON_NODPD(x)                        (((uint32_t)(((uint32_t)(x)) << PMU_PCON_NODPD_SHIFT)) & PMU_PCON_NODPD_MASK)
N#define PMU_PCON_SLEEPFLAG_MASK                  (0x100U)
N#define PMU_PCON_SLEEPFLAG_SHIFT                 (8U)
N#define PMU_PCON_SLEEPFLAG(x)                    (((uint32_t)(((uint32_t)(x)) << PMU_PCON_SLEEPFLAG_SHIFT)) & PMU_PCON_SLEEPFLAG_MASK)
N#define PMU_PCON_DPDFLAG_MASK                    (0x800U)
N#define PMU_PCON_DPDFLAG_SHIFT                   (11U)
N#define PMU_PCON_DPDFLAG(x)                      (((uint32_t)(((uint32_t)(x)) << PMU_PCON_DPDFLAG_SHIFT)) & PMU_PCON_DPDFLAG_MASK)
N/*! @} */
N
N/*! @name GPREG - General purpose register N */
N/*! @{ */
N#define PMU_GPREG_GPDATA_MASK                    (0xFFFFFFFFU)
N#define PMU_GPREG_GPDATA_SHIFT                   (0U)
N#define PMU_GPREG_GPDATA(x)                      (((uint32_t)(((uint32_t)(x)) << PMU_GPREG_GPDATA_SHIFT)) & PMU_GPREG_GPDATA_MASK)
N/*! @} */
N
N/* The count of PMU_GPREG */
N#define PMU_GPREG_COUNT                          (4U)
N
N/*! @name DPDCTRL - Deep power-down control register. Also includes bits for general purpose storage. */
N/*! @{ */
N#define PMU_DPDCTRL_WAKEUPHYS_MASK               (0x1U)
N#define PMU_DPDCTRL_WAKEUPHYS_SHIFT              (0U)
N#define PMU_DPDCTRL_WAKEUPHYS(x)                 (((uint32_t)(((uint32_t)(x)) << PMU_DPDCTRL_WAKEUPHYS_SHIFT)) & PMU_DPDCTRL_WAKEUPHYS_MASK)
N#define PMU_DPDCTRL_WAKEPAD_DISABLE_MASK         (0x2U)
N#define PMU_DPDCTRL_WAKEPAD_DISABLE_SHIFT        (1U)
N#define PMU_DPDCTRL_WAKEPAD_DISABLE(x)           (((uint32_t)(((uint32_t)(x)) << PMU_DPDCTRL_WAKEPAD_DISABLE_SHIFT)) & PMU_DPDCTRL_WAKEPAD_DISABLE_MASK)
N#define PMU_DPDCTRL_LPOSCEN_MASK                 (0x4U)
N#define PMU_DPDCTRL_LPOSCEN_SHIFT                (2U)
N#define PMU_DPDCTRL_LPOSCEN(x)                   (((uint32_t)(((uint32_t)(x)) << PMU_DPDCTRL_LPOSCEN_SHIFT)) & PMU_DPDCTRL_LPOSCEN_MASK)
N#define PMU_DPDCTRL_LPOSCDPDEN_MASK              (0x8U)
N#define PMU_DPDCTRL_LPOSCDPDEN_SHIFT             (3U)
N#define PMU_DPDCTRL_LPOSCDPDEN(x)                (((uint32_t)(((uint32_t)(x)) << PMU_DPDCTRL_LPOSCDPDEN_SHIFT)) & PMU_DPDCTRL_LPOSCDPDEN_MASK)
N#define PMU_DPDCTRL_WAKEUPCLKHYS_MASK            (0x10U)
N#define PMU_DPDCTRL_WAKEUPCLKHYS_SHIFT           (4U)
N#define PMU_DPDCTRL_WAKEUPCLKHYS(x)              (((uint32_t)(((uint32_t)(x)) << PMU_DPDCTRL_WAKEUPCLKHYS_SHIFT)) & PMU_DPDCTRL_WAKEUPCLKHYS_MASK)
N#define PMU_DPDCTRL_WAKECLKPAD_DISABLE_MASK      (0x20U)
N#define PMU_DPDCTRL_WAKECLKPAD_DISABLE_SHIFT     (5U)
N#define PMU_DPDCTRL_WAKECLKPAD_DISABLE(x)        (((uint32_t)(((uint32_t)(x)) << PMU_DPDCTRL_WAKECLKPAD_DISABLE_SHIFT)) & PMU_DPDCTRL_WAKECLKPAD_DISABLE_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group PMU_Register_Masks */
N
N
N/* PMU - Peripheral instance base addresses */
N/** Peripheral PMU base address */
N#define PMU_BASE                                 (0x40020000u)
N/** Peripheral PMU base pointer */
N#define PMU                                      ((PMU_Type *)PMU_BASE)
N/** Array initializer of PMU peripheral base addresses */
N#define PMU_BASE_ADDRS                           { PMU_BASE }
N/** Array initializer of PMU peripheral base pointers */
N#define PMU_BASE_PTRS                            { PMU }
N
N/*!
N * @}
N */ /* end of group PMU_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SCT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SCT_Peripheral_Access_Layer SCT Peripheral Access Layer
N * @{
N */
N
N/** SCT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CONFIG;                            /**< SCT configuration register, offset: 0x0 */
X  volatile uint32_t CONFIG;                             
N  __IO uint32_t CTRL;                              /**< SCT control register, offset: 0x4 */
X  volatile uint32_t CTRL;                               
N  __IO uint32_t LIMIT;                             /**< SCT limit event select register, offset: 0x8 */
X  volatile uint32_t LIMIT;                              
N  __IO uint32_t HALT;                              /**< SCT halt event select register, offset: 0xC */
X  volatile uint32_t HALT;                               
N  __IO uint32_t STOP;                              /**< SCT stop event select register, offset: 0x10 */
X  volatile uint32_t STOP;                               
N  __IO uint32_t START;                             /**< SCT start event select register, offset: 0x14 */
X  volatile uint32_t START;                              
N       uint8_t RESERVED_0[40];
N  __IO uint32_t COUNT;                             /**< SCT counter register, offset: 0x40 */
X  volatile uint32_t COUNT;                              
N  __IO uint32_t STATE;                             /**< SCT state register, offset: 0x44 */
X  volatile uint32_t STATE;                              
N  __I  uint32_t INPUT;                             /**< SCT input register, offset: 0x48 */
X  volatile const  uint32_t INPUT;                              
N  __IO uint32_t REGMODE;                           /**< SCT match/capture mode register, offset: 0x4C */
X  volatile uint32_t REGMODE;                            
N  __IO uint32_t OUTPUT;                            /**< SCT output register, offset: 0x50 */
X  volatile uint32_t OUTPUT;                             
N  __IO uint32_t OUTPUTDIRCTRL;                     /**< SCT output counter direction control register, offset: 0x54 */
X  volatile uint32_t OUTPUTDIRCTRL;                      
N  __IO uint32_t RES;                               /**< SCT conflict resolution register, offset: 0x58 */
X  volatile uint32_t RES;                                
N  __IO uint32_t DMA0REQUEST;                       /**< SCT DMA request 0 register, offset: 0x5C */
X  volatile uint32_t DMA0REQUEST;                        
N  __IO uint32_t DMA1REQUEST;                       /**< SCT DMA request 1 register, offset: 0x60 */
X  volatile uint32_t DMA1REQUEST;                        
N       uint8_t RESERVED_1[140];
N  __IO uint32_t EVEN;                              /**< SCT event interrupt enable register, offset: 0xF0 */
X  volatile uint32_t EVEN;                               
N  __IO uint32_t EVFLAG;                            /**< SCT event flag register, offset: 0xF4 */
X  volatile uint32_t EVFLAG;                             
N  __IO uint32_t CONEN;                             /**< SCT conflict interrupt enable register, offset: 0xF8 */
X  volatile uint32_t CONEN;                              
N  __IO uint32_t CONFLAG;                           /**< SCT conflict flag register, offset: 0xFC */
X  volatile uint32_t CONFLAG;                            
N  union {                                          /* offset: 0x100 */
N    __IO uint32_t SCTCAP[8];                         /**< SCT capture register of capture channel, array offset: 0x100, array step: 0x4 */
X    volatile uint32_t SCTCAP[8];                          
N    __IO uint32_t SCTMATCH[8];                       /**< SCT match value register of match channels, array offset: 0x100, array step: 0x4 */
X    volatile uint32_t SCTMATCH[8];                        
N  };
N       uint8_t RESERVED_2[224];
N  union {                                          /* offset: 0x200 */
N    __IO uint32_t SCTCAPCTRL[8];                     /**< SCT capture control register, array offset: 0x200, array step: 0x4 */
X    volatile uint32_t SCTCAPCTRL[8];                      
N    __IO uint32_t SCTMATCHREL[8];                    /**< SCT match reload value register, array offset: 0x200, array step: 0x4 */
X    volatile uint32_t SCTMATCHREL[8];                     
N  };
N       uint8_t RESERVED_3[224];
N  struct {                                         /* offset: 0x300, array step: 0x8 */
N    __IO uint32_t STATE;                             /**< SCT event state register 0, array offset: 0x300, array step: 0x8 */
X    volatile uint32_t STATE;                              
N    __IO uint32_t CTRL;                              /**< SCT event control register 0, array offset: 0x304, array step: 0x8 */
X    volatile uint32_t CTRL;                               
N  } EVENT[8];
N       uint8_t RESERVED_4[448];
N  struct {                                         /* offset: 0x500, array step: 0x8 */
N    __IO uint32_t SET;                               /**< SCT output 0 set register, array offset: 0x500, array step: 0x8 */
X    volatile uint32_t SET;                                
N    __IO uint32_t CLR;                               /**< SCT output 0 clear register, array offset: 0x504, array step: 0x8 */
X    volatile uint32_t CLR;                                
N  } OUT[6];
N} SCT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SCT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SCT_Register_Masks SCT Register Masks
N * @{
N */
N
N/*! @name CONFIG - SCT configuration register */
N/*! @{ */
N#define SCT_CONFIG_UNIFY_MASK                    (0x1U)
N#define SCT_CONFIG_UNIFY_SHIFT                   (0U)
N#define SCT_CONFIG_UNIFY(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_UNIFY_SHIFT)) & SCT_CONFIG_UNIFY_MASK)
N#define SCT_CONFIG_CLKMODE_MASK                  (0x6U)
N#define SCT_CONFIG_CLKMODE_SHIFT                 (1U)
N#define SCT_CONFIG_CLKMODE(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_CLKMODE_SHIFT)) & SCT_CONFIG_CLKMODE_MASK)
N#define SCT_CONFIG_CKSEL_MASK                    (0x78U)
N#define SCT_CONFIG_CKSEL_SHIFT                   (3U)
N#define SCT_CONFIG_CKSEL(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_CKSEL_SHIFT)) & SCT_CONFIG_CKSEL_MASK)
N#define SCT_CONFIG_NORELAOD_L_MASK               (0x80U)
N#define SCT_CONFIG_NORELAOD_L_SHIFT              (7U)
N#define SCT_CONFIG_NORELAOD_L(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_NORELAOD_L_SHIFT)) & SCT_CONFIG_NORELAOD_L_MASK)
N#define SCT_CONFIG_NORELOAD_H_MASK               (0x100U)
N#define SCT_CONFIG_NORELOAD_H_SHIFT              (8U)
N#define SCT_CONFIG_NORELOAD_H(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_NORELOAD_H_SHIFT)) & SCT_CONFIG_NORELOAD_H_MASK)
N#define SCT_CONFIG_INSYNC_MASK                   (0x1E00U)
N#define SCT_CONFIG_INSYNC_SHIFT                  (9U)
N#define SCT_CONFIG_INSYNC(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_INSYNC_SHIFT)) & SCT_CONFIG_INSYNC_MASK)
N#define SCT_CONFIG_AUTOLIMIT_L_MASK              (0x20000U)
N#define SCT_CONFIG_AUTOLIMIT_L_SHIFT             (17U)
N#define SCT_CONFIG_AUTOLIMIT_L(x)                (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_AUTOLIMIT_L_SHIFT)) & SCT_CONFIG_AUTOLIMIT_L_MASK)
N#define SCT_CONFIG_AUTOLIMIT_H_MASK              (0x40000U)
N#define SCT_CONFIG_AUTOLIMIT_H_SHIFT             (18U)
N#define SCT_CONFIG_AUTOLIMIT_H(x)                (((uint32_t)(((uint32_t)(x)) << SCT_CONFIG_AUTOLIMIT_H_SHIFT)) & SCT_CONFIG_AUTOLIMIT_H_MASK)
N/*! @} */
N
N/*! @name CTRL - SCT control register */
N/*! @{ */
N#define SCT_CTRL_DOWN_L_MASK                     (0x1U)
N#define SCT_CTRL_DOWN_L_SHIFT                    (0U)
N#define SCT_CTRL_DOWN_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_DOWN_L_SHIFT)) & SCT_CTRL_DOWN_L_MASK)
N#define SCT_CTRL_STOP_L_MASK                     (0x2U)
N#define SCT_CTRL_STOP_L_SHIFT                    (1U)
N#define SCT_CTRL_STOP_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_STOP_L_SHIFT)) & SCT_CTRL_STOP_L_MASK)
N#define SCT_CTRL_HALT_L_MASK                     (0x4U)
N#define SCT_CTRL_HALT_L_SHIFT                    (2U)
N#define SCT_CTRL_HALT_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_HALT_L_SHIFT)) & SCT_CTRL_HALT_L_MASK)
N#define SCT_CTRL_CLRCTR_L_MASK                   (0x8U)
N#define SCT_CTRL_CLRCTR_L_SHIFT                  (3U)
N#define SCT_CTRL_CLRCTR_L(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_CLRCTR_L_SHIFT)) & SCT_CTRL_CLRCTR_L_MASK)
N#define SCT_CTRL_BIDIR_L_MASK                    (0x10U)
N#define SCT_CTRL_BIDIR_L_SHIFT                   (4U)
N#define SCT_CTRL_BIDIR_L(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_BIDIR_L_SHIFT)) & SCT_CTRL_BIDIR_L_MASK)
N#define SCT_CTRL_PRE_L_MASK                      (0x1FE0U)
N#define SCT_CTRL_PRE_L_SHIFT                     (5U)
N#define SCT_CTRL_PRE_L(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_PRE_L_SHIFT)) & SCT_CTRL_PRE_L_MASK)
N#define SCT_CTRL_DOWN_H_MASK                     (0x10000U)
N#define SCT_CTRL_DOWN_H_SHIFT                    (16U)
N#define SCT_CTRL_DOWN_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_DOWN_H_SHIFT)) & SCT_CTRL_DOWN_H_MASK)
N#define SCT_CTRL_STOP_H_MASK                     (0x20000U)
N#define SCT_CTRL_STOP_H_SHIFT                    (17U)
N#define SCT_CTRL_STOP_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_STOP_H_SHIFT)) & SCT_CTRL_STOP_H_MASK)
N#define SCT_CTRL_HALT_H_MASK                     (0x40000U)
N#define SCT_CTRL_HALT_H_SHIFT                    (18U)
N#define SCT_CTRL_HALT_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_HALT_H_SHIFT)) & SCT_CTRL_HALT_H_MASK)
N#define SCT_CTRL_CLRCTR_H_MASK                   (0x80000U)
N#define SCT_CTRL_CLRCTR_H_SHIFT                  (19U)
N#define SCT_CTRL_CLRCTR_H(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_CLRCTR_H_SHIFT)) & SCT_CTRL_CLRCTR_H_MASK)
N#define SCT_CTRL_BIDIR_H_MASK                    (0x100000U)
N#define SCT_CTRL_BIDIR_H_SHIFT                   (20U)
N#define SCT_CTRL_BIDIR_H(x)                      (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_BIDIR_H_SHIFT)) & SCT_CTRL_BIDIR_H_MASK)
N#define SCT_CTRL_PRE_H_MASK                      (0x1FE00000U)
N#define SCT_CTRL_PRE_H_SHIFT                     (21U)
N#define SCT_CTRL_PRE_H(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_CTRL_PRE_H_SHIFT)) & SCT_CTRL_PRE_H_MASK)
N/*! @} */
N
N/*! @name LIMIT - SCT limit event select register */
N/*! @{ */
N#define SCT_LIMIT_LIMMSK_L_MASK                  (0xFFU)
N#define SCT_LIMIT_LIMMSK_L_SHIFT                 (0U)
N#define SCT_LIMIT_LIMMSK_L(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_LIMIT_LIMMSK_L_SHIFT)) & SCT_LIMIT_LIMMSK_L_MASK)
N#define SCT_LIMIT_LIMMSK_H_MASK                  (0xFF0000U)
N#define SCT_LIMIT_LIMMSK_H_SHIFT                 (16U)
N#define SCT_LIMIT_LIMMSK_H(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_LIMIT_LIMMSK_H_SHIFT)) & SCT_LIMIT_LIMMSK_H_MASK)
N/*! @} */
N
N/*! @name HALT - SCT halt event select register */
N/*! @{ */
N#define SCT_HALT_HALTMSK_L_MASK                  (0xFFU)
N#define SCT_HALT_HALTMSK_L_SHIFT                 (0U)
N#define SCT_HALT_HALTMSK_L(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_HALT_HALTMSK_L_SHIFT)) & SCT_HALT_HALTMSK_L_MASK)
N#define SCT_HALT_HALTMSK_H_MASK                  (0xFF0000U)
N#define SCT_HALT_HALTMSK_H_SHIFT                 (16U)
N#define SCT_HALT_HALTMSK_H(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_HALT_HALTMSK_H_SHIFT)) & SCT_HALT_HALTMSK_H_MASK)
N/*! @} */
N
N/*! @name STOP - SCT stop event select register */
N/*! @{ */
N#define SCT_STOP_STOPMSK_L_MASK                  (0xFFU)
N#define SCT_STOP_STOPMSK_L_SHIFT                 (0U)
N#define SCT_STOP_STOPMSK_L(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_STOP_STOPMSK_L_SHIFT)) & SCT_STOP_STOPMSK_L_MASK)
N#define SCT_STOP_STOPMSK_H_MASK                  (0xFF0000U)
N#define SCT_STOP_STOPMSK_H_SHIFT                 (16U)
N#define SCT_STOP_STOPMSK_H(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_STOP_STOPMSK_H_SHIFT)) & SCT_STOP_STOPMSK_H_MASK)
N/*! @} */
N
N/*! @name START - SCT start event select register */
N/*! @{ */
N#define SCT_START_STARTMSK_L_MASK                (0xFFU)
N#define SCT_START_STARTMSK_L_SHIFT               (0U)
N#define SCT_START_STARTMSK_L(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_START_STARTMSK_L_SHIFT)) & SCT_START_STARTMSK_L_MASK)
N#define SCT_START_STARTMSK_H_MASK                (0xFF0000U)
N#define SCT_START_STARTMSK_H_SHIFT               (16U)
N#define SCT_START_STARTMSK_H(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_START_STARTMSK_H_SHIFT)) & SCT_START_STARTMSK_H_MASK)
N/*! @} */
N
N/*! @name COUNT - SCT counter register */
N/*! @{ */
N#define SCT_COUNT_CTR_L_MASK                     (0xFFFFU)
N#define SCT_COUNT_CTR_L_SHIFT                    (0U)
N#define SCT_COUNT_CTR_L(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_COUNT_CTR_L_SHIFT)) & SCT_COUNT_CTR_L_MASK)
N#define SCT_COUNT_CTR_H_MASK                     (0xFFFF0000U)
N#define SCT_COUNT_CTR_H_SHIFT                    (16U)
N#define SCT_COUNT_CTR_H(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_COUNT_CTR_H_SHIFT)) & SCT_COUNT_CTR_H_MASK)
N/*! @} */
N
N/*! @name STATE - SCT state register */
N/*! @{ */
N#define SCT_STATE_STATE_L_MASK                   (0x1FU)
N#define SCT_STATE_STATE_L_SHIFT                  (0U)
N#define SCT_STATE_STATE_L(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_STATE_STATE_L_SHIFT)) & SCT_STATE_STATE_L_MASK)
N#define SCT_STATE_STATE_H_MASK                   (0x1F0000U)
N#define SCT_STATE_STATE_H_SHIFT                  (16U)
N#define SCT_STATE_STATE_H(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_STATE_STATE_H_SHIFT)) & SCT_STATE_STATE_H_MASK)
N/*! @} */
N
N/*! @name INPUT - SCT input register */
N/*! @{ */
N#define SCT_INPUT_AIN0_MASK                      (0x1U)
N#define SCT_INPUT_AIN0_SHIFT                     (0U)
N#define SCT_INPUT_AIN0(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN0_SHIFT)) & SCT_INPUT_AIN0_MASK)
N#define SCT_INPUT_AIN1_MASK                      (0x2U)
N#define SCT_INPUT_AIN1_SHIFT                     (1U)
N#define SCT_INPUT_AIN1(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN1_SHIFT)) & SCT_INPUT_AIN1_MASK)
N#define SCT_INPUT_AIN2_MASK                      (0x4U)
N#define SCT_INPUT_AIN2_SHIFT                     (2U)
N#define SCT_INPUT_AIN2(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN2_SHIFT)) & SCT_INPUT_AIN2_MASK)
N#define SCT_INPUT_AIN3_MASK                      (0x8U)
N#define SCT_INPUT_AIN3_SHIFT                     (3U)
N#define SCT_INPUT_AIN3(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_AIN3_SHIFT)) & SCT_INPUT_AIN3_MASK)
N#define SCT_INPUT_SIN0_MASK                      (0x10000U)
N#define SCT_INPUT_SIN0_SHIFT                     (16U)
N#define SCT_INPUT_SIN0(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN0_SHIFT)) & SCT_INPUT_SIN0_MASK)
N#define SCT_INPUT_SIN1_MASK                      (0x20000U)
N#define SCT_INPUT_SIN1_SHIFT                     (17U)
N#define SCT_INPUT_SIN1(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN1_SHIFT)) & SCT_INPUT_SIN1_MASK)
N#define SCT_INPUT_SIN2_MASK                      (0x40000U)
N#define SCT_INPUT_SIN2_SHIFT                     (18U)
N#define SCT_INPUT_SIN2(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN2_SHIFT)) & SCT_INPUT_SIN2_MASK)
N#define SCT_INPUT_SIN3_MASK                      (0x80000U)
N#define SCT_INPUT_SIN3_SHIFT                     (19U)
N#define SCT_INPUT_SIN3(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_INPUT_SIN3_SHIFT)) & SCT_INPUT_SIN3_MASK)
N/*! @} */
N
N/*! @name REGMODE - SCT match/capture mode register */
N/*! @{ */
N#define SCT_REGMODE_REGMOD_L_MASK                (0xFFU)
N#define SCT_REGMODE_REGMOD_L_SHIFT               (0U)
N#define SCT_REGMODE_REGMOD_L(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_REGMODE_REGMOD_L_SHIFT)) & SCT_REGMODE_REGMOD_L_MASK)
N#define SCT_REGMODE_REGMOD_H_MASK                (0xFF0000U)
N#define SCT_REGMODE_REGMOD_H_SHIFT               (16U)
N#define SCT_REGMODE_REGMOD_H(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_REGMODE_REGMOD_H_SHIFT)) & SCT_REGMODE_REGMOD_H_MASK)
N/*! @} */
N
N/*! @name OUTPUT - SCT output register */
N/*! @{ */
N#define SCT_OUTPUT_OUT_MASK                      (0xFFU)
N#define SCT_OUTPUT_OUT_SHIFT                     (0U)
N#define SCT_OUTPUT_OUT(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUT_OUT_SHIFT)) & SCT_OUTPUT_OUT_MASK)
N/*! @} */
N
N/*! @name OUTPUTDIRCTRL - SCT output counter direction control register */
N/*! @{ */
N#define SCT_OUTPUTDIRCTRL_SETCLR0_MASK           (0x3U)
N#define SCT_OUTPUTDIRCTRL_SETCLR0_SHIFT          (0U)
N#define SCT_OUTPUTDIRCTRL_SETCLR0(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR0_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR0_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR1_MASK           (0xCU)
N#define SCT_OUTPUTDIRCTRL_SETCLR1_SHIFT          (2U)
N#define SCT_OUTPUTDIRCTRL_SETCLR1(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR1_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR1_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR2_MASK           (0x30U)
N#define SCT_OUTPUTDIRCTRL_SETCLR2_SHIFT          (4U)
N#define SCT_OUTPUTDIRCTRL_SETCLR2(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR2_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR2_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR3_MASK           (0xC0U)
N#define SCT_OUTPUTDIRCTRL_SETCLR3_SHIFT          (6U)
N#define SCT_OUTPUTDIRCTRL_SETCLR3(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR3_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR3_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR4_MASK           (0x300U)
N#define SCT_OUTPUTDIRCTRL_SETCLR4_SHIFT          (8U)
N#define SCT_OUTPUTDIRCTRL_SETCLR4(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR4_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR4_MASK)
N#define SCT_OUTPUTDIRCTRL_SETCLR5_MASK           (0xC00U)
N#define SCT_OUTPUTDIRCTRL_SETCLR5_SHIFT          (10U)
N#define SCT_OUTPUTDIRCTRL_SETCLR5(x)             (((uint32_t)(((uint32_t)(x)) << SCT_OUTPUTDIRCTRL_SETCLR5_SHIFT)) & SCT_OUTPUTDIRCTRL_SETCLR5_MASK)
N/*! @} */
N
N/*! @name RES - SCT conflict resolution register */
N/*! @{ */
N#define SCT_RES_O0RES_MASK                       (0x3U)
N#define SCT_RES_O0RES_SHIFT                      (0U)
N#define SCT_RES_O0RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O0RES_SHIFT)) & SCT_RES_O0RES_MASK)
N#define SCT_RES_O1RES_MASK                       (0xCU)
N#define SCT_RES_O1RES_SHIFT                      (2U)
N#define SCT_RES_O1RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O1RES_SHIFT)) & SCT_RES_O1RES_MASK)
N#define SCT_RES_O2RES_MASK                       (0x30U)
N#define SCT_RES_O2RES_SHIFT                      (4U)
N#define SCT_RES_O2RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O2RES_SHIFT)) & SCT_RES_O2RES_MASK)
N#define SCT_RES_O3RES_MASK                       (0xC0U)
N#define SCT_RES_O3RES_SHIFT                      (6U)
N#define SCT_RES_O3RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O3RES_SHIFT)) & SCT_RES_O3RES_MASK)
N#define SCT_RES_O4RES_MASK                       (0x300U)
N#define SCT_RES_O4RES_SHIFT                      (8U)
N#define SCT_RES_O4RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O4RES_SHIFT)) & SCT_RES_O4RES_MASK)
N#define SCT_RES_O5RES_MASK                       (0xC00U)
N#define SCT_RES_O5RES_SHIFT                      (10U)
N#define SCT_RES_O5RES(x)                         (((uint32_t)(((uint32_t)(x)) << SCT_RES_O5RES_SHIFT)) & SCT_RES_O5RES_MASK)
N/*! @} */
N
N/*! @name DMA0REQUEST - SCT DMA request 0 register */
N/*! @{ */
N#define SCT_DMA0REQUEST_DEV_0_MASK               (0x3FU)
N#define SCT_DMA0REQUEST_DEV_0_SHIFT              (0U)
N#define SCT_DMA0REQUEST_DEV_0(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_DMA0REQUEST_DEV_0_SHIFT)) & SCT_DMA0REQUEST_DEV_0_MASK)
N#define SCT_DMA0REQUEST_DRL0_MASK                (0x40000000U)
N#define SCT_DMA0REQUEST_DRL0_SHIFT               (30U)
N#define SCT_DMA0REQUEST_DRL0(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA0REQUEST_DRL0_SHIFT)) & SCT_DMA0REQUEST_DRL0_MASK)
N#define SCT_DMA0REQUEST_DRQ0_MASK                (0x80000000U)
N#define SCT_DMA0REQUEST_DRQ0_SHIFT               (31U)
N#define SCT_DMA0REQUEST_DRQ0(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA0REQUEST_DRQ0_SHIFT)) & SCT_DMA0REQUEST_DRQ0_MASK)
N/*! @} */
N
N/*! @name DMA1REQUEST - SCT DMA request 1 register */
N/*! @{ */
N#define SCT_DMA1REQUEST_DEV_1_MASK               (0x3FU)
N#define SCT_DMA1REQUEST_DEV_1_SHIFT              (0U)
N#define SCT_DMA1REQUEST_DEV_1(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_DMA1REQUEST_DEV_1_SHIFT)) & SCT_DMA1REQUEST_DEV_1_MASK)
N#define SCT_DMA1REQUEST_DRL1_MASK                (0x40000000U)
N#define SCT_DMA1REQUEST_DRL1_SHIFT               (30U)
N#define SCT_DMA1REQUEST_DRL1(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA1REQUEST_DRL1_SHIFT)) & SCT_DMA1REQUEST_DRL1_MASK)
N#define SCT_DMA1REQUEST_DRQ1_MASK                (0x80000000U)
N#define SCT_DMA1REQUEST_DRQ1_SHIFT               (31U)
N#define SCT_DMA1REQUEST_DRQ1(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_DMA1REQUEST_DRQ1_SHIFT)) & SCT_DMA1REQUEST_DRQ1_MASK)
N/*! @} */
N
N/*! @name EVEN - SCT event interrupt enable register */
N/*! @{ */
N#define SCT_EVEN_IEN_MASK                        (0xFFU)
N#define SCT_EVEN_IEN_SHIFT                       (0U)
N#define SCT_EVEN_IEN(x)                          (((uint32_t)(((uint32_t)(x)) << SCT_EVEN_IEN_SHIFT)) & SCT_EVEN_IEN_MASK)
N/*! @} */
N
N/*! @name EVFLAG - SCT event flag register */
N/*! @{ */
N#define SCT_EVFLAG_FLAG_MASK                     (0xFFU)
N#define SCT_EVFLAG_FLAG_SHIFT                    (0U)
N#define SCT_EVFLAG_FLAG(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_EVFLAG_FLAG_SHIFT)) & SCT_EVFLAG_FLAG_MASK)
N/*! @} */
N
N/*! @name CONEN - SCT conflict interrupt enable register */
N/*! @{ */
N#define SCT_CONEN_NCEN_MASK                      (0x3FU)
N#define SCT_CONEN_NCEN_SHIFT                     (0U)
N#define SCT_CONEN_NCEN(x)                        (((uint32_t)(((uint32_t)(x)) << SCT_CONEN_NCEN_SHIFT)) & SCT_CONEN_NCEN_MASK)
N/*! @} */
N
N/*! @name CONFLAG - SCT conflict flag register */
N/*! @{ */
N#define SCT_CONFLAG_NCFLAG_MASK                  (0x3FU)
N#define SCT_CONFLAG_NCFLAG_SHIFT                 (0U)
N#define SCT_CONFLAG_NCFLAG(x)                    (((uint32_t)(((uint32_t)(x)) << SCT_CONFLAG_NCFLAG_SHIFT)) & SCT_CONFLAG_NCFLAG_MASK)
N#define SCT_CONFLAG_BUSERRL_MASK                 (0x40000000U)
N#define SCT_CONFLAG_BUSERRL_SHIFT                (30U)
N#define SCT_CONFLAG_BUSERRL(x)                   (((uint32_t)(((uint32_t)(x)) << SCT_CONFLAG_BUSERRL_SHIFT)) & SCT_CONFLAG_BUSERRL_MASK)
N#define SCT_CONFLAG_BUSERRH_MASK                 (0x80000000U)
N#define SCT_CONFLAG_BUSERRH_SHIFT                (31U)
N#define SCT_CONFLAG_BUSERRH(x)                   (((uint32_t)(((uint32_t)(x)) << SCT_CONFLAG_BUSERRH_SHIFT)) & SCT_CONFLAG_BUSERRH_MASK)
N/*! @} */
N
N/*! @name SCTCAP - SCT capture register of capture channel */
N/*! @{ */
N#define SCT_SCTCAP_CAPn_L_MASK                   (0xFFFFU)
N#define SCT_SCTCAP_CAPn_L_SHIFT                  (0U)
N#define SCT_SCTCAP_CAPn_L(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAP_CAPn_L_SHIFT)) & SCT_SCTCAP_CAPn_L_MASK)
N#define SCT_SCTCAP_CAPn_H_MASK                   (0xFFFF0000U)
N#define SCT_SCTCAP_CAPn_H_SHIFT                  (16U)
N#define SCT_SCTCAP_CAPn_H(x)                     (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAP_CAPn_H_SHIFT)) & SCT_SCTCAP_CAPn_H_MASK)
N/*! @} */
N
N/* The count of SCT_SCTCAP */
N#define SCT_SCTCAP_COUNT                         (8U)
N
N/*! @name SCTMATCH - SCT match value register of match channels */
N/*! @{ */
N#define SCT_SCTMATCH_MATCHn_L_MASK               (0xFFFFU)
N#define SCT_SCTMATCH_MATCHn_L_SHIFT              (0U)
N#define SCT_SCTMATCH_MATCHn_L(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCH_MATCHn_L_SHIFT)) & SCT_SCTMATCH_MATCHn_L_MASK)
N#define SCT_SCTMATCH_MATCHn_H_MASK               (0xFFFF0000U)
N#define SCT_SCTMATCH_MATCHn_H_SHIFT              (16U)
N#define SCT_SCTMATCH_MATCHn_H(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCH_MATCHn_H_SHIFT)) & SCT_SCTMATCH_MATCHn_H_MASK)
N/*! @} */
N
N/* The count of SCT_SCTMATCH */
N#define SCT_SCTMATCH_COUNT                       (8U)
N
N/*! @name SCTCAPCTRL - SCT capture control register */
N/*! @{ */
N#define SCT_SCTCAPCTRL_CAPCONn_L_MASK            (0xFFU)
N#define SCT_SCTCAPCTRL_CAPCONn_L_SHIFT           (0U)
N#define SCT_SCTCAPCTRL_CAPCONn_L(x)              (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAPCTRL_CAPCONn_L_SHIFT)) & SCT_SCTCAPCTRL_CAPCONn_L_MASK)
N#define SCT_SCTCAPCTRL_CAPCONn_H_MASK            (0xFF0000U)
N#define SCT_SCTCAPCTRL_CAPCONn_H_SHIFT           (16U)
N#define SCT_SCTCAPCTRL_CAPCONn_H(x)              (((uint32_t)(((uint32_t)(x)) << SCT_SCTCAPCTRL_CAPCONn_H_SHIFT)) & SCT_SCTCAPCTRL_CAPCONn_H_MASK)
N/*! @} */
N
N/* The count of SCT_SCTCAPCTRL */
N#define SCT_SCTCAPCTRL_COUNT                     (8U)
N
N/*! @name SCTMATCHREL - SCT match reload value register */
N/*! @{ */
N#define SCT_SCTMATCHREL_RELOADn_L_MASK           (0xFFFFU)
N#define SCT_SCTMATCHREL_RELOADn_L_SHIFT          (0U)
N#define SCT_SCTMATCHREL_RELOADn_L(x)             (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCHREL_RELOADn_L_SHIFT)) & SCT_SCTMATCHREL_RELOADn_L_MASK)
N#define SCT_SCTMATCHREL_RELOADn_H_MASK           (0xFFFF0000U)
N#define SCT_SCTMATCHREL_RELOADn_H_SHIFT          (16U)
N#define SCT_SCTMATCHREL_RELOADn_H(x)             (((uint32_t)(((uint32_t)(x)) << SCT_SCTMATCHREL_RELOADn_H_SHIFT)) & SCT_SCTMATCHREL_RELOADn_H_MASK)
N/*! @} */
N
N/* The count of SCT_SCTMATCHREL */
N#define SCT_SCTMATCHREL_COUNT                    (8U)
N
N/*! @name EVENT_STATE - SCT event state register 0 */
N/*! @{ */
N#define SCT_EVENT_STATE_STATEMSKn_MASK           (0xFFU)
N#define SCT_EVENT_STATE_STATEMSKn_SHIFT          (0U)
N#define SCT_EVENT_STATE_STATEMSKn(x)             (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_STATE_STATEMSKn_SHIFT)) & SCT_EVENT_STATE_STATEMSKn_MASK)
N/*! @} */
N
N/* The count of SCT_EVENT_STATE */
N#define SCT_EVENT_STATE_COUNT                    (8U)
N
N/*! @name EVENT_CTRL - SCT event control register 0 */
N/*! @{ */
N#define SCT_EVENT_CTRL_MATCHSEL_MASK             (0xFU)
N#define SCT_EVENT_CTRL_MATCHSEL_SHIFT            (0U)
N#define SCT_EVENT_CTRL_MATCHSEL(x)               (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_MATCHSEL_SHIFT)) & SCT_EVENT_CTRL_MATCHSEL_MASK)
N#define SCT_EVENT_CTRL_HEVENT_MASK               (0x10U)
N#define SCT_EVENT_CTRL_HEVENT_SHIFT              (4U)
N#define SCT_EVENT_CTRL_HEVENT(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_HEVENT_SHIFT)) & SCT_EVENT_CTRL_HEVENT_MASK)
N#define SCT_EVENT_CTRL_OUTSEL_MASK               (0x20U)
N#define SCT_EVENT_CTRL_OUTSEL_SHIFT              (5U)
N#define SCT_EVENT_CTRL_OUTSEL(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_OUTSEL_SHIFT)) & SCT_EVENT_CTRL_OUTSEL_MASK)
N#define SCT_EVENT_CTRL_IOSEL_MASK                (0x3C0U)
N#define SCT_EVENT_CTRL_IOSEL_SHIFT               (6U)
N#define SCT_EVENT_CTRL_IOSEL(x)                  (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_IOSEL_SHIFT)) & SCT_EVENT_CTRL_IOSEL_MASK)
N#define SCT_EVENT_CTRL_IOCOND_MASK               (0xC00U)
N#define SCT_EVENT_CTRL_IOCOND_SHIFT              (10U)
N#define SCT_EVENT_CTRL_IOCOND(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_IOCOND_SHIFT)) & SCT_EVENT_CTRL_IOCOND_MASK)
N#define SCT_EVENT_CTRL_COMBMODE_MASK             (0x3000U)
N#define SCT_EVENT_CTRL_COMBMODE_SHIFT            (12U)
N#define SCT_EVENT_CTRL_COMBMODE(x)               (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_COMBMODE_SHIFT)) & SCT_EVENT_CTRL_COMBMODE_MASK)
N#define SCT_EVENT_CTRL_STATELD_MASK              (0x4000U)
N#define SCT_EVENT_CTRL_STATELD_SHIFT             (14U)
N#define SCT_EVENT_CTRL_STATELD(x)                (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_STATELD_SHIFT)) & SCT_EVENT_CTRL_STATELD_MASK)
N#define SCT_EVENT_CTRL_STATEV_MASK               (0xF8000U)
N#define SCT_EVENT_CTRL_STATEV_SHIFT              (15U)
N#define SCT_EVENT_CTRL_STATEV(x)                 (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_STATEV_SHIFT)) & SCT_EVENT_CTRL_STATEV_MASK)
N#define SCT_EVENT_CTRL_MATCHMEM_MASK             (0x100000U)
N#define SCT_EVENT_CTRL_MATCHMEM_SHIFT            (20U)
N#define SCT_EVENT_CTRL_MATCHMEM(x)               (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_MATCHMEM_SHIFT)) & SCT_EVENT_CTRL_MATCHMEM_MASK)
N#define SCT_EVENT_CTRL_DIRECTION_MASK            (0x600000U)
N#define SCT_EVENT_CTRL_DIRECTION_SHIFT           (21U)
N#define SCT_EVENT_CTRL_DIRECTION(x)              (((uint32_t)(((uint32_t)(x)) << SCT_EVENT_CTRL_DIRECTION_SHIFT)) & SCT_EVENT_CTRL_DIRECTION_MASK)
N/*! @} */
N
N/* The count of SCT_EVENT_CTRL */
N#define SCT_EVENT_CTRL_COUNT                     (8U)
N
N/*! @name OUT_SET - SCT output 0 set register */
N/*! @{ */
N#define SCT_OUT_SET_SET_MASK                     (0xFFU)
N#define SCT_OUT_SET_SET_SHIFT                    (0U)
N#define SCT_OUT_SET_SET(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_OUT_SET_SET_SHIFT)) & SCT_OUT_SET_SET_MASK)
N/*! @} */
N
N/* The count of SCT_OUT_SET */
N#define SCT_OUT_SET_COUNT                        (6U)
N
N/*! @name OUT_CLR - SCT output 0 clear register */
N/*! @{ */
N#define SCT_OUT_CLR_CLR_MASK                     (0xFFU)
N#define SCT_OUT_CLR_CLR_SHIFT                    (0U)
N#define SCT_OUT_CLR_CLR(x)                       (((uint32_t)(((uint32_t)(x)) << SCT_OUT_CLR_CLR_SHIFT)) & SCT_OUT_CLR_CLR_MASK)
N/*! @} */
N
N/* The count of SCT_OUT_CLR */
N#define SCT_OUT_CLR_COUNT                        (6U)
N
N
N/*!
N * @}
N */ /* end of group SCT_Register_Masks */
N
N
N/* SCT - Peripheral instance base addresses */
N/** Peripheral SCT0 base address */
N#define SCT0_BASE                                (0x50004000u)
N/** Peripheral SCT0 base pointer */
N#define SCT0                                     ((SCT_Type *)SCT0_BASE)
N/** Array initializer of SCT peripheral base addresses */
N#define SCT_BASE_ADDRS                           { SCT0_BASE }
N/** Array initializer of SCT peripheral base pointers */
N#define SCT_BASE_PTRS                            { SCT0 }
N/** Interrupt vectors for the SCT peripheral type */
N#define SCT_IRQS                                 { SCT0_IRQn }
N
N/*!
N * @}
N */ /* end of group SCT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SPI Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SPI_Peripheral_Access_Layer SPI Peripheral Access Layer
N * @{
N */
N
N/** SPI - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CFG;                               /**< SPI Configuration register, offset: 0x0 */
X  volatile uint32_t CFG;                                
N  __IO uint32_t DLY;                               /**< SPI Delay register, offset: 0x4 */
X  volatile uint32_t DLY;                                
N  __IO uint32_t STAT;                              /**< SPI Status. Some status flags can be cleared by writing a 1 to that bit position, offset: 0x8 */
X  volatile uint32_t STAT;                               
N  __IO uint32_t INTENSET;                          /**< SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set., offset: 0xC */
X  volatile uint32_t INTENSET;                           
N  __O  uint32_t INTENCLR;                          /**< SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared., offset: 0x10 */
X  volatile  uint32_t INTENCLR;                           
N  __I  uint32_t RXDAT;                             /**< SPI Receive Data, offset: 0x14 */
X  volatile const  uint32_t RXDAT;                              
N  __IO uint32_t TXDATCTL;                          /**< SPI Transmit Data with Control, offset: 0x18 */
X  volatile uint32_t TXDATCTL;                           
N  __IO uint32_t TXDAT;                             /**< SPI Transmit Data., offset: 0x1C */
X  volatile uint32_t TXDAT;                              
N  __IO uint32_t TXCTL;                             /**< SPI Transmit Control, offset: 0x20 */
X  volatile uint32_t TXCTL;                              
N  __IO uint32_t DIV;                               /**< SPI clock Divider, offset: 0x24 */
X  volatile uint32_t DIV;                                
N  __I  uint32_t INTSTAT;                           /**< SPI Interrupt Status, offset: 0x28 */
X  volatile const  uint32_t INTSTAT;                            
N} SPI_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SPI Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SPI_Register_Masks SPI Register Masks
N * @{
N */
N
N/*! @name CFG - SPI Configuration register */
N/*! @{ */
N#define SPI_CFG_ENABLE_MASK                      (0x1U)
N#define SPI_CFG_ENABLE_SHIFT                     (0U)
N#define SPI_CFG_ENABLE(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_CFG_ENABLE_SHIFT)) & SPI_CFG_ENABLE_MASK)
N#define SPI_CFG_MASTER_MASK                      (0x4U)
N#define SPI_CFG_MASTER_SHIFT                     (2U)
N#define SPI_CFG_MASTER(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_CFG_MASTER_SHIFT)) & SPI_CFG_MASTER_MASK)
N#define SPI_CFG_LSBF_MASK                        (0x8U)
N#define SPI_CFG_LSBF_SHIFT                       (3U)
N#define SPI_CFG_LSBF(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_LSBF_SHIFT)) & SPI_CFG_LSBF_MASK)
N#define SPI_CFG_CPHA_MASK                        (0x10U)
N#define SPI_CFG_CPHA_SHIFT                       (4U)
N#define SPI_CFG_CPHA(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_CPHA_SHIFT)) & SPI_CFG_CPHA_MASK)
N#define SPI_CFG_CPOL_MASK                        (0x20U)
N#define SPI_CFG_CPOL_SHIFT                       (5U)
N#define SPI_CFG_CPOL(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_CPOL_SHIFT)) & SPI_CFG_CPOL_MASK)
N#define SPI_CFG_LOOP_MASK                        (0x80U)
N#define SPI_CFG_LOOP_SHIFT                       (7U)
N#define SPI_CFG_LOOP(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_CFG_LOOP_SHIFT)) & SPI_CFG_LOOP_MASK)
N#define SPI_CFG_SPOL0_MASK                       (0x100U)
N#define SPI_CFG_SPOL0_SHIFT                      (8U)
N#define SPI_CFG_SPOL0(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL0_SHIFT)) & SPI_CFG_SPOL0_MASK)
N#define SPI_CFG_SPOL1_MASK                       (0x200U)
N#define SPI_CFG_SPOL1_SHIFT                      (9U)
N#define SPI_CFG_SPOL1(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL1_SHIFT)) & SPI_CFG_SPOL1_MASK)
N#define SPI_CFG_SPOL2_MASK                       (0x400U)
N#define SPI_CFG_SPOL2_SHIFT                      (10U)
N#define SPI_CFG_SPOL2(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL2_SHIFT)) & SPI_CFG_SPOL2_MASK)
N#define SPI_CFG_SPOL3_MASK                       (0x800U)
N#define SPI_CFG_SPOL3_SHIFT                      (11U)
N#define SPI_CFG_SPOL3(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_CFG_SPOL3_SHIFT)) & SPI_CFG_SPOL3_MASK)
N/*! @} */
N
N/*! @name DLY - SPI Delay register */
N/*! @{ */
N#define SPI_DLY_PRE_DELAY_MASK                   (0xFU)
N#define SPI_DLY_PRE_DELAY_SHIFT                  (0U)
N#define SPI_DLY_PRE_DELAY(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_DLY_PRE_DELAY_SHIFT)) & SPI_DLY_PRE_DELAY_MASK)
N#define SPI_DLY_POST_DELAY_MASK                  (0xF0U)
N#define SPI_DLY_POST_DELAY_SHIFT                 (4U)
N#define SPI_DLY_POST_DELAY(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_DLY_POST_DELAY_SHIFT)) & SPI_DLY_POST_DELAY_MASK)
N#define SPI_DLY_FRAME_DELAY_MASK                 (0xF00U)
N#define SPI_DLY_FRAME_DELAY_SHIFT                (8U)
N#define SPI_DLY_FRAME_DELAY(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_DLY_FRAME_DELAY_SHIFT)) & SPI_DLY_FRAME_DELAY_MASK)
N#define SPI_DLY_TRANSFER_DELAY_MASK              (0xF000U)
N#define SPI_DLY_TRANSFER_DELAY_SHIFT             (12U)
N#define SPI_DLY_TRANSFER_DELAY(x)                (((uint32_t)(((uint32_t)(x)) << SPI_DLY_TRANSFER_DELAY_SHIFT)) & SPI_DLY_TRANSFER_DELAY_MASK)
N/*! @} */
N
N/*! @name STAT - SPI Status. Some status flags can be cleared by writing a 1 to that bit position */
N/*! @{ */
N#define SPI_STAT_RXRDY_MASK                      (0x1U)
N#define SPI_STAT_RXRDY_SHIFT                     (0U)
N#define SPI_STAT_RXRDY(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_STAT_RXRDY_SHIFT)) & SPI_STAT_RXRDY_MASK)
N#define SPI_STAT_TXRDY_MASK                      (0x2U)
N#define SPI_STAT_TXRDY_SHIFT                     (1U)
N#define SPI_STAT_TXRDY(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_STAT_TXRDY_SHIFT)) & SPI_STAT_TXRDY_MASK)
N#define SPI_STAT_RXOV_MASK                       (0x4U)
N#define SPI_STAT_RXOV_SHIFT                      (2U)
N#define SPI_STAT_RXOV(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_STAT_RXOV_SHIFT)) & SPI_STAT_RXOV_MASK)
N#define SPI_STAT_TXUR_MASK                       (0x8U)
N#define SPI_STAT_TXUR_SHIFT                      (3U)
N#define SPI_STAT_TXUR(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_STAT_TXUR_SHIFT)) & SPI_STAT_TXUR_MASK)
N#define SPI_STAT_SSA_MASK                        (0x10U)
N#define SPI_STAT_SSA_SHIFT                       (4U)
N#define SPI_STAT_SSA(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_STAT_SSA_SHIFT)) & SPI_STAT_SSA_MASK)
N#define SPI_STAT_SSD_MASK                        (0x20U)
N#define SPI_STAT_SSD_SHIFT                       (5U)
N#define SPI_STAT_SSD(x)                          (((uint32_t)(((uint32_t)(x)) << SPI_STAT_SSD_SHIFT)) & SPI_STAT_SSD_MASK)
N#define SPI_STAT_STALLED_MASK                    (0x40U)
N#define SPI_STAT_STALLED_SHIFT                   (6U)
N#define SPI_STAT_STALLED(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_STAT_STALLED_SHIFT)) & SPI_STAT_STALLED_MASK)
N#define SPI_STAT_ENDTRANSFER_MASK                (0x80U)
N#define SPI_STAT_ENDTRANSFER_SHIFT               (7U)
N#define SPI_STAT_ENDTRANSFER(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_STAT_ENDTRANSFER_SHIFT)) & SPI_STAT_ENDTRANSFER_MASK)
N#define SPI_STAT_MSTIDLE_MASK                    (0x100U)
N#define SPI_STAT_MSTIDLE_SHIFT                   (8U)
N#define SPI_STAT_MSTIDLE(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_STAT_MSTIDLE_SHIFT)) & SPI_STAT_MSTIDLE_MASK)
N/*! @} */
N
N/*! @name INTENSET - SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set. */
N/*! @{ */
N#define SPI_INTENSET_RXRDYEN_MASK                (0x1U)
N#define SPI_INTENSET_RXRDYEN_SHIFT               (0U)
N#define SPI_INTENSET_RXRDYEN(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_RXRDYEN_SHIFT)) & SPI_INTENSET_RXRDYEN_MASK)
N#define SPI_INTENSET_TXRDYEN_MASK                (0x2U)
N#define SPI_INTENSET_TXRDYEN_SHIFT               (1U)
N#define SPI_INTENSET_TXRDYEN(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_TXRDYEN_SHIFT)) & SPI_INTENSET_TXRDYEN_MASK)
N#define SPI_INTENSET_RXOVEN_MASK                 (0x4U)
N#define SPI_INTENSET_RXOVEN_SHIFT                (2U)
N#define SPI_INTENSET_RXOVEN(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_RXOVEN_SHIFT)) & SPI_INTENSET_RXOVEN_MASK)
N#define SPI_INTENSET_TXUREN_MASK                 (0x8U)
N#define SPI_INTENSET_TXUREN_SHIFT                (3U)
N#define SPI_INTENSET_TXUREN(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_TXUREN_SHIFT)) & SPI_INTENSET_TXUREN_MASK)
N#define SPI_INTENSET_SSAEN_MASK                  (0x10U)
N#define SPI_INTENSET_SSAEN_SHIFT                 (4U)
N#define SPI_INTENSET_SSAEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_SSAEN_SHIFT)) & SPI_INTENSET_SSAEN_MASK)
N#define SPI_INTENSET_SSDEN_MASK                  (0x20U)
N#define SPI_INTENSET_SSDEN_SHIFT                 (5U)
N#define SPI_INTENSET_SSDEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_SSDEN_SHIFT)) & SPI_INTENSET_SSDEN_MASK)
N#define SPI_INTENSET_MSTIDLEEN_MASK              (0x100U)
N#define SPI_INTENSET_MSTIDLEEN_SHIFT             (8U)
N#define SPI_INTENSET_MSTIDLEEN(x)                (((uint32_t)(((uint32_t)(x)) << SPI_INTENSET_MSTIDLEEN_SHIFT)) & SPI_INTENSET_MSTIDLEEN_MASK)
N/*! @} */
N
N/*! @name INTENCLR - SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared. */
N/*! @{ */
N#define SPI_INTENCLR_RXRDYEN_MASK                (0x1U)
N#define SPI_INTENCLR_RXRDYEN_SHIFT               (0U)
N#define SPI_INTENCLR_RXRDYEN(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_RXRDYEN_SHIFT)) & SPI_INTENCLR_RXRDYEN_MASK)
N#define SPI_INTENCLR_TXRDYEN_MASK                (0x2U)
N#define SPI_INTENCLR_TXRDYEN_SHIFT               (1U)
N#define SPI_INTENCLR_TXRDYEN(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_TXRDYEN_SHIFT)) & SPI_INTENCLR_TXRDYEN_MASK)
N#define SPI_INTENCLR_RXOVEN_MASK                 (0x4U)
N#define SPI_INTENCLR_RXOVEN_SHIFT                (2U)
N#define SPI_INTENCLR_RXOVEN(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_RXOVEN_SHIFT)) & SPI_INTENCLR_RXOVEN_MASK)
N#define SPI_INTENCLR_TXUREN_MASK                 (0x8U)
N#define SPI_INTENCLR_TXUREN_SHIFT                (3U)
N#define SPI_INTENCLR_TXUREN(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_TXUREN_SHIFT)) & SPI_INTENCLR_TXUREN_MASK)
N#define SPI_INTENCLR_SSAEN_MASK                  (0x10U)
N#define SPI_INTENCLR_SSAEN_SHIFT                 (4U)
N#define SPI_INTENCLR_SSAEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_SSAEN_SHIFT)) & SPI_INTENCLR_SSAEN_MASK)
N#define SPI_INTENCLR_SSDEN_MASK                  (0x20U)
N#define SPI_INTENCLR_SSDEN_SHIFT                 (5U)
N#define SPI_INTENCLR_SSDEN(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_SSDEN_SHIFT)) & SPI_INTENCLR_SSDEN_MASK)
N#define SPI_INTENCLR_MSTIDLE_MASK                (0x100U)
N#define SPI_INTENCLR_MSTIDLE_SHIFT               (8U)
N#define SPI_INTENCLR_MSTIDLE(x)                  (((uint32_t)(((uint32_t)(x)) << SPI_INTENCLR_MSTIDLE_SHIFT)) & SPI_INTENCLR_MSTIDLE_MASK)
N/*! @} */
N
N/*! @name RXDAT - SPI Receive Data */
N/*! @{ */
N#define SPI_RXDAT_RXDAT_MASK                     (0xFFFFU)
N#define SPI_RXDAT_RXDAT_SHIFT                    (0U)
N#define SPI_RXDAT_RXDAT(x)                       (((uint32_t)(((uint32_t)(x)) << SPI_RXDAT_RXDAT_SHIFT)) & SPI_RXDAT_RXDAT_MASK)
N#define SPI_RXDAT_RXSSEL0_N_MASK                 (0x10000U)
N#define SPI_RXDAT_RXSSEL0_N_SHIFT                (16U)
N#define SPI_RXDAT_RXSSEL0_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_RXDAT_RXSSEL0_N_SHIFT)) & SPI_RXDAT_RXSSEL0_N_MASK)
N#define SPI_RXDAT_RXSSEL1_N_MASK                 (0x20000U)
N#define SPI_RXDAT_RXSSEL1_N_SHIFT                (17U)
N#define SPI_RXDAT_RXSSEL1_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_RXDAT_RXSSEL1_N_SHIFT)) & SPI_RXDAT_RXSSEL1_N_MASK)
N#define SPI_RXDAT_RXSSEL2_N_MASK                 (0x40000U)
N#define SPI_RXDAT_RXSSEL2_N_SHIFT                (18U)
N#define SPI_RXDAT_RXSSEL2_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_RXDAT_RXSSEL2_N_SHIFT)) & SPI_RXDAT_RXSSEL2_N_MASK)
N#define SPI_RXDAT_RXSSEL3_N_MASK                 (0x80000U)
N#define SPI_RXDAT_RXSSEL3_N_SHIFT                (19U)
N#define SPI_RXDAT_RXSSEL3_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_RXDAT_RXSSEL3_N_SHIFT)) & SPI_RXDAT_RXSSEL3_N_MASK)
N#define SPI_RXDAT_SOT_MASK                       (0x100000U)
N#define SPI_RXDAT_SOT_SHIFT                      (20U)
N#define SPI_RXDAT_SOT(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_RXDAT_SOT_SHIFT)) & SPI_RXDAT_SOT_MASK)
N/*! @} */
N
N/*! @name TXDATCTL - SPI Transmit Data with Control */
N/*! @{ */
N#define SPI_TXDATCTL_TXDAT_MASK                  (0xFFFFU)
N#define SPI_TXDATCTL_TXDAT_SHIFT                 (0U)
N#define SPI_TXDATCTL_TXDAT(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_TXDAT_SHIFT)) & SPI_TXDATCTL_TXDAT_MASK)
N#define SPI_TXDATCTL_TXSSEL0_N_MASK              (0x10000U)
N#define SPI_TXDATCTL_TXSSEL0_N_SHIFT             (16U)
N#define SPI_TXDATCTL_TXSSEL0_N(x)                (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_TXSSEL0_N_SHIFT)) & SPI_TXDATCTL_TXSSEL0_N_MASK)
N#define SPI_TXDATCTL_TXSSEL1_N_MASK              (0x20000U)
N#define SPI_TXDATCTL_TXSSEL1_N_SHIFT             (17U)
N#define SPI_TXDATCTL_TXSSEL1_N(x)                (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_TXSSEL1_N_SHIFT)) & SPI_TXDATCTL_TXSSEL1_N_MASK)
N#define SPI_TXDATCTL_TXSSEL2_N_MASK              (0x40000U)
N#define SPI_TXDATCTL_TXSSEL2_N_SHIFT             (18U)
N#define SPI_TXDATCTL_TXSSEL2_N(x)                (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_TXSSEL2_N_SHIFT)) & SPI_TXDATCTL_TXSSEL2_N_MASK)
N#define SPI_TXDATCTL_TXSSEL3_N_MASK              (0x80000U)
N#define SPI_TXDATCTL_TXSSEL3_N_SHIFT             (19U)
N#define SPI_TXDATCTL_TXSSEL3_N(x)                (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_TXSSEL3_N_SHIFT)) & SPI_TXDATCTL_TXSSEL3_N_MASK)
N#define SPI_TXDATCTL_EOT_MASK                    (0x100000U)
N#define SPI_TXDATCTL_EOT_SHIFT                   (20U)
N#define SPI_TXDATCTL_EOT(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_EOT_SHIFT)) & SPI_TXDATCTL_EOT_MASK)
N#define SPI_TXDATCTL_EOF_MASK                    (0x200000U)
N#define SPI_TXDATCTL_EOF_SHIFT                   (21U)
N#define SPI_TXDATCTL_EOF(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_EOF_SHIFT)) & SPI_TXDATCTL_EOF_MASK)
N#define SPI_TXDATCTL_RXIGNORE_MASK               (0x400000U)
N#define SPI_TXDATCTL_RXIGNORE_SHIFT              (22U)
N#define SPI_TXDATCTL_RXIGNORE(x)                 (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_RXIGNORE_SHIFT)) & SPI_TXDATCTL_RXIGNORE_MASK)
N#define SPI_TXDATCTL_LEN_MASK                    (0xF000000U)
N#define SPI_TXDATCTL_LEN_SHIFT                   (24U)
N#define SPI_TXDATCTL_LEN(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_TXDATCTL_LEN_SHIFT)) & SPI_TXDATCTL_LEN_MASK)
N/*! @} */
N
N/*! @name TXDAT - SPI Transmit Data. */
N/*! @{ */
N#define SPI_TXDAT_DATA_MASK                      (0xFFFFU)
N#define SPI_TXDAT_DATA_SHIFT                     (0U)
N#define SPI_TXDAT_DATA(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_TXDAT_DATA_SHIFT)) & SPI_TXDAT_DATA_MASK)
N/*! @} */
N
N/*! @name TXCTL - SPI Transmit Control */
N/*! @{ */
N#define SPI_TXCTL_TXSSEL0_N_MASK                 (0x10000U)
N#define SPI_TXCTL_TXSSEL0_N_SHIFT                (16U)
N#define SPI_TXCTL_TXSSEL0_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_TXSSEL0_N_SHIFT)) & SPI_TXCTL_TXSSEL0_N_MASK)
N#define SPI_TXCTL_TXSSEL1_N_MASK                 (0x20000U)
N#define SPI_TXCTL_TXSSEL1_N_SHIFT                (17U)
N#define SPI_TXCTL_TXSSEL1_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_TXSSEL1_N_SHIFT)) & SPI_TXCTL_TXSSEL1_N_MASK)
N#define SPI_TXCTL_TXSSEL2_N_MASK                 (0x40000U)
N#define SPI_TXCTL_TXSSEL2_N_SHIFT                (18U)
N#define SPI_TXCTL_TXSSEL2_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_TXSSEL2_N_SHIFT)) & SPI_TXCTL_TXSSEL2_N_MASK)
N#define SPI_TXCTL_TXSSEL3_N_MASK                 (0x80000U)
N#define SPI_TXCTL_TXSSEL3_N_SHIFT                (19U)
N#define SPI_TXCTL_TXSSEL3_N(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_TXSSEL3_N_SHIFT)) & SPI_TXCTL_TXSSEL3_N_MASK)
N#define SPI_TXCTL_EOT_MASK                       (0x100000U)
N#define SPI_TXCTL_EOT_SHIFT                      (20U)
N#define SPI_TXCTL_EOT(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_EOT_SHIFT)) & SPI_TXCTL_EOT_MASK)
N#define SPI_TXCTL_EOF_MASK                       (0x200000U)
N#define SPI_TXCTL_EOF_SHIFT                      (21U)
N#define SPI_TXCTL_EOF(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_EOF_SHIFT)) & SPI_TXCTL_EOF_MASK)
N#define SPI_TXCTL_RXIGNORE_MASK                  (0x400000U)
N#define SPI_TXCTL_RXIGNORE_SHIFT                 (22U)
N#define SPI_TXCTL_RXIGNORE(x)                    (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_RXIGNORE_SHIFT)) & SPI_TXCTL_RXIGNORE_MASK)
N#define SPI_TXCTL_LEN_MASK                       (0xF000000U)
N#define SPI_TXCTL_LEN_SHIFT                      (24U)
N#define SPI_TXCTL_LEN(x)                         (((uint32_t)(((uint32_t)(x)) << SPI_TXCTL_LEN_SHIFT)) & SPI_TXCTL_LEN_MASK)
N/*! @} */
N
N/*! @name DIV - SPI clock Divider */
N/*! @{ */
N#define SPI_DIV_DIVVAL_MASK                      (0xFFFFU)
N#define SPI_DIV_DIVVAL_SHIFT                     (0U)
N#define SPI_DIV_DIVVAL(x)                        (((uint32_t)(((uint32_t)(x)) << SPI_DIV_DIVVAL_SHIFT)) & SPI_DIV_DIVVAL_MASK)
N/*! @} */
N
N/*! @name INTSTAT - SPI Interrupt Status */
N/*! @{ */
N#define SPI_INTSTAT_RXRDY_MASK                   (0x1U)
N#define SPI_INTSTAT_RXRDY_SHIFT                  (0U)
N#define SPI_INTSTAT_RXRDY(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_RXRDY_SHIFT)) & SPI_INTSTAT_RXRDY_MASK)
N#define SPI_INTSTAT_TXRDY_MASK                   (0x2U)
N#define SPI_INTSTAT_TXRDY_SHIFT                  (1U)
N#define SPI_INTSTAT_TXRDY(x)                     (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_TXRDY_SHIFT)) & SPI_INTSTAT_TXRDY_MASK)
N#define SPI_INTSTAT_RXOV_MASK                    (0x4U)
N#define SPI_INTSTAT_RXOV_SHIFT                   (2U)
N#define SPI_INTSTAT_RXOV(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_RXOV_SHIFT)) & SPI_INTSTAT_RXOV_MASK)
N#define SPI_INTSTAT_TXUR_MASK                    (0x8U)
N#define SPI_INTSTAT_TXUR_SHIFT                   (3U)
N#define SPI_INTSTAT_TXUR(x)                      (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_TXUR_SHIFT)) & SPI_INTSTAT_TXUR_MASK)
N#define SPI_INTSTAT_SSA_MASK                     (0x10U)
N#define SPI_INTSTAT_SSA_SHIFT                    (4U)
N#define SPI_INTSTAT_SSA(x)                       (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_SSA_SHIFT)) & SPI_INTSTAT_SSA_MASK)
N#define SPI_INTSTAT_SSD_MASK                     (0x20U)
N#define SPI_INTSTAT_SSD_SHIFT                    (5U)
N#define SPI_INTSTAT_SSD(x)                       (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_SSD_SHIFT)) & SPI_INTSTAT_SSD_MASK)
N#define SPI_INTSTAT_MSTIDLE_MASK                 (0x100U)
N#define SPI_INTSTAT_MSTIDLE_SHIFT                (8U)
N#define SPI_INTSTAT_MSTIDLE(x)                   (((uint32_t)(((uint32_t)(x)) << SPI_INTSTAT_MSTIDLE_SHIFT)) & SPI_INTSTAT_MSTIDLE_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group SPI_Register_Masks */
N
N
N/* SPI - Peripheral instance base addresses */
N/** Peripheral SPI0 base address */
N#define SPI0_BASE                                (0x40058000u)
N/** Peripheral SPI0 base pointer */
N#define SPI0                                     ((SPI_Type *)SPI0_BASE)
N/** Peripheral SPI1 base address */
N#define SPI1_BASE                                (0x4005C000u)
N/** Peripheral SPI1 base pointer */
N#define SPI1                                     ((SPI_Type *)SPI1_BASE)
N/** Array initializer of SPI peripheral base addresses */
N#define SPI_BASE_ADDRS                           { SPI0_BASE, SPI1_BASE }
N/** Array initializer of SPI peripheral base pointers */
N#define SPI_BASE_PTRS                            { SPI0, SPI1 }
N/** Interrupt vectors for the SPI peripheral type */
N#define SPI_IRQS                                 { SPI0_IRQn, SPI1_IRQn }
N
N/*!
N * @}
N */ /* end of group SPI_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SWM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SWM_Peripheral_Access_Layer SWM Peripheral Access Layer
N * @{
N */
N
N/** SWM - Register Layout Typedef */
Ntypedef struct {
N  union {                                          /* offset: 0x0 */
N    struct {                                         /* offset: 0x0 */
N      __IO uint32_t PINASSIGN0;                        /**< Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS., offset: 0x0 */
X      volatile uint32_t PINASSIGN0;                         
N      __IO uint32_t PINASSIGN1;                        /**< Pin assign register 1. Assign movable functions U0_SCLK, U1_TXD, U1_RXD, U1_RTS., offset: 0x4 */
X      volatile uint32_t PINASSIGN1;                         
N      __IO uint32_t PINASSIGN2;                        /**< Pin assign register 2. Assign movable functions U1_CTS, U1_SCLK, U2_TXD, U2_RXD., offset: 0x8 */
X      volatile uint32_t PINASSIGN2;                         
N      __IO uint32_t PINASSIGN3;                        /**< Pin assign register 3. Assign movable function U2_RTS, U2_CTS, U2_SCLK, SPI0_SCK., offset: 0xC */
X      volatile uint32_t PINASSIGN3;                         
N      __IO uint32_t PINASSIGN4;                        /**< Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL0, SPI0_SSEL1., offset: 0x10 */
X      volatile uint32_t PINASSIGN4;                         
N      __IO uint32_t PINASSIGN5;                        /**< Pin assign register 5. Assign movable functions SPI0_SSEL2, SPI0_SSEL3, SPI1_SCK, SPI1_MOSI, offset: 0x14 */
X      volatile uint32_t PINASSIGN5;                         
N      __IO uint32_t PINASSIGN6;                        /**< Pin assign register 6. Assign movable functions SPI1_MISO, SPI1_SSEL0, SPI1_SSEL1, SCT0_IN0., offset: 0x18 */
X      volatile uint32_t PINASSIGN6;                         
N      __IO uint32_t PINASSIGN7;                        /**< Pin assign register 7. Assign movable functions SCT_IN1, SCT_IN2, SCT_IN3, SCT_OUT0., offset: 0x1C */
X      volatile uint32_t PINASSIGN7;                         
N      __IO uint32_t PINASSIGN8;                        /**< Pin assign register 8. Assign movable functions SCT_OUT1, SCT_OUT2, SCT_OUT3, SCT_OUT4., offset: 0x20 */
X      volatile uint32_t PINASSIGN8;                         
N      __IO uint32_t PINASSIGN9;                        /**< Pin assign register 9. Assign movable functions SCT_OUT5, I2C1_SDA, I2C1_SCL, I2C2_SDA., offset: 0x24 */
X      volatile uint32_t PINASSIGN9;                         
N      __IO uint32_t PINASSIGN10;                       /**< Pin assign register 10. Assign movable functions, I2C2_SCL, I2C3_SDA, I2C3_SCL, ADC_PINTRIG0., offset: 0x28 */
X      volatile uint32_t PINASSIGN10;                        
N      __IO uint32_t PINASSIGN11;                       /**< Pin assign register 11. Assign movable functions ADC_PINTRIG1, ACMP_O, CLKOUT, GPIO_INT_BMAT, offset: 0x2C */
X      volatile uint32_t PINASSIGN11;                        
N    } ;
N    __IO uint32_t PINASSIGN_DATA[12];                /**< Pin assign register, array offset: 0x0, array step: 0x4 */
X    volatile uint32_t PINASSIGN_DATA[12];                 
N  };
N       uint8_t RESERVED_0[400];
N  __IO uint32_t PINENABLE0;                        /**< Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP and so on., offset: 0x1C0 */
X  volatile uint32_t PINENABLE0;                         
N} SWM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SWM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SWM_Register_Masks SWM Register Masks
N * @{
N */
N
N/*! @name PINASSIGN0 - Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS. */
N/*! @{ */
N#define SWM_PINASSIGN0_U0_TXD_O_MASK             (0xFFU)
N#define SWM_PINASSIGN0_U0_TXD_O_SHIFT            (0U)
N#define SWM_PINASSIGN0_U0_TXD_O(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN0_U0_TXD_O_SHIFT)) & SWM_PINASSIGN0_U0_TXD_O_MASK)
N#define SWM_PINASSIGN0_U0_RXD_I_MASK             (0xFF00U)
N#define SWM_PINASSIGN0_U0_RXD_I_SHIFT            (8U)
N#define SWM_PINASSIGN0_U0_RXD_I(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN0_U0_RXD_I_SHIFT)) & SWM_PINASSIGN0_U0_RXD_I_MASK)
N#define SWM_PINASSIGN0_U0_RTS_O_MASK             (0xFF0000U)
N#define SWM_PINASSIGN0_U0_RTS_O_SHIFT            (16U)
N#define SWM_PINASSIGN0_U0_RTS_O(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN0_U0_RTS_O_SHIFT)) & SWM_PINASSIGN0_U0_RTS_O_MASK)
N#define SWM_PINASSIGN0_U0_CTS_I_MASK             (0xFF000000U)
N#define SWM_PINASSIGN0_U0_CTS_I_SHIFT            (24U)
N#define SWM_PINASSIGN0_U0_CTS_I(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN0_U0_CTS_I_SHIFT)) & SWM_PINASSIGN0_U0_CTS_I_MASK)
N/*! @} */
N
N/*! @name PINASSIGN1 - Pin assign register 1. Assign movable functions U0_SCLK, U1_TXD, U1_RXD, U1_RTS. */
N/*! @{ */
N#define SWM_PINASSIGN1_U0_SCLK_IO_MASK           (0xFFU)
N#define SWM_PINASSIGN1_U0_SCLK_IO_SHIFT          (0U)
N#define SWM_PINASSIGN1_U0_SCLK_IO(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN1_U0_SCLK_IO_SHIFT)) & SWM_PINASSIGN1_U0_SCLK_IO_MASK)
N#define SWM_PINASSIGN1_U1_TXD_O_MASK             (0xFF00U)
N#define SWM_PINASSIGN1_U1_TXD_O_SHIFT            (8U)
N#define SWM_PINASSIGN1_U1_TXD_O(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN1_U1_TXD_O_SHIFT)) & SWM_PINASSIGN1_U1_TXD_O_MASK)
N#define SWM_PINASSIGN1_U1_RXD_I_MASK             (0xFF0000U)
N#define SWM_PINASSIGN1_U1_RXD_I_SHIFT            (16U)
N#define SWM_PINASSIGN1_U1_RXD_I(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN1_U1_RXD_I_SHIFT)) & SWM_PINASSIGN1_U1_RXD_I_MASK)
N#define SWM_PINASSIGN1_U1_RTS_O_MASK             (0xFF000000U)
N#define SWM_PINASSIGN1_U1_RTS_O_SHIFT            (24U)
N#define SWM_PINASSIGN1_U1_RTS_O(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN1_U1_RTS_O_SHIFT)) & SWM_PINASSIGN1_U1_RTS_O_MASK)
N/*! @} */
N
N/*! @name PINASSIGN2 - Pin assign register 2. Assign movable functions U1_CTS, U1_SCLK, U2_TXD, U2_RXD. */
N/*! @{ */
N#define SWM_PINASSIGN2_U1_CTS_I_MASK             (0xFFU)
N#define SWM_PINASSIGN2_U1_CTS_I_SHIFT            (0U)
N#define SWM_PINASSIGN2_U1_CTS_I(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN2_U1_CTS_I_SHIFT)) & SWM_PINASSIGN2_U1_CTS_I_MASK)
N#define SWM_PINASSIGN2_U1_SCLK_IO_MASK           (0xFF00U)
N#define SWM_PINASSIGN2_U1_SCLK_IO_SHIFT          (8U)
N#define SWM_PINASSIGN2_U1_SCLK_IO(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN2_U1_SCLK_IO_SHIFT)) & SWM_PINASSIGN2_U1_SCLK_IO_MASK)
N#define SWM_PINASSIGN2_U2_TXD_O_MASK             (0xFF0000U)
N#define SWM_PINASSIGN2_U2_TXD_O_SHIFT            (16U)
N#define SWM_PINASSIGN2_U2_TXD_O(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN2_U2_TXD_O_SHIFT)) & SWM_PINASSIGN2_U2_TXD_O_MASK)
N#define SWM_PINASSIGN2_U2_RXD_I_MASK             (0xFF000000U)
N#define SWM_PINASSIGN2_U2_RXD_I_SHIFT            (24U)
N#define SWM_PINASSIGN2_U2_RXD_I(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN2_U2_RXD_I_SHIFT)) & SWM_PINASSIGN2_U2_RXD_I_MASK)
N/*! @} */
N
N/*! @name PINASSIGN3 - Pin assign register 3. Assign movable function U2_RTS, U2_CTS, U2_SCLK, SPI0_SCK. */
N/*! @{ */
N#define SWM_PINASSIGN3_U2_RTS_O_MASK             (0xFFU)
N#define SWM_PINASSIGN3_U2_RTS_O_SHIFT            (0U)
N#define SWM_PINASSIGN3_U2_RTS_O(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN3_U2_RTS_O_SHIFT)) & SWM_PINASSIGN3_U2_RTS_O_MASK)
N#define SWM_PINASSIGN3_U2_CTS_I_MASK             (0xFF00U)
N#define SWM_PINASSIGN3_U2_CTS_I_SHIFT            (8U)
N#define SWM_PINASSIGN3_U2_CTS_I(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN3_U2_CTS_I_SHIFT)) & SWM_PINASSIGN3_U2_CTS_I_MASK)
N#define SWM_PINASSIGN3_U2_SCLK_IO_MASK           (0xFF0000U)
N#define SWM_PINASSIGN3_U2_SCLK_IO_SHIFT          (16U)
N#define SWM_PINASSIGN3_U2_SCLK_IO(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN3_U2_SCLK_IO_SHIFT)) & SWM_PINASSIGN3_U2_SCLK_IO_MASK)
N#define SWM_PINASSIGN3_SPI0_SCK_IO_MASK          (0xFF000000U)
N#define SWM_PINASSIGN3_SPI0_SCK_IO_SHIFT         (24U)
N#define SWM_PINASSIGN3_SPI0_SCK_IO(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN3_SPI0_SCK_IO_SHIFT)) & SWM_PINASSIGN3_SPI0_SCK_IO_MASK)
N/*! @} */
N
N/*! @name PINASSIGN4 - Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL0, SPI0_SSEL1. */
N/*! @{ */
N#define SWM_PINASSIGN4_SPI0_MOSI_IO_MASK         (0xFFU)
N#define SWM_PINASSIGN4_SPI0_MOSI_IO_SHIFT        (0U)
N#define SWM_PINASSIGN4_SPI0_MOSI_IO(x)           (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN4_SPI0_MOSI_IO_SHIFT)) & SWM_PINASSIGN4_SPI0_MOSI_IO_MASK)
N#define SWM_PINASSIGN4_SPI0_MISO_IO_MASK         (0xFF00U)
N#define SWM_PINASSIGN4_SPI0_MISO_IO_SHIFT        (8U)
N#define SWM_PINASSIGN4_SPI0_MISO_IO(x)           (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN4_SPI0_MISO_IO_SHIFT)) & SWM_PINASSIGN4_SPI0_MISO_IO_MASK)
N#define SWM_PINASSIGN4_SPI0_SSEL0_IO_MASK        (0xFF0000U)
N#define SWM_PINASSIGN4_SPI0_SSEL0_IO_SHIFT       (16U)
N#define SWM_PINASSIGN4_SPI0_SSEL0_IO(x)          (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN4_SPI0_SSEL0_IO_SHIFT)) & SWM_PINASSIGN4_SPI0_SSEL0_IO_MASK)
N#define SWM_PINASSIGN4_SPI0_SSEL1_IO_MASK        (0xFF000000U)
N#define SWM_PINASSIGN4_SPI0_SSEL1_IO_SHIFT       (24U)
N#define SWM_PINASSIGN4_SPI0_SSEL1_IO(x)          (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN4_SPI0_SSEL1_IO_SHIFT)) & SWM_PINASSIGN4_SPI0_SSEL1_IO_MASK)
N/*! @} */
N
N/*! @name PINASSIGN5 - Pin assign register 5. Assign movable functions SPI0_SSEL2, SPI0_SSEL3, SPI1_SCK, SPI1_MOSI */
N/*! @{ */
N#define SWM_PINASSIGN5_SPI0_SSEL2_IO_MASK        (0xFFU)
N#define SWM_PINASSIGN5_SPI0_SSEL2_IO_SHIFT       (0U)
N#define SWM_PINASSIGN5_SPI0_SSEL2_IO(x)          (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN5_SPI0_SSEL2_IO_SHIFT)) & SWM_PINASSIGN5_SPI0_SSEL2_IO_MASK)
N#define SWM_PINASSIGN5_SPI0_SSEL3_IO_MASK        (0xFF00U)
N#define SWM_PINASSIGN5_SPI0_SSEL3_IO_SHIFT       (8U)
N#define SWM_PINASSIGN5_SPI0_SSEL3_IO(x)          (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN5_SPI0_SSEL3_IO_SHIFT)) & SWM_PINASSIGN5_SPI0_SSEL3_IO_MASK)
N#define SWM_PINASSIGN5_SPI1_SCK_IO_MASK          (0xFF0000U)
N#define SWM_PINASSIGN5_SPI1_SCK_IO_SHIFT         (16U)
N#define SWM_PINASSIGN5_SPI1_SCK_IO(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN5_SPI1_SCK_IO_SHIFT)) & SWM_PINASSIGN5_SPI1_SCK_IO_MASK)
N#define SWM_PINASSIGN5_SPI1_MOSI_IO_MASK         (0xFF000000U)
N#define SWM_PINASSIGN5_SPI1_MOSI_IO_SHIFT        (24U)
N#define SWM_PINASSIGN5_SPI1_MOSI_IO(x)           (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN5_SPI1_MOSI_IO_SHIFT)) & SWM_PINASSIGN5_SPI1_MOSI_IO_MASK)
N/*! @} */
N
N/*! @name PINASSIGN6 - Pin assign register 6. Assign movable functions SPI1_MISO, SPI1_SSEL0, SPI1_SSEL1, SCT0_IN0. */
N/*! @{ */
N#define SWM_PINASSIGN6_SPI1_MISO_IO_MASK         (0xFFU)
N#define SWM_PINASSIGN6_SPI1_MISO_IO_SHIFT        (0U)
N#define SWM_PINASSIGN6_SPI1_MISO_IO(x)           (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN6_SPI1_MISO_IO_SHIFT)) & SWM_PINASSIGN6_SPI1_MISO_IO_MASK)
N#define SWM_PINASSIGN6_SPI1_SSEL0_IO_MASK        (0xFF00U)
N#define SWM_PINASSIGN6_SPI1_SSEL0_IO_SHIFT       (8U)
N#define SWM_PINASSIGN6_SPI1_SSEL0_IO(x)          (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN6_SPI1_SSEL0_IO_SHIFT)) & SWM_PINASSIGN6_SPI1_SSEL0_IO_MASK)
N#define SWM_PINASSIGN6_SPI1_SSEL1_IO_MASK        (0xFF0000U)
N#define SWM_PINASSIGN6_SPI1_SSEL1_IO_SHIFT       (16U)
N#define SWM_PINASSIGN6_SPI1_SSEL1_IO(x)          (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN6_SPI1_SSEL1_IO_SHIFT)) & SWM_PINASSIGN6_SPI1_SSEL1_IO_MASK)
N#define SWM_PINASSIGN6_SCT_PIN0_I_MASK           (0xFF000000U)
N#define SWM_PINASSIGN6_SCT_PIN0_I_SHIFT          (24U)
N#define SWM_PINASSIGN6_SCT_PIN0_I(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN6_SCT_PIN0_I_SHIFT)) & SWM_PINASSIGN6_SCT_PIN0_I_MASK)
N/*! @} */
N
N/*! @name PINASSIGN7 - Pin assign register 7. Assign movable functions SCT_IN1, SCT_IN2, SCT_IN3, SCT_OUT0. */
N/*! @{ */
N#define SWM_PINASSIGN7_SCT_PIN1_I_MASK           (0xFFU)
N#define SWM_PINASSIGN7_SCT_PIN1_I_SHIFT          (0U)
N#define SWM_PINASSIGN7_SCT_PIN1_I(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN7_SCT_PIN1_I_SHIFT)) & SWM_PINASSIGN7_SCT_PIN1_I_MASK)
N#define SWM_PINASSIGN7_SCT_PIN2_I_MASK           (0xFF00U)
N#define SWM_PINASSIGN7_SCT_PIN2_I_SHIFT          (8U)
N#define SWM_PINASSIGN7_SCT_PIN2_I(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN7_SCT_PIN2_I_SHIFT)) & SWM_PINASSIGN7_SCT_PIN2_I_MASK)
N#define SWM_PINASSIGN7_SCT_PIN3_I_MASK           (0xFF0000U)
N#define SWM_PINASSIGN7_SCT_PIN3_I_SHIFT          (16U)
N#define SWM_PINASSIGN7_SCT_PIN3_I(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN7_SCT_PIN3_I_SHIFT)) & SWM_PINASSIGN7_SCT_PIN3_I_MASK)
N#define SWM_PINASSIGN7_SCT_OUT0_O_MASK           (0xFF000000U)
N#define SWM_PINASSIGN7_SCT_OUT0_O_SHIFT          (24U)
N#define SWM_PINASSIGN7_SCT_OUT0_O(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN7_SCT_OUT0_O_SHIFT)) & SWM_PINASSIGN7_SCT_OUT0_O_MASK)
N/*! @} */
N
N/*! @name PINASSIGN8 - Pin assign register 8. Assign movable functions SCT_OUT1, SCT_OUT2, SCT_OUT3, SCT_OUT4. */
N/*! @{ */
N#define SWM_PINASSIGN8_SCT_OUT1_O_MASK           (0xFFU)
N#define SWM_PINASSIGN8_SCT_OUT1_O_SHIFT          (0U)
N#define SWM_PINASSIGN8_SCT_OUT1_O(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN8_SCT_OUT1_O_SHIFT)) & SWM_PINASSIGN8_SCT_OUT1_O_MASK)
N#define SWM_PINASSIGN8_SCT_OUT2_O_MASK           (0xFF00U)
N#define SWM_PINASSIGN8_SCT_OUT2_O_SHIFT          (8U)
N#define SWM_PINASSIGN8_SCT_OUT2_O(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN8_SCT_OUT2_O_SHIFT)) & SWM_PINASSIGN8_SCT_OUT2_O_MASK)
N#define SWM_PINASSIGN8_SCT_OUT3_O_MASK           (0xFF0000U)
N#define SWM_PINASSIGN8_SCT_OUT3_O_SHIFT          (16U)
N#define SWM_PINASSIGN8_SCT_OUT3_O(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN8_SCT_OUT3_O_SHIFT)) & SWM_PINASSIGN8_SCT_OUT3_O_MASK)
N#define SWM_PINASSIGN8_SCT_OUT4_O_MASK           (0xFF000000U)
N#define SWM_PINASSIGN8_SCT_OUT4_O_SHIFT          (24U)
N#define SWM_PINASSIGN8_SCT_OUT4_O(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN8_SCT_OUT4_O_SHIFT)) & SWM_PINASSIGN8_SCT_OUT4_O_MASK)
N/*! @} */
N
N/*! @name PINASSIGN9 - Pin assign register 9. Assign movable functions SCT_OUT5, I2C1_SDA, I2C1_SCL, I2C2_SDA. */
N/*! @{ */
N#define SWM_PINASSIGN9_SCT_OUT5_O_MASK           (0xFFU)
N#define SWM_PINASSIGN9_SCT_OUT5_O_SHIFT          (0U)
N#define SWM_PINASSIGN9_SCT_OUT5_O(x)             (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN9_SCT_OUT5_O_SHIFT)) & SWM_PINASSIGN9_SCT_OUT5_O_MASK)
N#define SWM_PINASSIGN9_I2C1_SDA_IO_MASK          (0xFF00U)
N#define SWM_PINASSIGN9_I2C1_SDA_IO_SHIFT         (8U)
N#define SWM_PINASSIGN9_I2C1_SDA_IO(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN9_I2C1_SDA_IO_SHIFT)) & SWM_PINASSIGN9_I2C1_SDA_IO_MASK)
N#define SWM_PINASSIGN9_I2C1_SCL_IO_MASK          (0xFF0000U)
N#define SWM_PINASSIGN9_I2C1_SCL_IO_SHIFT         (16U)
N#define SWM_PINASSIGN9_I2C1_SCL_IO(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN9_I2C1_SCL_IO_SHIFT)) & SWM_PINASSIGN9_I2C1_SCL_IO_MASK)
N#define SWM_PINASSIGN9_I2C2_SDA_IO_MASK          (0xFF000000U)
N#define SWM_PINASSIGN9_I2C2_SDA_IO_SHIFT         (24U)
N#define SWM_PINASSIGN9_I2C2_SDA_IO(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN9_I2C2_SDA_IO_SHIFT)) & SWM_PINASSIGN9_I2C2_SDA_IO_MASK)
N/*! @} */
N
N/*! @name PINASSIGN10 - Pin assign register 10. Assign movable functions, I2C2_SCL, I2C3_SDA, I2C3_SCL, ADC_PINTRIG0. */
N/*! @{ */
N#define SWM_PINASSIGN10_I2C2_SCL_IO_MASK         (0xFFU)
N#define SWM_PINASSIGN10_I2C2_SCL_IO_SHIFT        (0U)
N#define SWM_PINASSIGN10_I2C2_SCL_IO(x)           (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN10_I2C2_SCL_IO_SHIFT)) & SWM_PINASSIGN10_I2C2_SCL_IO_MASK)
N#define SWM_PINASSIGN10_I2C3_SDA_IO_MASK         (0xFF00U)
N#define SWM_PINASSIGN10_I2C3_SDA_IO_SHIFT        (8U)
N#define SWM_PINASSIGN10_I2C3_SDA_IO(x)           (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN10_I2C3_SDA_IO_SHIFT)) & SWM_PINASSIGN10_I2C3_SDA_IO_MASK)
N#define SWM_PINASSIGN10_I2C3_SCL_IO_MASK         (0xFF0000U)
N#define SWM_PINASSIGN10_I2C3_SCL_IO_SHIFT        (16U)
N#define SWM_PINASSIGN10_I2C3_SCL_IO(x)           (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN10_I2C3_SCL_IO_SHIFT)) & SWM_PINASSIGN10_I2C3_SCL_IO_MASK)
N#define SWM_PINASSIGN10_ADC_PINTRIG0_I_MASK      (0xFF000000U)
N#define SWM_PINASSIGN10_ADC_PINTRIG0_I_SHIFT     (24U)
N#define SWM_PINASSIGN10_ADC_PINTRIG0_I(x)        (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN10_ADC_PINTRIG0_I_SHIFT)) & SWM_PINASSIGN10_ADC_PINTRIG0_I_MASK)
N/*! @} */
N
N/*! @name PINASSIGN11 - Pin assign register 11. Assign movable functions ADC_PINTRIG1, ACMP_O, CLKOUT, GPIO_INT_BMAT */
N/*! @{ */
N#define SWM_PINASSIGN11_ADC_PINTRIG1_I_MASK      (0xFFU)
N#define SWM_PINASSIGN11_ADC_PINTRIG1_I_SHIFT     (0U)
N#define SWM_PINASSIGN11_ADC_PINTRIG1_I(x)        (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN11_ADC_PINTRIG1_I_SHIFT)) & SWM_PINASSIGN11_ADC_PINTRIG1_I_MASK)
N#define SWM_PINASSIGN11_ACMP_O_O_MASK            (0xFF00U)
N#define SWM_PINASSIGN11_ACMP_O_O_SHIFT           (8U)
N#define SWM_PINASSIGN11_ACMP_O_O(x)              (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN11_ACMP_O_O_SHIFT)) & SWM_PINASSIGN11_ACMP_O_O_MASK)
N#define SWM_PINASSIGN11_CLKOUT_O_MASK            (0xFF0000U)
N#define SWM_PINASSIGN11_CLKOUT_O_SHIFT           (16U)
N#define SWM_PINASSIGN11_CLKOUT_O(x)              (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN11_CLKOUT_O_SHIFT)) & SWM_PINASSIGN11_CLKOUT_O_MASK)
N#define SWM_PINASSIGN11_GPIO_INT_BMAT_O_MASK     (0xFF000000U)
N#define SWM_PINASSIGN11_GPIO_INT_BMAT_O_SHIFT    (24U)
N#define SWM_PINASSIGN11_GPIO_INT_BMAT_O(x)       (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN11_GPIO_INT_BMAT_O_SHIFT)) & SWM_PINASSIGN11_GPIO_INT_BMAT_O_MASK)
N/*! @} */
N
N/*! @name PINASSIGN_DATA - Pin assign register */
N/*! @{ */
N#define SWM_PINASSIGN_DATA_T0_MAT3_MASK          (0xFFU)
N#define SWM_PINASSIGN_DATA_T0_MAT3_SHIFT         (0U)
N#define SWM_PINASSIGN_DATA_T0_MAT3(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN_DATA_T0_MAT3_SHIFT)) & SWM_PINASSIGN_DATA_T0_MAT3_MASK)
N#define SWM_PINASSIGN_DATA_T0_CAP0_MASK          (0xFF00U)
N#define SWM_PINASSIGN_DATA_T0_CAP0_SHIFT         (8U)
N#define SWM_PINASSIGN_DATA_T0_CAP0(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN_DATA_T0_CAP0_SHIFT)) & SWM_PINASSIGN_DATA_T0_CAP0_MASK)
N#define SWM_PINASSIGN_DATA_T0_CAP1_MASK          (0xFF0000U)
N#define SWM_PINASSIGN_DATA_T0_CAP1_SHIFT         (16U)
N#define SWM_PINASSIGN_DATA_T0_CAP1(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN_DATA_T0_CAP1_SHIFT)) & SWM_PINASSIGN_DATA_T0_CAP1_MASK)
N#define SWM_PINASSIGN_DATA_T0_CAP2_MASK          (0xFF000000U)
N#define SWM_PINASSIGN_DATA_T0_CAP2_SHIFT         (24U)
N#define SWM_PINASSIGN_DATA_T0_CAP2(x)            (((uint32_t)(((uint32_t)(x)) << SWM_PINASSIGN_DATA_T0_CAP2_SHIFT)) & SWM_PINASSIGN_DATA_T0_CAP2_MASK)
N/*! @} */
N
N/* The count of SWM_PINASSIGN_DATA */
N#define SWM_PINASSIGN_DATA_COUNT                 (12U)
N
N/*! @name PINENABLE0 - Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP and so on. */
N/*! @{ */
N#define SWM_PINENABLE0_ACMP_I1_MASK              (0x1U)
N#define SWM_PINENABLE0_ACMP_I1_SHIFT             (0U)
N#define SWM_PINENABLE0_ACMP_I1(x)                (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ACMP_I1_SHIFT)) & SWM_PINENABLE0_ACMP_I1_MASK)
N#define SWM_PINENABLE0_ACMP_I2_MASK              (0x2U)
N#define SWM_PINENABLE0_ACMP_I2_SHIFT             (1U)
N#define SWM_PINENABLE0_ACMP_I2(x)                (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ACMP_I2_SHIFT)) & SWM_PINENABLE0_ACMP_I2_MASK)
N#define SWM_PINENABLE0_ACMP_I3_MASK              (0x4U)
N#define SWM_PINENABLE0_ACMP_I3_SHIFT             (2U)
N#define SWM_PINENABLE0_ACMP_I3(x)                (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ACMP_I3_SHIFT)) & SWM_PINENABLE0_ACMP_I3_MASK)
N#define SWM_PINENABLE0_ACMP_I4_MASK              (0x8U)
N#define SWM_PINENABLE0_ACMP_I4_SHIFT             (3U)
N#define SWM_PINENABLE0_ACMP_I4(x)                (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ACMP_I4_SHIFT)) & SWM_PINENABLE0_ACMP_I4_MASK)
N#define SWM_PINENABLE0_SWCLK_MASK                (0x10U)
N#define SWM_PINENABLE0_SWCLK_SHIFT               (4U)
N#define SWM_PINENABLE0_SWCLK(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_SWCLK_SHIFT)) & SWM_PINENABLE0_SWCLK_MASK)
N#define SWM_PINENABLE0_SWDIO_MASK                (0x20U)
N#define SWM_PINENABLE0_SWDIO_SHIFT               (5U)
N#define SWM_PINENABLE0_SWDIO(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_SWDIO_SHIFT)) & SWM_PINENABLE0_SWDIO_MASK)
N#define SWM_PINENABLE0_XTALIN_MASK               (0x40U)
N#define SWM_PINENABLE0_XTALIN_SHIFT              (6U)
N#define SWM_PINENABLE0_XTALIN(x)                 (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_XTALIN_SHIFT)) & SWM_PINENABLE0_XTALIN_MASK)
N#define SWM_PINENABLE0_XTALOUT_MASK              (0x80U)
N#define SWM_PINENABLE0_XTALOUT_SHIFT             (7U)
N#define SWM_PINENABLE0_XTALOUT(x)                (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_XTALOUT_SHIFT)) & SWM_PINENABLE0_XTALOUT_MASK)
N#define SWM_PINENABLE0_RESETN_MASK               (0x100U)
N#define SWM_PINENABLE0_RESETN_SHIFT              (8U)
N#define SWM_PINENABLE0_RESETN(x)                 (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_RESETN_SHIFT)) & SWM_PINENABLE0_RESETN_MASK)
N#define SWM_PINENABLE0_CLKIN_MASK                (0x200U)
N#define SWM_PINENABLE0_CLKIN_SHIFT               (9U)
N#define SWM_PINENABLE0_CLKIN(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_CLKIN_SHIFT)) & SWM_PINENABLE0_CLKIN_MASK)
N#define SWM_PINENABLE0_VDDCMP_MASK               (0x400U)
N#define SWM_PINENABLE0_VDDCMP_SHIFT              (10U)
N#define SWM_PINENABLE0_VDDCMP(x)                 (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_VDDCMP_SHIFT)) & SWM_PINENABLE0_VDDCMP_MASK)
N#define SWM_PINENABLE0_I2C0_SDA_MASK             (0x800U)
N#define SWM_PINENABLE0_I2C0_SDA_SHIFT            (11U)
N#define SWM_PINENABLE0_I2C0_SDA(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_I2C0_SDA_SHIFT)) & SWM_PINENABLE0_I2C0_SDA_MASK)
N#define SWM_PINENABLE0_I2C0_SCL_MASK             (0x1000U)
N#define SWM_PINENABLE0_I2C0_SCL_SHIFT            (12U)
N#define SWM_PINENABLE0_I2C0_SCL(x)               (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_I2C0_SCL_SHIFT)) & SWM_PINENABLE0_I2C0_SCL_MASK)
N#define SWM_PINENABLE0_ADC_0_MASK                (0x2000U)
N#define SWM_PINENABLE0_ADC_0_SHIFT               (13U)
N#define SWM_PINENABLE0_ADC_0(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_0_SHIFT)) & SWM_PINENABLE0_ADC_0_MASK)
N#define SWM_PINENABLE0_ADC_1_MASK                (0x4000U)
N#define SWM_PINENABLE0_ADC_1_SHIFT               (14U)
N#define SWM_PINENABLE0_ADC_1(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_1_SHIFT)) & SWM_PINENABLE0_ADC_1_MASK)
N#define SWM_PINENABLE0_ADC_2_MASK                (0x8000U)
N#define SWM_PINENABLE0_ADC_2_SHIFT               (15U)
N#define SWM_PINENABLE0_ADC_2(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_2_SHIFT)) & SWM_PINENABLE0_ADC_2_MASK)
N#define SWM_PINENABLE0_ADC_3_MASK                (0x10000U)
N#define SWM_PINENABLE0_ADC_3_SHIFT               (16U)
N#define SWM_PINENABLE0_ADC_3(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_3_SHIFT)) & SWM_PINENABLE0_ADC_3_MASK)
N#define SWM_PINENABLE0_ADC_4_MASK                (0x20000U)
N#define SWM_PINENABLE0_ADC_4_SHIFT               (17U)
N#define SWM_PINENABLE0_ADC_4(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_4_SHIFT)) & SWM_PINENABLE0_ADC_4_MASK)
N#define SWM_PINENABLE0_ADC_5_MASK                (0x40000U)
N#define SWM_PINENABLE0_ADC_5_SHIFT               (18U)
N#define SWM_PINENABLE0_ADC_5(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_5_SHIFT)) & SWM_PINENABLE0_ADC_5_MASK)
N#define SWM_PINENABLE0_ADC_6_MASK                (0x80000U)
N#define SWM_PINENABLE0_ADC_6_SHIFT               (19U)
N#define SWM_PINENABLE0_ADC_6(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_6_SHIFT)) & SWM_PINENABLE0_ADC_6_MASK)
N#define SWM_PINENABLE0_ADC_7_MASK                (0x100000U)
N#define SWM_PINENABLE0_ADC_7_SHIFT               (20U)
N#define SWM_PINENABLE0_ADC_7(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_7_SHIFT)) & SWM_PINENABLE0_ADC_7_MASK)
N#define SWM_PINENABLE0_ADC_8_MASK                (0x200000U)
N#define SWM_PINENABLE0_ADC_8_SHIFT               (21U)
N#define SWM_PINENABLE0_ADC_8(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_8_SHIFT)) & SWM_PINENABLE0_ADC_8_MASK)
N#define SWM_PINENABLE0_ADC_9_MASK                (0x400000U)
N#define SWM_PINENABLE0_ADC_9_SHIFT               (22U)
N#define SWM_PINENABLE0_ADC_9(x)                  (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_9_SHIFT)) & SWM_PINENABLE0_ADC_9_MASK)
N#define SWM_PINENABLE0_ADC_10_MASK               (0x800000U)
N#define SWM_PINENABLE0_ADC_10_SHIFT              (23U)
N#define SWM_PINENABLE0_ADC_10(x)                 (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_10_SHIFT)) & SWM_PINENABLE0_ADC_10_MASK)
N#define SWM_PINENABLE0_ADC_11_MASK               (0x1000000U)
N#define SWM_PINENABLE0_ADC_11_SHIFT              (24U)
N#define SWM_PINENABLE0_ADC_11(x)                 (((uint32_t)(((uint32_t)(x)) << SWM_PINENABLE0_ADC_11_SHIFT)) & SWM_PINENABLE0_ADC_11_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group SWM_Register_Masks */
N
N
N/* SWM - Peripheral instance base addresses */
N/** Peripheral SWM0 base address */
N#define SWM0_BASE                                (0x4000C000u)
N/** Peripheral SWM0 base pointer */
N#define SWM0                                     ((SWM_Type *)SWM0_BASE)
N/** Array initializer of SWM peripheral base addresses */
N#define SWM_BASE_ADDRS                           { SWM0_BASE }
N/** Array initializer of SWM peripheral base pointers */
N#define SWM_BASE_PTRS                            { SWM0 }
N
N/*!
N * @}
N */ /* end of group SWM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SYSCON Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SYSCON_Peripheral_Access_Layer SYSCON Peripheral Access Layer
N * @{
N */
N
N/** SYSCON - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t SYSMEMREMAP;                       /**< System Remap register, offset: 0x0 */
X  volatile uint32_t SYSMEMREMAP;                        
N  __IO uint32_t PRESETCTRL;                        /**< Peripheral reset control register, offset: 0x4 */
X  volatile uint32_t PRESETCTRL;                         
N  __IO uint32_t SYSPLLCTRL;                        /**< PLL control, offset: 0x8 */
X  volatile uint32_t SYSPLLCTRL;                         
N  __I  uint32_t SYSPLLSTAT;                        /**< PLL status, offset: 0xC */
X  volatile const  uint32_t SYSPLLSTAT;                         
N       uint8_t RESERVED_0[16];
N  __IO uint32_t SYSOSCCTRL;                        /**< system oscillator control, offset: 0x20 */
X  volatile uint32_t SYSOSCCTRL;                         
N  __IO uint32_t WDTOSCCTRL;                        /**< Watchdog oscillator control, offset: 0x24 */
X  volatile uint32_t WDTOSCCTRL;                         
N  __IO uint32_t IRCCTRL;                           /**< IRC control, offset: 0x28 */
X  volatile uint32_t IRCCTRL;                            
N       uint8_t RESERVED_1[4];
N  __IO uint32_t SYSRSTSTAT;                        /**< System reset status register, offset: 0x30 */
X  volatile uint32_t SYSRSTSTAT;                         
N       uint8_t RESERVED_2[12];
N  __IO uint32_t SYSPLLCLKSEL;                      /**< System PLL clock source select register, offset: 0x40 */
X  volatile uint32_t SYSPLLCLKSEL;                       
N  __IO uint32_t SYSPLLCLKUEN;                      /**< System PLL clock source update enable register, offset: 0x44 */
X  volatile uint32_t SYSPLLCLKUEN;                       
N       uint8_t RESERVED_3[40];
N  __IO uint32_t MAINCLKSEL;                        /**< Main clock source select, offset: 0x70 */
X  volatile uint32_t MAINCLKSEL;                         
N  __IO uint32_t MAINCLKUEN;                        /**< Main clock source update enable, offset: 0x74 */
X  volatile uint32_t MAINCLKUEN;                         
N  __IO uint32_t SYSAHBCLKDIV;                      /**< System clock divider, offset: 0x78 */
X  volatile uint32_t SYSAHBCLKDIV;                       
N       uint8_t RESERVED_4[4];
N  __IO uint32_t SYSAHBCLKCTRL;                     /**< System clock control, offset: 0x80 */
X  volatile uint32_t SYSAHBCLKCTRL;                      
N       uint8_t RESERVED_5[16];
N  __IO uint32_t UARTCLKDIV;                        /**< USART clock divider, offset: 0x94 */
X  volatile uint32_t UARTCLKDIV;                         
N       uint8_t RESERVED_6[72];
N  __IO uint32_t CLKOUTSEL;                         /**< CLKOUT clock source select, offset: 0xE0 */
X  volatile uint32_t CLKOUTSEL;                          
N  __IO uint32_t CLKOUTUEN;                         /**< CLKOUT clock source update enable, offset: 0xE4 */
X  volatile uint32_t CLKOUTUEN;                          
N  __IO uint32_t CLKOUTDIV;                         /**< PLL control, offset: 0xE8 */
X  volatile uint32_t CLKOUTDIV;                          
N       uint8_t RESERVED_7[4];
N  __IO uint32_t UARTFRGDIV;                        /**< USART1 to USART4 common fractional generator divider value, offset: 0xF0 */
X  volatile uint32_t UARTFRGDIV;                         
N  __IO uint32_t UARTFRGMULT;                       /**< USART1 to USART4 common fractional generator divider value, offset: 0xF4 */
X  volatile uint32_t UARTFRGMULT;                        
N       uint8_t RESERVED_8[4];
N  __IO uint32_t EXTTRACECMD;                       /**< External trace buffer command register, offset: 0xFC */
X  volatile uint32_t EXTTRACECMD;                        
N  __I  uint32_t PIOPORCAP0;                        /**< POR captured PIO status 0, offset: 0x100 */
X  volatile const  uint32_t PIOPORCAP0;                         
N       uint8_t RESERVED_9[48];
N  __IO uint32_t IOCONCLKDIV6;                      /**< Peripheral clock 6 to the IOCON block for programmable glitch filter, offset: 0x134 */
X  volatile uint32_t IOCONCLKDIV6;                       
N  __IO uint32_t IOCONCLKDIV5;                      /**< Peripheral clock 6 to the IOCON block for programmable glitch filter, offset: 0x138 */
X  volatile uint32_t IOCONCLKDIV5;                       
N  __IO uint32_t IOCONCLKDIV4;                      /**< Peripheral clock 4 to the IOCON block for programmable glitch filter, offset: 0x13C */
X  volatile uint32_t IOCONCLKDIV4;                       
N  __IO uint32_t IOCONCLKDIV3;                      /**< Peripheral clock 3 to the IOCON block for programmable glitch filter, offset: 0x140 */
X  volatile uint32_t IOCONCLKDIV3;                       
N  __IO uint32_t IOCONCLKDIV2;                      /**< Peripheral clock 2 to the IOCON block for programmable glitch filter, offset: 0x144 */
X  volatile uint32_t IOCONCLKDIV2;                       
N  __IO uint32_t IOCONCLKDIV1;                      /**< Peripheral clock 1 to the IOCON block for programmable glitch filter, offset: 0x148 */
X  volatile uint32_t IOCONCLKDIV1;                       
N  __IO uint32_t IOCONCLKDIV0;                      /**< Peripheral clock 0 to the IOCON block for programmable glitch filter, offset: 0x14C */
X  volatile uint32_t IOCONCLKDIV0;                       
N  __IO uint32_t BODCTRL;                           /**< BOD control register, offset: 0x150 */
X  volatile uint32_t BODCTRL;                            
N  __IO uint32_t SYSTCKCAL;                         /**< System tick timer calibration register, offset: 0x154 */
X  volatile uint32_t SYSTCKCAL;                          
N       uint8_t RESERVED_10[24];
N  __IO uint32_t IRQLATENCY;                        /**< IRQ latency register, offset: 0x170 */
X  volatile uint32_t IRQLATENCY;                         
N  __IO uint32_t NMISRC;                            /**< NMI source selection register, offset: 0x174 */
X  volatile uint32_t NMISRC;                             
N  __IO uint32_t PINTSEL[8];                        /**< Pin interrupt select registers N, array offset: 0x178, array step: 0x4 */
X  volatile uint32_t PINTSEL[8];                         
N       uint8_t RESERVED_11[108];
N  __IO uint32_t STARTERP0;                         /**< Start logic 0 pin wake-up enable register 0, offset: 0x204 */
X  volatile uint32_t STARTERP0;                          
N       uint8_t RESERVED_12[12];
N  __IO uint32_t STARTERP1;                         /**< Start logic 0 pin wake-up enable register 1, offset: 0x214 */
X  volatile uint32_t STARTERP1;                          
N       uint8_t RESERVED_13[24];
N  __IO uint32_t PDSLEEPCFG;                        /**< Deep-sleep configuration register, offset: 0x230 */
X  volatile uint32_t PDSLEEPCFG;                         
N  __IO uint32_t PDAWAKECFG;                        /**< Wake-up configuration register, offset: 0x234 */
X  volatile uint32_t PDAWAKECFG;                         
N  __IO uint32_t PDRUNCFG;                          /**< Power configuration register, offset: 0x238 */
X  volatile uint32_t PDRUNCFG;                           
N       uint8_t RESERVED_14[444];
N  __I  uint32_t DEVICE_ID;                         /**< Part ID register, offset: 0x3F8 */
X  volatile const  uint32_t DEVICE_ID;                          
N} SYSCON_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SYSCON Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SYSCON_Register_Masks SYSCON Register Masks
N * @{
N */
N
N/*! @name SYSMEMREMAP - System Remap register */
N/*! @{ */
N#define SYSCON_SYSMEMREMAP_MAP_MASK              (0x3U)
N#define SYSCON_SYSMEMREMAP_MAP_SHIFT             (0U)
N#define SYSCON_SYSMEMREMAP_MAP(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSMEMREMAP_MAP_SHIFT)) & SYSCON_SYSMEMREMAP_MAP_MASK)
N/*! @} */
N
N/*! @name PRESETCTRL - Peripheral reset control register */
N/*! @{ */
N#define SYSCON_PRESETCTRL_SPI0_RST_N_MASK        (0x1U)
N#define SYSCON_PRESETCTRL_SPI0_RST_N_SHIFT       (0U)
N#define SYSCON_PRESETCTRL_SPI0_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SPI0_RST_N_SHIFT)) & SYSCON_PRESETCTRL_SPI0_RST_N_MASK)
N#define SYSCON_PRESETCTRL_SPI1_RST_N_MASK        (0x2U)
N#define SYSCON_PRESETCTRL_SPI1_RST_N_SHIFT       (1U)
N#define SYSCON_PRESETCTRL_SPI1_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SPI1_RST_N_SHIFT)) & SYSCON_PRESETCTRL_SPI1_RST_N_MASK)
N#define SYSCON_PRESETCTRL_UARTFRG_RST_N_MASK     (0x4U)
N#define SYSCON_PRESETCTRL_UARTFRG_RST_N_SHIFT    (2U)
N#define SYSCON_PRESETCTRL_UARTFRG_RST_N(x)       (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_UARTFRG_RST_N_SHIFT)) & SYSCON_PRESETCTRL_UARTFRG_RST_N_MASK)
N#define SYSCON_PRESETCTRL_UART0_RST_N_MASK       (0x8U)
N#define SYSCON_PRESETCTRL_UART0_RST_N_SHIFT      (3U)
N#define SYSCON_PRESETCTRL_UART0_RST_N(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_UART0_RST_N_SHIFT)) & SYSCON_PRESETCTRL_UART0_RST_N_MASK)
N#define SYSCON_PRESETCTRL_UART1_RST_N_MASK       (0x10U)
N#define SYSCON_PRESETCTRL_UART1_RST_N_SHIFT      (4U)
N#define SYSCON_PRESETCTRL_UART1_RST_N(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_UART1_RST_N_SHIFT)) & SYSCON_PRESETCTRL_UART1_RST_N_MASK)
N#define SYSCON_PRESETCTRL_UART2_RST_N_MASK       (0x20U)
N#define SYSCON_PRESETCTRL_UART2_RST_N_SHIFT      (5U)
N#define SYSCON_PRESETCTRL_UART2_RST_N(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_UART2_RST_N_SHIFT)) & SYSCON_PRESETCTRL_UART2_RST_N_MASK)
N#define SYSCON_PRESETCTRL_I2C0_RST_N_MASK        (0x40U)
N#define SYSCON_PRESETCTRL_I2C0_RST_N_SHIFT       (6U)
N#define SYSCON_PRESETCTRL_I2C0_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_I2C0_RST_N_SHIFT)) & SYSCON_PRESETCTRL_I2C0_RST_N_MASK)
N#define SYSCON_PRESETCTRL_MRT_RST_N_MASK         (0x80U)
N#define SYSCON_PRESETCTRL_MRT_RST_N_SHIFT        (7U)
N#define SYSCON_PRESETCTRL_MRT_RST_N(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_MRT_RST_N_SHIFT)) & SYSCON_PRESETCTRL_MRT_RST_N_MASK)
N#define SYSCON_PRESETCTRL_SCT_RST_N_MASK         (0x100U)
N#define SYSCON_PRESETCTRL_SCT_RST_N_SHIFT        (8U)
N#define SYSCON_PRESETCTRL_SCT_RST_N(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_SCT_RST_N_SHIFT)) & SYSCON_PRESETCTRL_SCT_RST_N_MASK)
N#define SYSCON_PRESETCTRL_WKT_RST_N_MASK         (0x200U)
N#define SYSCON_PRESETCTRL_WKT_RST_N_SHIFT        (9U)
N#define SYSCON_PRESETCTRL_WKT_RST_N(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_WKT_RST_N_SHIFT)) & SYSCON_PRESETCTRL_WKT_RST_N_MASK)
N#define SYSCON_PRESETCTRL_GPIO_RST_N_MASK        (0x400U)
N#define SYSCON_PRESETCTRL_GPIO_RST_N_SHIFT       (10U)
N#define SYSCON_PRESETCTRL_GPIO_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_GPIO_RST_N_SHIFT)) & SYSCON_PRESETCTRL_GPIO_RST_N_MASK)
N#define SYSCON_PRESETCTRL_FLASH_RST_N_MASK       (0x800U)
N#define SYSCON_PRESETCTRL_FLASH_RST_N_SHIFT      (11U)
N#define SYSCON_PRESETCTRL_FLASH_RST_N(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_FLASH_RST_N_SHIFT)) & SYSCON_PRESETCTRL_FLASH_RST_N_MASK)
N#define SYSCON_PRESETCTRL_ACMP_RST_N_MASK        (0x1000U)
N#define SYSCON_PRESETCTRL_ACMP_RST_N_SHIFT       (12U)
N#define SYSCON_PRESETCTRL_ACMP_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_ACMP_RST_N_SHIFT)) & SYSCON_PRESETCTRL_ACMP_RST_N_MASK)
N#define SYSCON_PRESETCTRL_I2C1_RST_N_MASK        (0x4000U)
N#define SYSCON_PRESETCTRL_I2C1_RST_N_SHIFT       (14U)
N#define SYSCON_PRESETCTRL_I2C1_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_I2C1_RST_N_SHIFT)) & SYSCON_PRESETCTRL_I2C1_RST_N_MASK)
N#define SYSCON_PRESETCTRL_I2C2_RST_N_MASK        (0x8000U)
N#define SYSCON_PRESETCTRL_I2C2_RST_N_SHIFT       (15U)
N#define SYSCON_PRESETCTRL_I2C2_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_I2C2_RST_N_SHIFT)) & SYSCON_PRESETCTRL_I2C2_RST_N_MASK)
N#define SYSCON_PRESETCTRL_I2C3_RST_N_MASK        (0x10000U)
N#define SYSCON_PRESETCTRL_I2C3_RST_N_SHIFT       (16U)
N#define SYSCON_PRESETCTRL_I2C3_RST_N(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_I2C3_RST_N_SHIFT)) & SYSCON_PRESETCTRL_I2C3_RST_N_MASK)
N#define SYSCON_PRESETCTRL_ADC_RST_N_MASK         (0x1000000U)
N#define SYSCON_PRESETCTRL_ADC_RST_N_SHIFT        (24U)
N#define SYSCON_PRESETCTRL_ADC_RST_N(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_ADC_RST_N_SHIFT)) & SYSCON_PRESETCTRL_ADC_RST_N_MASK)
N#define SYSCON_PRESETCTRL_DMA_RST_N_MASK         (0x20000000U)
N#define SYSCON_PRESETCTRL_DMA_RST_N_SHIFT        (29U)
N#define SYSCON_PRESETCTRL_DMA_RST_N(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PRESETCTRL_DMA_RST_N_SHIFT)) & SYSCON_PRESETCTRL_DMA_RST_N_MASK)
N/*! @} */
N
N/*! @name SYSPLLCTRL - PLL control */
N/*! @{ */
N#define SYSCON_SYSPLLCTRL_MSEL_MASK              (0x1FU)
N#define SYSCON_SYSPLLCTRL_MSEL_SHIFT             (0U)
N#define SYSCON_SYSPLLCTRL_MSEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_MSEL_SHIFT)) & SYSCON_SYSPLLCTRL_MSEL_MASK)
N#define SYSCON_SYSPLLCTRL_PSEL_MASK              (0x60U)
N#define SYSCON_SYSPLLCTRL_PSEL_SHIFT             (5U)
N#define SYSCON_SYSPLLCTRL_PSEL(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCTRL_PSEL_SHIFT)) & SYSCON_SYSPLLCTRL_PSEL_MASK)
N/*! @} */
N
N/*! @name SYSPLLSTAT - PLL status */
N/*! @{ */
N#define SYSCON_SYSPLLSTAT_LOCK_MASK              (0x1U)
N#define SYSCON_SYSPLLSTAT_LOCK_SHIFT             (0U)
N#define SYSCON_SYSPLLSTAT_LOCK(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLSTAT_LOCK_SHIFT)) & SYSCON_SYSPLLSTAT_LOCK_MASK)
N/*! @} */
N
N/*! @name SYSOSCCTRL - system oscillator control */
N/*! @{ */
N#define SYSCON_SYSOSCCTRL_BYPASS_MASK            (0x1U)
N#define SYSCON_SYSOSCCTRL_BYPASS_SHIFT           (0U)
N#define SYSCON_SYSOSCCTRL_BYPASS(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSOSCCTRL_BYPASS_SHIFT)) & SYSCON_SYSOSCCTRL_BYPASS_MASK)
N#define SYSCON_SYSOSCCTRL_FREQ_RANGE_MASK        (0x2U)
N#define SYSCON_SYSOSCCTRL_FREQ_RANGE_SHIFT       (1U)
N#define SYSCON_SYSOSCCTRL_FREQ_RANGE(x)          (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSOSCCTRL_FREQ_RANGE_SHIFT)) & SYSCON_SYSOSCCTRL_FREQ_RANGE_MASK)
N/*! @} */
N
N/*! @name WDTOSCCTRL - Watchdog oscillator control */
N/*! @{ */
N#define SYSCON_WDTOSCCTRL_DIVSEL_MASK            (0x1FU)
N#define SYSCON_WDTOSCCTRL_DIVSEL_SHIFT           (0U)
N#define SYSCON_WDTOSCCTRL_DIVSEL(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_WDTOSCCTRL_DIVSEL_SHIFT)) & SYSCON_WDTOSCCTRL_DIVSEL_MASK)
N#define SYSCON_WDTOSCCTRL_FREQSEL_MASK           (0x1E0U)
N#define SYSCON_WDTOSCCTRL_FREQSEL_SHIFT          (5U)
N#define SYSCON_WDTOSCCTRL_FREQSEL(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_WDTOSCCTRL_FREQSEL_SHIFT)) & SYSCON_WDTOSCCTRL_FREQSEL_MASK)
N/*! @} */
N
N/*! @name IRCCTRL - IRC control */
N/*! @{ */
N#define SYSCON_IRCCTRL_TRIM_MASK                 (0xFFU)
N#define SYSCON_IRCCTRL_TRIM_SHIFT                (0U)
N#define SYSCON_IRCCTRL_TRIM(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_IRCCTRL_TRIM_SHIFT)) & SYSCON_IRCCTRL_TRIM_MASK)
N/*! @} */
N
N/*! @name SYSRSTSTAT - System reset status register */
N/*! @{ */
N#define SYSCON_SYSRSTSTAT_POR_MASK               (0x1U)
N#define SYSCON_SYSRSTSTAT_POR_SHIFT              (0U)
N#define SYSCON_SYSRSTSTAT_POR(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_POR_SHIFT)) & SYSCON_SYSRSTSTAT_POR_MASK)
N#define SYSCON_SYSRSTSTAT_EXTRST_MASK            (0x2U)
N#define SYSCON_SYSRSTSTAT_EXTRST_SHIFT           (1U)
N#define SYSCON_SYSRSTSTAT_EXTRST(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_EXTRST_SHIFT)) & SYSCON_SYSRSTSTAT_EXTRST_MASK)
N#define SYSCON_SYSRSTSTAT_WDT_MASK               (0x4U)
N#define SYSCON_SYSRSTSTAT_WDT_SHIFT              (2U)
N#define SYSCON_SYSRSTSTAT_WDT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_WDT_SHIFT)) & SYSCON_SYSRSTSTAT_WDT_MASK)
N#define SYSCON_SYSRSTSTAT_BOD_MASK               (0x8U)
N#define SYSCON_SYSRSTSTAT_BOD_SHIFT              (3U)
N#define SYSCON_SYSRSTSTAT_BOD(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_BOD_SHIFT)) & SYSCON_SYSRSTSTAT_BOD_MASK)
N#define SYSCON_SYSRSTSTAT_SYSRST_MASK            (0x10U)
N#define SYSCON_SYSRSTSTAT_SYSRST_SHIFT           (4U)
N#define SYSCON_SYSRSTSTAT_SYSRST(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSRSTSTAT_SYSRST_SHIFT)) & SYSCON_SYSRSTSTAT_SYSRST_MASK)
N/*! @} */
N
N/*! @name SYSPLLCLKSEL - System PLL clock source select register */
N/*! @{ */
N#define SYSCON_SYSPLLCLKSEL_SEL_MASK             (0x3U)
N#define SYSCON_SYSPLLCLKSEL_SEL_SHIFT            (0U)
N#define SYSCON_SYSPLLCLKSEL_SEL(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCLKSEL_SEL_SHIFT)) & SYSCON_SYSPLLCLKSEL_SEL_MASK)
N/*! @} */
N
N/*! @name SYSPLLCLKUEN - System PLL clock source update enable register */
N/*! @{ */
N#define SYSCON_SYSPLLCLKUEN_ENA_MASK             (0x1U)
N#define SYSCON_SYSPLLCLKUEN_ENA_SHIFT            (0U)
N#define SYSCON_SYSPLLCLKUEN_ENA(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSPLLCLKUEN_ENA_SHIFT)) & SYSCON_SYSPLLCLKUEN_ENA_MASK)
N/*! @} */
N
N/*! @name MAINCLKSEL - Main clock source select */
N/*! @{ */
N#define SYSCON_MAINCLKSEL_SEL_MASK               (0x3U)
N#define SYSCON_MAINCLKSEL_SEL_SHIFT              (0U)
N#define SYSCON_MAINCLKSEL_SEL(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_MAINCLKSEL_SEL_SHIFT)) & SYSCON_MAINCLKSEL_SEL_MASK)
N/*! @} */
N
N/*! @name MAINCLKUEN - Main clock source update enable */
N/*! @{ */
N#define SYSCON_MAINCLKUEN_ENA_MASK               (0x1U)
N#define SYSCON_MAINCLKUEN_ENA_SHIFT              (0U)
N#define SYSCON_MAINCLKUEN_ENA(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_MAINCLKUEN_ENA_SHIFT)) & SYSCON_MAINCLKUEN_ENA_MASK)
N/*! @} */
N
N/*! @name SYSAHBCLKDIV - System clock divider */
N/*! @{ */
N#define SYSCON_SYSAHBCLKDIV_DIV_MASK             (0xFFU)
N#define SYSCON_SYSAHBCLKDIV_DIV_SHIFT            (0U)
N#define SYSCON_SYSAHBCLKDIV_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKDIV_DIV_SHIFT)) & SYSCON_SYSAHBCLKDIV_DIV_MASK)
N/*! @} */
N
N/*! @name SYSAHBCLKCTRL - System clock control */
N/*! @{ */
N#define SYSCON_SYSAHBCLKCTRL_SYS_MASK            (0x1U)
N#define SYSCON_SYSAHBCLKCTRL_SYS_SHIFT           (0U)
N#define SYSCON_SYSAHBCLKCTRL_SYS(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_SYS_SHIFT)) & SYSCON_SYSAHBCLKCTRL_SYS_MASK)
N#define SYSCON_SYSAHBCLKCTRL_ROM_MASK            (0x2U)
N#define SYSCON_SYSAHBCLKCTRL_ROM_SHIFT           (1U)
N#define SYSCON_SYSAHBCLKCTRL_ROM(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_ROM_SHIFT)) & SYSCON_SYSAHBCLKCTRL_ROM_MASK)
N#define SYSCON_SYSAHBCLKCTRL_RAM0_1_MASK         (0x4U)
N#define SYSCON_SYSAHBCLKCTRL_RAM0_1_SHIFT        (2U)
N#define SYSCON_SYSAHBCLKCTRL_RAM0_1(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_RAM0_1_SHIFT)) & SYSCON_SYSAHBCLKCTRL_RAM0_1_MASK)
N#define SYSCON_SYSAHBCLKCTRL_FLASHREG_MASK       (0x8U)
N#define SYSCON_SYSAHBCLKCTRL_FLASHREG_SHIFT      (3U)
N#define SYSCON_SYSAHBCLKCTRL_FLASHREG(x)         (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_FLASHREG_SHIFT)) & SYSCON_SYSAHBCLKCTRL_FLASHREG_MASK)
N#define SYSCON_SYSAHBCLKCTRL_FLASH_MASK          (0x10U)
N#define SYSCON_SYSAHBCLKCTRL_FLASH_SHIFT         (4U)
N#define SYSCON_SYSAHBCLKCTRL_FLASH(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_FLASH_SHIFT)) & SYSCON_SYSAHBCLKCTRL_FLASH_MASK)
N#define SYSCON_SYSAHBCLKCTRL_I2C0_MASK           (0x20U)
N#define SYSCON_SYSAHBCLKCTRL_I2C0_SHIFT          (5U)
N#define SYSCON_SYSAHBCLKCTRL_I2C0(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_I2C0_SHIFT)) & SYSCON_SYSAHBCLKCTRL_I2C0_MASK)
N#define SYSCON_SYSAHBCLKCTRL_GPIO_MASK           (0x40U)
N#define SYSCON_SYSAHBCLKCTRL_GPIO_SHIFT          (6U)
N#define SYSCON_SYSAHBCLKCTRL_GPIO(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_GPIO_SHIFT)) & SYSCON_SYSAHBCLKCTRL_GPIO_MASK)
N#define SYSCON_SYSAHBCLKCTRL_SWM_MASK            (0x80U)
N#define SYSCON_SYSAHBCLKCTRL_SWM_SHIFT           (7U)
N#define SYSCON_SYSAHBCLKCTRL_SWM(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_SWM_SHIFT)) & SYSCON_SYSAHBCLKCTRL_SWM_MASK)
N#define SYSCON_SYSAHBCLKCTRL_SCT_MASK            (0x100U)
N#define SYSCON_SYSAHBCLKCTRL_SCT_SHIFT           (8U)
N#define SYSCON_SYSAHBCLKCTRL_SCT(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_SCT_SHIFT)) & SYSCON_SYSAHBCLKCTRL_SCT_MASK)
N#define SYSCON_SYSAHBCLKCTRL_WKT_MASK            (0x200U)
N#define SYSCON_SYSAHBCLKCTRL_WKT_SHIFT           (9U)
N#define SYSCON_SYSAHBCLKCTRL_WKT(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_WKT_SHIFT)) & SYSCON_SYSAHBCLKCTRL_WKT_MASK)
N#define SYSCON_SYSAHBCLKCTRL_MRT_MASK            (0x400U)
N#define SYSCON_SYSAHBCLKCTRL_MRT_SHIFT           (10U)
N#define SYSCON_SYSAHBCLKCTRL_MRT(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_MRT_SHIFT)) & SYSCON_SYSAHBCLKCTRL_MRT_MASK)
N#define SYSCON_SYSAHBCLKCTRL_SPI0_MASK           (0x800U)
N#define SYSCON_SYSAHBCLKCTRL_SPI0_SHIFT          (11U)
N#define SYSCON_SYSAHBCLKCTRL_SPI0(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_SPI0_SHIFT)) & SYSCON_SYSAHBCLKCTRL_SPI0_MASK)
N#define SYSCON_SYSAHBCLKCTRL_SPI1_MASK           (0x1000U)
N#define SYSCON_SYSAHBCLKCTRL_SPI1_SHIFT          (12U)
N#define SYSCON_SYSAHBCLKCTRL_SPI1(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_SPI1_SHIFT)) & SYSCON_SYSAHBCLKCTRL_SPI1_MASK)
N#define SYSCON_SYSAHBCLKCTRL_CRC_MASK            (0x2000U)
N#define SYSCON_SYSAHBCLKCTRL_CRC_SHIFT           (13U)
N#define SYSCON_SYSAHBCLKCTRL_CRC(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_CRC_SHIFT)) & SYSCON_SYSAHBCLKCTRL_CRC_MASK)
N#define SYSCON_SYSAHBCLKCTRL_UART0_MASK          (0x4000U)
N#define SYSCON_SYSAHBCLKCTRL_UART0_SHIFT         (14U)
N#define SYSCON_SYSAHBCLKCTRL_UART0(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_UART0_SHIFT)) & SYSCON_SYSAHBCLKCTRL_UART0_MASK)
N#define SYSCON_SYSAHBCLKCTRL_UART1_MASK          (0x8000U)
N#define SYSCON_SYSAHBCLKCTRL_UART1_SHIFT         (15U)
N#define SYSCON_SYSAHBCLKCTRL_UART1(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_UART1_SHIFT)) & SYSCON_SYSAHBCLKCTRL_UART1_MASK)
N#define SYSCON_SYSAHBCLKCTRL_UART2_MASK          (0x10000U)
N#define SYSCON_SYSAHBCLKCTRL_UART2_SHIFT         (16U)
N#define SYSCON_SYSAHBCLKCTRL_UART2(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_UART2_SHIFT)) & SYSCON_SYSAHBCLKCTRL_UART2_MASK)
N#define SYSCON_SYSAHBCLKCTRL_WWDT_MASK           (0x20000U)
N#define SYSCON_SYSAHBCLKCTRL_WWDT_SHIFT          (17U)
N#define SYSCON_SYSAHBCLKCTRL_WWDT(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_WWDT_SHIFT)) & SYSCON_SYSAHBCLKCTRL_WWDT_MASK)
N#define SYSCON_SYSAHBCLKCTRL_IOCON_MASK          (0x40000U)
N#define SYSCON_SYSAHBCLKCTRL_IOCON_SHIFT         (18U)
N#define SYSCON_SYSAHBCLKCTRL_IOCON(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_IOCON_SHIFT)) & SYSCON_SYSAHBCLKCTRL_IOCON_MASK)
N#define SYSCON_SYSAHBCLKCTRL_ACMP_MASK           (0x80000U)
N#define SYSCON_SYSAHBCLKCTRL_ACMP_SHIFT          (19U)
N#define SYSCON_SYSAHBCLKCTRL_ACMP(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_ACMP_SHIFT)) & SYSCON_SYSAHBCLKCTRL_ACMP_MASK)
N#define SYSCON_SYSAHBCLKCTRL_I2C1_MASK           (0x200000U)
N#define SYSCON_SYSAHBCLKCTRL_I2C1_SHIFT          (21U)
N#define SYSCON_SYSAHBCLKCTRL_I2C1(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_I2C1_SHIFT)) & SYSCON_SYSAHBCLKCTRL_I2C1_MASK)
N#define SYSCON_SYSAHBCLKCTRL_I2C2_MASK           (0x400000U)
N#define SYSCON_SYSAHBCLKCTRL_I2C2_SHIFT          (22U)
N#define SYSCON_SYSAHBCLKCTRL_I2C2(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_I2C2_SHIFT)) & SYSCON_SYSAHBCLKCTRL_I2C2_MASK)
N#define SYSCON_SYSAHBCLKCTRL_I2C3_MASK           (0x800000U)
N#define SYSCON_SYSAHBCLKCTRL_I2C3_SHIFT          (23U)
N#define SYSCON_SYSAHBCLKCTRL_I2C3(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_I2C3_SHIFT)) & SYSCON_SYSAHBCLKCTRL_I2C3_MASK)
N#define SYSCON_SYSAHBCLKCTRL_ADC_MASK            (0x1000000U)
N#define SYSCON_SYSAHBCLKCTRL_ADC_SHIFT           (24U)
N#define SYSCON_SYSAHBCLKCTRL_ADC(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_ADC_SHIFT)) & SYSCON_SYSAHBCLKCTRL_ADC_MASK)
N#define SYSCON_SYSAHBCLKCTRL_MTB_MASK            (0x4000000U)
N#define SYSCON_SYSAHBCLKCTRL_MTB_SHIFT           (26U)
N#define SYSCON_SYSAHBCLKCTRL_MTB(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_MTB_SHIFT)) & SYSCON_SYSAHBCLKCTRL_MTB_MASK)
N#define SYSCON_SYSAHBCLKCTRL_DMA_MASK            (0x20000000U)
N#define SYSCON_SYSAHBCLKCTRL_DMA_SHIFT           (29U)
N#define SYSCON_SYSAHBCLKCTRL_DMA(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSAHBCLKCTRL_DMA_SHIFT)) & SYSCON_SYSAHBCLKCTRL_DMA_MASK)
N/*! @} */
N
N/*! @name UARTCLKDIV - USART clock divider */
N/*! @{ */
N#define SYSCON_UARTCLKDIV_DIV_MASK               (0xFFU)
N#define SYSCON_UARTCLKDIV_DIV_SHIFT              (0U)
N#define SYSCON_UARTCLKDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_UARTCLKDIV_DIV_SHIFT)) & SYSCON_UARTCLKDIV_DIV_MASK)
N/*! @} */
N
N/*! @name CLKOUTSEL - CLKOUT clock source select */
N/*! @{ */
N#define SYSCON_CLKOUTSEL_SEL_MASK                (0x3U)
N#define SYSCON_CLKOUTSEL_SEL_SHIFT               (0U)
N#define SYSCON_CLKOUTSEL_SEL(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTSEL_SEL_SHIFT)) & SYSCON_CLKOUTSEL_SEL_MASK)
N/*! @} */
N
N/*! @name CLKOUTUEN - CLKOUT clock source update enable */
N/*! @{ */
N#define SYSCON_CLKOUTUEN_ENA_MASK                (0x1U)
N#define SYSCON_CLKOUTUEN_ENA_SHIFT               (0U)
N#define SYSCON_CLKOUTUEN_ENA(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTUEN_ENA_SHIFT)) & SYSCON_CLKOUTUEN_ENA_MASK)
N/*! @} */
N
N/*! @name CLKOUTDIV - PLL control */
N/*! @{ */
N#define SYSCON_CLKOUTDIV_DIV_MASK                (0xFFU)
N#define SYSCON_CLKOUTDIV_DIV_SHIFT               (0U)
N#define SYSCON_CLKOUTDIV_DIV(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_CLKOUTDIV_DIV_SHIFT)) & SYSCON_CLKOUTDIV_DIV_MASK)
N/*! @} */
N
N/*! @name UARTFRGDIV - USART1 to USART4 common fractional generator divider value */
N/*! @{ */
N#define SYSCON_UARTFRGDIV_DIV_MASK               (0xFFU)
N#define SYSCON_UARTFRGDIV_DIV_SHIFT              (0U)
N#define SYSCON_UARTFRGDIV_DIV(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_UARTFRGDIV_DIV_SHIFT)) & SYSCON_UARTFRGDIV_DIV_MASK)
N/*! @} */
N
N/*! @name UARTFRGMULT - USART1 to USART4 common fractional generator divider value */
N/*! @{ */
N#define SYSCON_UARTFRGMULT_MULT_MASK             (0xFFU)
N#define SYSCON_UARTFRGMULT_MULT_SHIFT            (0U)
N#define SYSCON_UARTFRGMULT_MULT(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_UARTFRGMULT_MULT_SHIFT)) & SYSCON_UARTFRGMULT_MULT_MASK)
N/*! @} */
N
N/*! @name EXTTRACECMD - External trace buffer command register */
N/*! @{ */
N#define SYSCON_EXTTRACECMD_START_MASK            (0x1U)
N#define SYSCON_EXTTRACECMD_START_SHIFT           (0U)
N#define SYSCON_EXTTRACECMD_START(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_EXTTRACECMD_START_SHIFT)) & SYSCON_EXTTRACECMD_START_MASK)
N#define SYSCON_EXTTRACECMD_STOP_MASK             (0x2U)
N#define SYSCON_EXTTRACECMD_STOP_SHIFT            (1U)
N#define SYSCON_EXTTRACECMD_STOP(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_EXTTRACECMD_STOP_SHIFT)) & SYSCON_EXTTRACECMD_STOP_MASK)
N/*! @} */
N
N/*! @name PIOPORCAP0 - POR captured PIO status 0 */
N/*! @{ */
N#define SYSCON_PIOPORCAP0_PIOSTAT_MASK           (0x3FFFFU)
N#define SYSCON_PIOPORCAP0_PIOSTAT_SHIFT          (0U)
N#define SYSCON_PIOPORCAP0_PIOSTAT(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PIOPORCAP0_PIOSTAT_SHIFT)) & SYSCON_PIOPORCAP0_PIOSTAT_MASK)
N/*! @} */
N
N/*! @name IOCONCLKDIV6 - Peripheral clock 6 to the IOCON block for programmable glitch filter */
N/*! @{ */
N#define SYSCON_IOCONCLKDIV6_DIV_MASK             (0xFFU)
N#define SYSCON_IOCONCLKDIV6_DIV_SHIFT            (0U)
N#define SYSCON_IOCONCLKDIV6_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_IOCONCLKDIV6_DIV_SHIFT)) & SYSCON_IOCONCLKDIV6_DIV_MASK)
N/*! @} */
N
N/*! @name IOCONCLKDIV5 - Peripheral clock 6 to the IOCON block for programmable glitch filter */
N/*! @{ */
N#define SYSCON_IOCONCLKDIV5_DIV_MASK             (0xFFU)
N#define SYSCON_IOCONCLKDIV5_DIV_SHIFT            (0U)
N#define SYSCON_IOCONCLKDIV5_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_IOCONCLKDIV5_DIV_SHIFT)) & SYSCON_IOCONCLKDIV5_DIV_MASK)
N/*! @} */
N
N/*! @name IOCONCLKDIV4 - Peripheral clock 4 to the IOCON block for programmable glitch filter */
N/*! @{ */
N#define SYSCON_IOCONCLKDIV4_DIV_MASK             (0xFFU)
N#define SYSCON_IOCONCLKDIV4_DIV_SHIFT            (0U)
N#define SYSCON_IOCONCLKDIV4_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_IOCONCLKDIV4_DIV_SHIFT)) & SYSCON_IOCONCLKDIV4_DIV_MASK)
N/*! @} */
N
N/*! @name IOCONCLKDIV3 - Peripheral clock 3 to the IOCON block for programmable glitch filter */
N/*! @{ */
N#define SYSCON_IOCONCLKDIV3_DIV_MASK             (0xFFU)
N#define SYSCON_IOCONCLKDIV3_DIV_SHIFT            (0U)
N#define SYSCON_IOCONCLKDIV3_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_IOCONCLKDIV3_DIV_SHIFT)) & SYSCON_IOCONCLKDIV3_DIV_MASK)
N/*! @} */
N
N/*! @name IOCONCLKDIV2 - Peripheral clock 2 to the IOCON block for programmable glitch filter */
N/*! @{ */
N#define SYSCON_IOCONCLKDIV2_DIV_MASK             (0xFFU)
N#define SYSCON_IOCONCLKDIV2_DIV_SHIFT            (0U)
N#define SYSCON_IOCONCLKDIV2_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_IOCONCLKDIV2_DIV_SHIFT)) & SYSCON_IOCONCLKDIV2_DIV_MASK)
N/*! @} */
N
N/*! @name IOCONCLKDIV1 - Peripheral clock 1 to the IOCON block for programmable glitch filter */
N/*! @{ */
N#define SYSCON_IOCONCLKDIV1_DIV_MASK             (0xFFU)
N#define SYSCON_IOCONCLKDIV1_DIV_SHIFT            (0U)
N#define SYSCON_IOCONCLKDIV1_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_IOCONCLKDIV1_DIV_SHIFT)) & SYSCON_IOCONCLKDIV1_DIV_MASK)
N/*! @} */
N
N/*! @name IOCONCLKDIV0 - Peripheral clock 0 to the IOCON block for programmable glitch filter */
N/*! @{ */
N#define SYSCON_IOCONCLKDIV0_DIV_MASK             (0xFFU)
N#define SYSCON_IOCONCLKDIV0_DIV_SHIFT            (0U)
N#define SYSCON_IOCONCLKDIV0_DIV(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_IOCONCLKDIV0_DIV_SHIFT)) & SYSCON_IOCONCLKDIV0_DIV_MASK)
N/*! @} */
N
N/*! @name BODCTRL - BOD control register */
N/*! @{ */
N#define SYSCON_BODCTRL_BODRSTLEV_MASK            (0x3U)
N#define SYSCON_BODCTRL_BODRSTLEV_SHIFT           (0U)
N#define SYSCON_BODCTRL_BODRSTLEV(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODRSTLEV_SHIFT)) & SYSCON_BODCTRL_BODRSTLEV_MASK)
N#define SYSCON_BODCTRL_BODINTVAL_MASK            (0xCU)
N#define SYSCON_BODCTRL_BODINTVAL_SHIFT           (2U)
N#define SYSCON_BODCTRL_BODINTVAL(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODINTVAL_SHIFT)) & SYSCON_BODCTRL_BODINTVAL_MASK)
N#define SYSCON_BODCTRL_BODRSTENA_MASK            (0x10U)
N#define SYSCON_BODCTRL_BODRSTENA_SHIFT           (4U)
N#define SYSCON_BODCTRL_BODRSTENA(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_BODCTRL_BODRSTENA_SHIFT)) & SYSCON_BODCTRL_BODRSTENA_MASK)
N/*! @} */
N
N/*! @name SYSTCKCAL - System tick timer calibration register */
N/*! @{ */
N#define SYSCON_SYSTCKCAL_CAL_MASK                (0x3FFFFFFU)
N#define SYSCON_SYSTCKCAL_CAL_SHIFT               (0U)
N#define SYSCON_SYSTCKCAL_CAL(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_SYSTCKCAL_CAL_SHIFT)) & SYSCON_SYSTCKCAL_CAL_MASK)
N/*! @} */
N
N/*! @name IRQLATENCY - IRQ latency register */
N/*! @{ */
N#define SYSCON_IRQLATENCY_LATENCY_MASK           (0xFFU)
N#define SYSCON_IRQLATENCY_LATENCY_SHIFT          (0U)
N#define SYSCON_IRQLATENCY_LATENCY(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_IRQLATENCY_LATENCY_SHIFT)) & SYSCON_IRQLATENCY_LATENCY_MASK)
N/*! @} */
N
N/*! @name NMISRC - NMI source selection register */
N/*! @{ */
N#define SYSCON_NMISRC_IRQN_MASK                  (0x1FU)
N#define SYSCON_NMISRC_IRQN_SHIFT                 (0U)
N#define SYSCON_NMISRC_IRQN(x)                    (((uint32_t)(((uint32_t)(x)) << SYSCON_NMISRC_IRQN_SHIFT)) & SYSCON_NMISRC_IRQN_MASK)
N#define SYSCON_NMISRC_NMIEN_MASK                 (0x80000000U)
N#define SYSCON_NMISRC_NMIEN_SHIFT                (31U)
N#define SYSCON_NMISRC_NMIEN(x)                   (((uint32_t)(((uint32_t)(x)) << SYSCON_NMISRC_NMIEN_SHIFT)) & SYSCON_NMISRC_NMIEN_MASK)
N/*! @} */
N
N/*! @name PINTSEL - Pin interrupt select registers N */
N/*! @{ */
N#define SYSCON_PINTSEL_INTPIN_MASK               (0x3FU)
N#define SYSCON_PINTSEL_INTPIN_SHIFT              (0U)
N#define SYSCON_PINTSEL_INTPIN(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_PINTSEL_INTPIN_SHIFT)) & SYSCON_PINTSEL_INTPIN_MASK)
N/*! @} */
N
N/* The count of SYSCON_PINTSEL */
N#define SYSCON_PINTSEL_COUNT                     (8U)
N
N/*! @name STARTERP0 - Start logic 0 pin wake-up enable register 0 */
N/*! @{ */
N#define SYSCON_STARTERP0_PINT0_MASK              (0x1U)
N#define SYSCON_STARTERP0_PINT0_SHIFT             (0U)
N#define SYSCON_STARTERP0_PINT0(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT0_SHIFT)) & SYSCON_STARTERP0_PINT0_MASK)
N#define SYSCON_STARTERP0_PINT1_MASK              (0x2U)
N#define SYSCON_STARTERP0_PINT1_SHIFT             (1U)
N#define SYSCON_STARTERP0_PINT1(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT1_SHIFT)) & SYSCON_STARTERP0_PINT1_MASK)
N#define SYSCON_STARTERP0_PINT2_MASK              (0x4U)
N#define SYSCON_STARTERP0_PINT2_SHIFT             (2U)
N#define SYSCON_STARTERP0_PINT2(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT2_SHIFT)) & SYSCON_STARTERP0_PINT2_MASK)
N#define SYSCON_STARTERP0_PINT3_MASK              (0x8U)
N#define SYSCON_STARTERP0_PINT3_SHIFT             (3U)
N#define SYSCON_STARTERP0_PINT3(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT3_SHIFT)) & SYSCON_STARTERP0_PINT3_MASK)
N#define SYSCON_STARTERP0_PINT4_MASK              (0x10U)
N#define SYSCON_STARTERP0_PINT4_SHIFT             (4U)
N#define SYSCON_STARTERP0_PINT4(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT4_SHIFT)) & SYSCON_STARTERP0_PINT4_MASK)
N#define SYSCON_STARTERP0_PINT5_MASK              (0x20U)
N#define SYSCON_STARTERP0_PINT5_SHIFT             (5U)
N#define SYSCON_STARTERP0_PINT5(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT5_SHIFT)) & SYSCON_STARTERP0_PINT5_MASK)
N#define SYSCON_STARTERP0_PINT6_MASK              (0x40U)
N#define SYSCON_STARTERP0_PINT6_SHIFT             (6U)
N#define SYSCON_STARTERP0_PINT6(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT6_SHIFT)) & SYSCON_STARTERP0_PINT6_MASK)
N#define SYSCON_STARTERP0_PINT7_MASK              (0x80U)
N#define SYSCON_STARTERP0_PINT7_SHIFT             (7U)
N#define SYSCON_STARTERP0_PINT7(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP0_PINT7_SHIFT)) & SYSCON_STARTERP0_PINT7_MASK)
N/*! @} */
N
N/*! @name STARTERP1 - Start logic 0 pin wake-up enable register 1 */
N/*! @{ */
N#define SYSCON_STARTERP1_SPI0_MASK               (0x1U)
N#define SYSCON_STARTERP1_SPI0_SHIFT              (0U)
N#define SYSCON_STARTERP1_SPI0(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_SPI0_SHIFT)) & SYSCON_STARTERP1_SPI0_MASK)
N#define SYSCON_STARTERP1_SPI1_MASK               (0x2U)
N#define SYSCON_STARTERP1_SPI1_SHIFT              (1U)
N#define SYSCON_STARTERP1_SPI1(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_SPI1_SHIFT)) & SYSCON_STARTERP1_SPI1_MASK)
N#define SYSCON_STARTERP1_USART0_MASK             (0x8U)
N#define SYSCON_STARTERP1_USART0_SHIFT            (3U)
N#define SYSCON_STARTERP1_USART0(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_USART0_SHIFT)) & SYSCON_STARTERP1_USART0_MASK)
N#define SYSCON_STARTERP1_USART1_MASK             (0x10U)
N#define SYSCON_STARTERP1_USART1_SHIFT            (4U)
N#define SYSCON_STARTERP1_USART1(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_USART1_SHIFT)) & SYSCON_STARTERP1_USART1_MASK)
N#define SYSCON_STARTERP1_USART2_MASK             (0x20U)
N#define SYSCON_STARTERP1_USART2_SHIFT            (5U)
N#define SYSCON_STARTERP1_USART2(x)               (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_USART2_SHIFT)) & SYSCON_STARTERP1_USART2_MASK)
N#define SYSCON_STARTERP1_I2C1_MASK               (0x80U)
N#define SYSCON_STARTERP1_I2C1_SHIFT              (7U)
N#define SYSCON_STARTERP1_I2C1(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_I2C1_SHIFT)) & SYSCON_STARTERP1_I2C1_MASK)
N#define SYSCON_STARTERP1_I2C0_MASK               (0x100U)
N#define SYSCON_STARTERP1_I2C0_SHIFT              (8U)
N#define SYSCON_STARTERP1_I2C0(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_I2C0_SHIFT)) & SYSCON_STARTERP1_I2C0_MASK)
N#define SYSCON_STARTERP1_WWDT_MASK               (0x1000U)
N#define SYSCON_STARTERP1_WWDT_SHIFT              (12U)
N#define SYSCON_STARTERP1_WWDT(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_WWDT_SHIFT)) & SYSCON_STARTERP1_WWDT_MASK)
N#define SYSCON_STARTERP1_BOD_MASK                (0x2000U)
N#define SYSCON_STARTERP1_BOD_SHIFT               (13U)
N#define SYSCON_STARTERP1_BOD(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_BOD_SHIFT)) & SYSCON_STARTERP1_BOD_MASK)
N#define SYSCON_STARTERP1_WKT_MASK                (0x8000U)
N#define SYSCON_STARTERP1_WKT_SHIFT               (15U)
N#define SYSCON_STARTERP1_WKT(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_WKT_SHIFT)) & SYSCON_STARTERP1_WKT_MASK)
N#define SYSCON_STARTERP1_I2C2_MASK               (0x200000U)
N#define SYSCON_STARTERP1_I2C2_SHIFT              (21U)
N#define SYSCON_STARTERP1_I2C2(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_I2C2_SHIFT)) & SYSCON_STARTERP1_I2C2_MASK)
N#define SYSCON_STARTERP1_I2C3_MASK               (0x400000U)
N#define SYSCON_STARTERP1_I2C3_SHIFT              (22U)
N#define SYSCON_STARTERP1_I2C3(x)                 (((uint32_t)(((uint32_t)(x)) << SYSCON_STARTERP1_I2C3_SHIFT)) & SYSCON_STARTERP1_I2C3_MASK)
N/*! @} */
N
N/*! @name PDSLEEPCFG - Deep-sleep configuration register */
N/*! @{ */
N#define SYSCON_PDSLEEPCFG_BOD_PD_MASK            (0x8U)
N#define SYSCON_PDSLEEPCFG_BOD_PD_SHIFT           (3U)
N#define SYSCON_PDSLEEPCFG_BOD_PD(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_BOD_PD_SHIFT)) & SYSCON_PDSLEEPCFG_BOD_PD_MASK)
N#define SYSCON_PDSLEEPCFG_WDTOSC_PD_MASK         (0x40U)
N#define SYSCON_PDSLEEPCFG_WDTOSC_PD_SHIFT        (6U)
N#define SYSCON_PDSLEEPCFG_WDTOSC_PD(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDSLEEPCFG_WDTOSC_PD_SHIFT)) & SYSCON_PDSLEEPCFG_WDTOSC_PD_MASK)
N/*! @} */
N
N/*! @name PDAWAKECFG - Wake-up configuration register */
N/*! @{ */
N#define SYSCON_PDAWAKECFG_IRCOUT_PD_MASK         (0x1U)
N#define SYSCON_PDAWAKECFG_IRCOUT_PD_SHIFT        (0U)
N#define SYSCON_PDAWAKECFG_IRCOUT_PD(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_IRCOUT_PD_SHIFT)) & SYSCON_PDAWAKECFG_IRCOUT_PD_MASK)
N#define SYSCON_PDAWAKECFG_IRC_PD_MASK            (0x2U)
N#define SYSCON_PDAWAKECFG_IRC_PD_SHIFT           (1U)
N#define SYSCON_PDAWAKECFG_IRC_PD(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_IRC_PD_SHIFT)) & SYSCON_PDAWAKECFG_IRC_PD_MASK)
N#define SYSCON_PDAWAKECFG_FLASH_PD_MASK          (0x4U)
N#define SYSCON_PDAWAKECFG_FLASH_PD_SHIFT         (2U)
N#define SYSCON_PDAWAKECFG_FLASH_PD(x)            (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_FLASH_PD_SHIFT)) & SYSCON_PDAWAKECFG_FLASH_PD_MASK)
N#define SYSCON_PDAWAKECFG_BOD_PD_MASK            (0x8U)
N#define SYSCON_PDAWAKECFG_BOD_PD_SHIFT           (3U)
N#define SYSCON_PDAWAKECFG_BOD_PD(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_BOD_PD_SHIFT)) & SYSCON_PDAWAKECFG_BOD_PD_MASK)
N#define SYSCON_PDAWAKECFG_ADC_PD_MASK            (0x10U)
N#define SYSCON_PDAWAKECFG_ADC_PD_SHIFT           (4U)
N#define SYSCON_PDAWAKECFG_ADC_PD(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_ADC_PD_SHIFT)) & SYSCON_PDAWAKECFG_ADC_PD_MASK)
N#define SYSCON_PDAWAKECFG_SYSOSC_PD_MASK         (0x20U)
N#define SYSCON_PDAWAKECFG_SYSOSC_PD_SHIFT        (5U)
N#define SYSCON_PDAWAKECFG_SYSOSC_PD(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_SYSOSC_PD_SHIFT)) & SYSCON_PDAWAKECFG_SYSOSC_PD_MASK)
N#define SYSCON_PDAWAKECFG_WDTOSC_PD_MASK         (0x40U)
N#define SYSCON_PDAWAKECFG_WDTOSC_PD_SHIFT        (6U)
N#define SYSCON_PDAWAKECFG_WDTOSC_PD(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_WDTOSC_PD_SHIFT)) & SYSCON_PDAWAKECFG_WDTOSC_PD_MASK)
N#define SYSCON_PDAWAKECFG_SYSPLL_PD_MASK         (0x80U)
N#define SYSCON_PDAWAKECFG_SYSPLL_PD_SHIFT        (7U)
N#define SYSCON_PDAWAKECFG_SYSPLL_PD(x)           (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_SYSPLL_PD_SHIFT)) & SYSCON_PDAWAKECFG_SYSPLL_PD_MASK)
N#define SYSCON_PDAWAKECFG_ACMP_MASK              (0x8000U)
N#define SYSCON_PDAWAKECFG_ACMP_SHIFT             (15U)
N#define SYSCON_PDAWAKECFG_ACMP(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_PDAWAKECFG_ACMP_SHIFT)) & SYSCON_PDAWAKECFG_ACMP_MASK)
N/*! @} */
N
N/*! @name PDRUNCFG - Power configuration register */
N/*! @{ */
N#define SYSCON_PDRUNCFG_IRCOUT_PD_MASK           (0x1U)
N#define SYSCON_PDRUNCFG_IRCOUT_PD_SHIFT          (0U)
N#define SYSCON_PDRUNCFG_IRCOUT_PD(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_IRCOUT_PD_SHIFT)) & SYSCON_PDRUNCFG_IRCOUT_PD_MASK)
N#define SYSCON_PDRUNCFG_IRC_PD_MASK              (0x2U)
N#define SYSCON_PDRUNCFG_IRC_PD_SHIFT             (1U)
N#define SYSCON_PDRUNCFG_IRC_PD(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_IRC_PD_SHIFT)) & SYSCON_PDRUNCFG_IRC_PD_MASK)
N#define SYSCON_PDRUNCFG_FLASH_PD_MASK            (0x4U)
N#define SYSCON_PDRUNCFG_FLASH_PD_SHIFT           (2U)
N#define SYSCON_PDRUNCFG_FLASH_PD(x)              (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_FLASH_PD_SHIFT)) & SYSCON_PDRUNCFG_FLASH_PD_MASK)
N#define SYSCON_PDRUNCFG_BOD_PD_MASK              (0x8U)
N#define SYSCON_PDRUNCFG_BOD_PD_SHIFT             (3U)
N#define SYSCON_PDRUNCFG_BOD_PD(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_BOD_PD_SHIFT)) & SYSCON_PDRUNCFG_BOD_PD_MASK)
N#define SYSCON_PDRUNCFG_ADC_PD_MASK              (0x10U)
N#define SYSCON_PDRUNCFG_ADC_PD_SHIFT             (4U)
N#define SYSCON_PDRUNCFG_ADC_PD(x)                (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_ADC_PD_SHIFT)) & SYSCON_PDRUNCFG_ADC_PD_MASK)
N#define SYSCON_PDRUNCFG_SYSOSC_PD_MASK           (0x20U)
N#define SYSCON_PDRUNCFG_SYSOSC_PD_SHIFT          (5U)
N#define SYSCON_PDRUNCFG_SYSOSC_PD(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_SYSOSC_PD_SHIFT)) & SYSCON_PDRUNCFG_SYSOSC_PD_MASK)
N#define SYSCON_PDRUNCFG_WDTOSC_PD_MASK           (0x40U)
N#define SYSCON_PDRUNCFG_WDTOSC_PD_SHIFT          (6U)
N#define SYSCON_PDRUNCFG_WDTOSC_PD(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_WDTOSC_PD_SHIFT)) & SYSCON_PDRUNCFG_WDTOSC_PD_MASK)
N#define SYSCON_PDRUNCFG_SYSPLL_PD_MASK           (0x80U)
N#define SYSCON_PDRUNCFG_SYSPLL_PD_SHIFT          (7U)
N#define SYSCON_PDRUNCFG_SYSPLL_PD(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_SYSPLL_PD_SHIFT)) & SYSCON_PDRUNCFG_SYSPLL_PD_MASK)
N#define SYSCON_PDRUNCFG_ACMP_MASK                (0x8000U)
N#define SYSCON_PDRUNCFG_ACMP_SHIFT               (15U)
N#define SYSCON_PDRUNCFG_ACMP(x)                  (((uint32_t)(((uint32_t)(x)) << SYSCON_PDRUNCFG_ACMP_SHIFT)) & SYSCON_PDRUNCFG_ACMP_MASK)
N/*! @} */
N
N/*! @name DEVICE_ID - Part ID register */
N/*! @{ */
N#define SYSCON_DEVICE_ID_DEVICEID_MASK           (0xFFFFFFFFU)
N#define SYSCON_DEVICE_ID_DEVICEID_SHIFT          (0U)
N#define SYSCON_DEVICE_ID_DEVICEID(x)             (((uint32_t)(((uint32_t)(x)) << SYSCON_DEVICE_ID_DEVICEID_SHIFT)) & SYSCON_DEVICE_ID_DEVICEID_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group SYSCON_Register_Masks */
N
N
N/* SYSCON - Peripheral instance base addresses */
N/** Peripheral SYSCON base address */
N#define SYSCON_BASE                              (0x40048000u)
N/** Peripheral SYSCON base pointer */
N#define SYSCON                                   ((SYSCON_Type *)SYSCON_BASE)
N/** Array initializer of SYSCON peripheral base addresses */
N#define SYSCON_BASE_ADDRS                        { SYSCON_BASE }
N/** Array initializer of SYSCON peripheral base pointers */
N#define SYSCON_BASE_PTRS                         { SYSCON }
N
N/*!
N * @}
N */ /* end of group SYSCON_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- USART Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USART_Peripheral_Access_Layer USART Peripheral Access Layer
N * @{
N */
N
N/** USART - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CFG;                               /**< USART Configuration register. Basic USART configuration settings that typically are not changed during operation., offset: 0x0 */
X  volatile uint32_t CFG;                                
N  __IO uint32_t CTL;                               /**< USART Control register. USART control settings that are more likely to change during operation., offset: 0x4 */
X  volatile uint32_t CTL;                                
N  __IO uint32_t STAT;                              /**< USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them., offset: 0x8 */
X  volatile uint32_t STAT;                               
N  __IO uint32_t INTENSET;                          /**< Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set., offset: 0xC */
X  volatile uint32_t INTENSET;                           
N  __O  uint32_t INTENCLR;                          /**< Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared., offset: 0x10 */
X  volatile  uint32_t INTENCLR;                           
N  __I  uint32_t RXDAT;                             /**< Receiver Data register. Contains the last character received., offset: 0x14 */
X  volatile const  uint32_t RXDAT;                              
N  __I  uint32_t RXDATSTAT;                         /**< Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together., offset: 0x18 */
X  volatile const  uint32_t RXDATSTAT;                          
N  __IO uint32_t TXDAT;                             /**< Transmit Data register. Data to be transmitted is written here., offset: 0x1C */
X  volatile uint32_t TXDAT;                              
N  __IO uint32_t BRG;                               /**< Baud Rate Generator register. 16-bit integer baud rate divisor value., offset: 0x20 */
X  volatile uint32_t BRG;                                
N  __I  uint32_t INTSTAT;                           /**< Interrupt status register. Reflects interrupts that are currently enabled., offset: 0x24 */
X  volatile const  uint32_t INTSTAT;                            
N  __IO uint32_t OSR;                               /**< Oversample selection register for asynchronous communication., offset: 0x28 */
X  volatile uint32_t OSR;                                
N  __IO uint32_t ADDR;                              /**< Address register for automatic address matching., offset: 0x2C */
X  volatile uint32_t ADDR;                               
N} USART_Type;
N
N/* ----------------------------------------------------------------------------
N   -- USART Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup USART_Register_Masks USART Register Masks
N * @{
N */
N
N/*! @name CFG - USART Configuration register. Basic USART configuration settings that typically are not changed during operation. */
N/*! @{ */
N#define USART_CFG_ENABLE_MASK                    (0x1U)
N#define USART_CFG_ENABLE_SHIFT                   (0U)
N#define USART_CFG_ENABLE(x)                      (((uint32_t)(((uint32_t)(x)) << USART_CFG_ENABLE_SHIFT)) & USART_CFG_ENABLE_MASK)
N#define USART_CFG_DATALEN_MASK                   (0xCU)
N#define USART_CFG_DATALEN_SHIFT                  (2U)
N#define USART_CFG_DATALEN(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_DATALEN_SHIFT)) & USART_CFG_DATALEN_MASK)
N#define USART_CFG_PARITYSEL_MASK                 (0x30U)
N#define USART_CFG_PARITYSEL_SHIFT                (4U)
N#define USART_CFG_PARITYSEL(x)                   (((uint32_t)(((uint32_t)(x)) << USART_CFG_PARITYSEL_SHIFT)) & USART_CFG_PARITYSEL_MASK)
N#define USART_CFG_STOPLEN_MASK                   (0x40U)
N#define USART_CFG_STOPLEN_SHIFT                  (6U)
N#define USART_CFG_STOPLEN(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_STOPLEN_SHIFT)) & USART_CFG_STOPLEN_MASK)
N#define USART_CFG_CTSEN_MASK                     (0x200U)
N#define USART_CFG_CTSEN_SHIFT                    (9U)
N#define USART_CFG_CTSEN(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_CTSEN_SHIFT)) & USART_CFG_CTSEN_MASK)
N#define USART_CFG_SYNCEN_MASK                    (0x800U)
N#define USART_CFG_SYNCEN_SHIFT                   (11U)
N#define USART_CFG_SYNCEN(x)                      (((uint32_t)(((uint32_t)(x)) << USART_CFG_SYNCEN_SHIFT)) & USART_CFG_SYNCEN_MASK)
N#define USART_CFG_CLKPOL_MASK                    (0x1000U)
N#define USART_CFG_CLKPOL_SHIFT                   (12U)
N#define USART_CFG_CLKPOL(x)                      (((uint32_t)(((uint32_t)(x)) << USART_CFG_CLKPOL_SHIFT)) & USART_CFG_CLKPOL_MASK)
N#define USART_CFG_SYNCMST_MASK                   (0x4000U)
N#define USART_CFG_SYNCMST_SHIFT                  (14U)
N#define USART_CFG_SYNCMST(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CFG_SYNCMST_SHIFT)) & USART_CFG_SYNCMST_MASK)
N#define USART_CFG_LOOP_MASK                      (0x8000U)
N#define USART_CFG_LOOP_SHIFT                     (15U)
N#define USART_CFG_LOOP(x)                        (((uint32_t)(((uint32_t)(x)) << USART_CFG_LOOP_SHIFT)) & USART_CFG_LOOP_MASK)
N#define USART_CFG_OETA_MASK                      (0x40000U)
N#define USART_CFG_OETA_SHIFT                     (18U)
N#define USART_CFG_OETA(x)                        (((uint32_t)(((uint32_t)(x)) << USART_CFG_OETA_SHIFT)) & USART_CFG_OETA_MASK)
N#define USART_CFG_AUTOADDR_MASK                  (0x80000U)
N#define USART_CFG_AUTOADDR_SHIFT                 (19U)
N#define USART_CFG_AUTOADDR(x)                    (((uint32_t)(((uint32_t)(x)) << USART_CFG_AUTOADDR_SHIFT)) & USART_CFG_AUTOADDR_MASK)
N#define USART_CFG_OESEL_MASK                     (0x100000U)
N#define USART_CFG_OESEL_SHIFT                    (20U)
N#define USART_CFG_OESEL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_OESEL_SHIFT)) & USART_CFG_OESEL_MASK)
N#define USART_CFG_OEPOL_MASK                     (0x200000U)
N#define USART_CFG_OEPOL_SHIFT                    (21U)
N#define USART_CFG_OEPOL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_OEPOL_SHIFT)) & USART_CFG_OEPOL_MASK)
N#define USART_CFG_RXPOL_MASK                     (0x400000U)
N#define USART_CFG_RXPOL_SHIFT                    (22U)
N#define USART_CFG_RXPOL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_RXPOL_SHIFT)) & USART_CFG_RXPOL_MASK)
N#define USART_CFG_TXPOL_MASK                     (0x800000U)
N#define USART_CFG_TXPOL_SHIFT                    (23U)
N#define USART_CFG_TXPOL(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CFG_TXPOL_SHIFT)) & USART_CFG_TXPOL_MASK)
N/*! @} */
N
N/*! @name CTL - USART Control register. USART control settings that are more likely to change during operation. */
N/*! @{ */
N#define USART_CTL_TXBRKEN_MASK                   (0x2U)
N#define USART_CTL_TXBRKEN_SHIFT                  (1U)
N#define USART_CTL_TXBRKEN(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CTL_TXBRKEN_SHIFT)) & USART_CTL_TXBRKEN_MASK)
N#define USART_CTL_ADDRDET_MASK                   (0x4U)
N#define USART_CTL_ADDRDET_SHIFT                  (2U)
N#define USART_CTL_ADDRDET(x)                     (((uint32_t)(((uint32_t)(x)) << USART_CTL_ADDRDET_SHIFT)) & USART_CTL_ADDRDET_MASK)
N#define USART_CTL_TXDIS_MASK                     (0x40U)
N#define USART_CTL_TXDIS_SHIFT                    (6U)
N#define USART_CTL_TXDIS(x)                       (((uint32_t)(((uint32_t)(x)) << USART_CTL_TXDIS_SHIFT)) & USART_CTL_TXDIS_MASK)
N#define USART_CTL_CC_MASK                        (0x100U)
N#define USART_CTL_CC_SHIFT                       (8U)
N#define USART_CTL_CC(x)                          (((uint32_t)(((uint32_t)(x)) << USART_CTL_CC_SHIFT)) & USART_CTL_CC_MASK)
N#define USART_CTL_CLRCCONRX_MASK                 (0x200U)
N#define USART_CTL_CLRCCONRX_SHIFT                (9U)
N#define USART_CTL_CLRCCONRX(x)                   (((uint32_t)(((uint32_t)(x)) << USART_CTL_CLRCCONRX_SHIFT)) & USART_CTL_CLRCCONRX_MASK)
N#define USART_CTL_AUTOBAUD_MASK                  (0x10000U)
N#define USART_CTL_AUTOBAUD_SHIFT                 (16U)
N#define USART_CTL_AUTOBAUD(x)                    (((uint32_t)(((uint32_t)(x)) << USART_CTL_AUTOBAUD_SHIFT)) & USART_CTL_AUTOBAUD_MASK)
N/*! @} */
N
N/*! @name STAT - USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them. */
N/*! @{ */
N#define USART_STAT_RXRDY_MASK                    (0x1U)
N#define USART_STAT_RXRDY_SHIFT                   (0U)
N#define USART_STAT_RXRDY(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_RXRDY_SHIFT)) & USART_STAT_RXRDY_MASK)
N#define USART_STAT_RXIDLE_MASK                   (0x2U)
N#define USART_STAT_RXIDLE_SHIFT                  (1U)
N#define USART_STAT_RXIDLE(x)                     (((uint32_t)(((uint32_t)(x)) << USART_STAT_RXIDLE_SHIFT)) & USART_STAT_RXIDLE_MASK)
N#define USART_STAT_TXRDY_MASK                    (0x4U)
N#define USART_STAT_TXRDY_SHIFT                   (2U)
N#define USART_STAT_TXRDY(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_TXRDY_SHIFT)) & USART_STAT_TXRDY_MASK)
N#define USART_STAT_TXIDLE_MASK                   (0x8U)
N#define USART_STAT_TXIDLE_SHIFT                  (3U)
N#define USART_STAT_TXIDLE(x)                     (((uint32_t)(((uint32_t)(x)) << USART_STAT_TXIDLE_SHIFT)) & USART_STAT_TXIDLE_MASK)
N#define USART_STAT_CTS_MASK                      (0x10U)
N#define USART_STAT_CTS_SHIFT                     (4U)
N#define USART_STAT_CTS(x)                        (((uint32_t)(((uint32_t)(x)) << USART_STAT_CTS_SHIFT)) & USART_STAT_CTS_MASK)
N#define USART_STAT_DELTACTS_MASK                 (0x20U)
N#define USART_STAT_DELTACTS_SHIFT                (5U)
N#define USART_STAT_DELTACTS(x)                   (((uint32_t)(((uint32_t)(x)) << USART_STAT_DELTACTS_SHIFT)) & USART_STAT_DELTACTS_MASK)
N#define USART_STAT_TXDISSTAT_MASK                (0x40U)
N#define USART_STAT_TXDISSTAT_SHIFT               (6U)
N#define USART_STAT_TXDISSTAT(x)                  (((uint32_t)(((uint32_t)(x)) << USART_STAT_TXDISSTAT_SHIFT)) & USART_STAT_TXDISSTAT_MASK)
N#define USART_STAT_OVERRUNINT_MASK               (0x100U)
N#define USART_STAT_OVERRUNINT_SHIFT              (8U)
N#define USART_STAT_OVERRUNINT(x)                 (((uint32_t)(((uint32_t)(x)) << USART_STAT_OVERRUNINT_SHIFT)) & USART_STAT_OVERRUNINT_MASK)
N#define USART_STAT_RXBRK_MASK                    (0x400U)
N#define USART_STAT_RXBRK_SHIFT                   (10U)
N#define USART_STAT_RXBRK(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_RXBRK_SHIFT)) & USART_STAT_RXBRK_MASK)
N#define USART_STAT_DELTARXBRK_MASK               (0x800U)
N#define USART_STAT_DELTARXBRK_SHIFT              (11U)
N#define USART_STAT_DELTARXBRK(x)                 (((uint32_t)(((uint32_t)(x)) << USART_STAT_DELTARXBRK_SHIFT)) & USART_STAT_DELTARXBRK_MASK)
N#define USART_STAT_START_MASK                    (0x1000U)
N#define USART_STAT_START_SHIFT                   (12U)
N#define USART_STAT_START(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_START_SHIFT)) & USART_STAT_START_MASK)
N#define USART_STAT_FRAMERRINT_MASK               (0x2000U)
N#define USART_STAT_FRAMERRINT_SHIFT              (13U)
N#define USART_STAT_FRAMERRINT(x)                 (((uint32_t)(((uint32_t)(x)) << USART_STAT_FRAMERRINT_SHIFT)) & USART_STAT_FRAMERRINT_MASK)
N#define USART_STAT_PARITYERRINT_MASK             (0x4000U)
N#define USART_STAT_PARITYERRINT_SHIFT            (14U)
N#define USART_STAT_PARITYERRINT(x)               (((uint32_t)(((uint32_t)(x)) << USART_STAT_PARITYERRINT_SHIFT)) & USART_STAT_PARITYERRINT_MASK)
N#define USART_STAT_RXNOISEINT_MASK               (0x8000U)
N#define USART_STAT_RXNOISEINT_SHIFT              (15U)
N#define USART_STAT_RXNOISEINT(x)                 (((uint32_t)(((uint32_t)(x)) << USART_STAT_RXNOISEINT_SHIFT)) & USART_STAT_RXNOISEINT_MASK)
N#define USART_STAT_ABERR_MASK                    (0x10000U)
N#define USART_STAT_ABERR_SHIFT                   (16U)
N#define USART_STAT_ABERR(x)                      (((uint32_t)(((uint32_t)(x)) << USART_STAT_ABERR_SHIFT)) & USART_STAT_ABERR_MASK)
N/*! @} */
N
N/*! @name INTENSET - Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set. */
N/*! @{ */
N#define USART_INTENSET_RXRDYEN_MASK              (0x1U)
N#define USART_INTENSET_RXRDYEN_SHIFT             (0U)
N#define USART_INTENSET_RXRDYEN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_RXRDYEN_SHIFT)) & USART_INTENSET_RXRDYEN_MASK)
N#define USART_INTENSET_TXRDYEN_MASK              (0x4U)
N#define USART_INTENSET_TXRDYEN_SHIFT             (2U)
N#define USART_INTENSET_TXRDYEN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_TXRDYEN_SHIFT)) & USART_INTENSET_TXRDYEN_MASK)
N#define USART_INTENSET_TXIDLEEN_MASK             (0x8U)
N#define USART_INTENSET_TXIDLEEN_SHIFT            (3U)
N#define USART_INTENSET_TXIDLEEN(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_TXIDLEEN_SHIFT)) & USART_INTENSET_TXIDLEEN_MASK)
N#define USART_INTENSET_DELTACTSEN_MASK           (0x20U)
N#define USART_INTENSET_DELTACTSEN_SHIFT          (5U)
N#define USART_INTENSET_DELTACTSEN(x)             (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_DELTACTSEN_SHIFT)) & USART_INTENSET_DELTACTSEN_MASK)
N#define USART_INTENSET_TXDISEN_MASK              (0x40U)
N#define USART_INTENSET_TXDISEN_SHIFT             (6U)
N#define USART_INTENSET_TXDISEN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_TXDISEN_SHIFT)) & USART_INTENSET_TXDISEN_MASK)
N#define USART_INTENSET_OVERRUNEN_MASK            (0x100U)
N#define USART_INTENSET_OVERRUNEN_SHIFT           (8U)
N#define USART_INTENSET_OVERRUNEN(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_OVERRUNEN_SHIFT)) & USART_INTENSET_OVERRUNEN_MASK)
N#define USART_INTENSET_DELTARXBRKEN_MASK         (0x800U)
N#define USART_INTENSET_DELTARXBRKEN_SHIFT        (11U)
N#define USART_INTENSET_DELTARXBRKEN(x)           (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_DELTARXBRKEN_SHIFT)) & USART_INTENSET_DELTARXBRKEN_MASK)
N#define USART_INTENSET_STARTEN_MASK              (0x1000U)
N#define USART_INTENSET_STARTEN_SHIFT             (12U)
N#define USART_INTENSET_STARTEN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_STARTEN_SHIFT)) & USART_INTENSET_STARTEN_MASK)
N#define USART_INTENSET_FRAMERREN_MASK            (0x2000U)
N#define USART_INTENSET_FRAMERREN_SHIFT           (13U)
N#define USART_INTENSET_FRAMERREN(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_FRAMERREN_SHIFT)) & USART_INTENSET_FRAMERREN_MASK)
N#define USART_INTENSET_PARITYERREN_MASK          (0x4000U)
N#define USART_INTENSET_PARITYERREN_SHIFT         (14U)
N#define USART_INTENSET_PARITYERREN(x)            (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_PARITYERREN_SHIFT)) & USART_INTENSET_PARITYERREN_MASK)
N#define USART_INTENSET_RXNOISEEN_MASK            (0x8000U)
N#define USART_INTENSET_RXNOISEEN_SHIFT           (15U)
N#define USART_INTENSET_RXNOISEEN(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_RXNOISEEN_SHIFT)) & USART_INTENSET_RXNOISEEN_MASK)
N#define USART_INTENSET_ABERREN_MASK              (0x10000U)
N#define USART_INTENSET_ABERREN_SHIFT             (16U)
N#define USART_INTENSET_ABERREN(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTENSET_ABERREN_SHIFT)) & USART_INTENSET_ABERREN_MASK)
N/*! @} */
N
N/*! @name INTENCLR - Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared. */
N/*! @{ */
N#define USART_INTENCLR_RXRDYCLR_MASK             (0x1U)
N#define USART_INTENCLR_RXRDYCLR_SHIFT            (0U)
N#define USART_INTENCLR_RXRDYCLR(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_RXRDYCLR_SHIFT)) & USART_INTENCLR_RXRDYCLR_MASK)
N#define USART_INTENCLR_TXRDYCLR_MASK             (0x4U)
N#define USART_INTENCLR_TXRDYCLR_SHIFT            (2U)
N#define USART_INTENCLR_TXRDYCLR(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_TXRDYCLR_SHIFT)) & USART_INTENCLR_TXRDYCLR_MASK)
N#define USART_INTENCLR_TXIDLECLR_MASK            (0x8U)
N#define USART_INTENCLR_TXIDLECLR_SHIFT           (3U)
N#define USART_INTENCLR_TXIDLECLR(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_TXIDLECLR_SHIFT)) & USART_INTENCLR_TXIDLECLR_MASK)
N#define USART_INTENCLR_DELTACTSCLR_MASK          (0x20U)
N#define USART_INTENCLR_DELTACTSCLR_SHIFT         (5U)
N#define USART_INTENCLR_DELTACTSCLR(x)            (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_DELTACTSCLR_SHIFT)) & USART_INTENCLR_DELTACTSCLR_MASK)
N#define USART_INTENCLR_TXDISINTCLR_MASK          (0x40U)
N#define USART_INTENCLR_TXDISINTCLR_SHIFT         (6U)
N#define USART_INTENCLR_TXDISINTCLR(x)            (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_TXDISINTCLR_SHIFT)) & USART_INTENCLR_TXDISINTCLR_MASK)
N#define USART_INTENCLR_OVERRUNCLR_MASK           (0x100U)
N#define USART_INTENCLR_OVERRUNCLR_SHIFT          (8U)
N#define USART_INTENCLR_OVERRUNCLR(x)             (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_OVERRUNCLR_SHIFT)) & USART_INTENCLR_OVERRUNCLR_MASK)
N#define USART_INTENCLR_DELTARXBRKCLR_MASK        (0x800U)
N#define USART_INTENCLR_DELTARXBRKCLR_SHIFT       (11U)
N#define USART_INTENCLR_DELTARXBRKCLR(x)          (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_DELTARXBRKCLR_SHIFT)) & USART_INTENCLR_DELTARXBRKCLR_MASK)
N#define USART_INTENCLR_STARTCLR_MASK             (0x1000U)
N#define USART_INTENCLR_STARTCLR_SHIFT            (12U)
N#define USART_INTENCLR_STARTCLR(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_STARTCLR_SHIFT)) & USART_INTENCLR_STARTCLR_MASK)
N#define USART_INTENCLR_FRAMERRCLR_MASK           (0x2000U)
N#define USART_INTENCLR_FRAMERRCLR_SHIFT          (13U)
N#define USART_INTENCLR_FRAMERRCLR(x)             (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_FRAMERRCLR_SHIFT)) & USART_INTENCLR_FRAMERRCLR_MASK)
N#define USART_INTENCLR_PARITYERRCLR_MASK         (0x4000U)
N#define USART_INTENCLR_PARITYERRCLR_SHIFT        (14U)
N#define USART_INTENCLR_PARITYERRCLR(x)           (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_PARITYERRCLR_SHIFT)) & USART_INTENCLR_PARITYERRCLR_MASK)
N#define USART_INTENCLR_RXNOISECLR_MASK           (0x8000U)
N#define USART_INTENCLR_RXNOISECLR_SHIFT          (15U)
N#define USART_INTENCLR_RXNOISECLR(x)             (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_RXNOISECLR_SHIFT)) & USART_INTENCLR_RXNOISECLR_MASK)
N#define USART_INTENCLR_ABERRCLR_MASK             (0x10000U)
N#define USART_INTENCLR_ABERRCLR_SHIFT            (16U)
N#define USART_INTENCLR_ABERRCLR(x)               (((uint32_t)(((uint32_t)(x)) << USART_INTENCLR_ABERRCLR_SHIFT)) & USART_INTENCLR_ABERRCLR_MASK)
N/*! @} */
N
N/*! @name RXDAT - Receiver Data register. Contains the last character received. */
N/*! @{ */
N#define USART_RXDAT_RXDAT_MASK                   (0x1FFU)
N#define USART_RXDAT_RXDAT_SHIFT                  (0U)
N#define USART_RXDAT_RXDAT(x)                     (((uint32_t)(((uint32_t)(x)) << USART_RXDAT_RXDAT_SHIFT)) & USART_RXDAT_RXDAT_MASK)
N/*! @} */
N
N/*! @name RXDATSTAT - Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows DMA or software to recover incoming data and status together. */
N/*! @{ */
N#define USART_RXDATSTAT_RXDAT_MASK               (0x1FFU)
N#define USART_RXDATSTAT_RXDAT_SHIFT              (0U)
N#define USART_RXDATSTAT_RXDAT(x)                 (((uint32_t)(((uint32_t)(x)) << USART_RXDATSTAT_RXDAT_SHIFT)) & USART_RXDATSTAT_RXDAT_MASK)
N#define USART_RXDATSTAT_FRAMERR_MASK             (0x2000U)
N#define USART_RXDATSTAT_FRAMERR_SHIFT            (13U)
N#define USART_RXDATSTAT_FRAMERR(x)               (((uint32_t)(((uint32_t)(x)) << USART_RXDATSTAT_FRAMERR_SHIFT)) & USART_RXDATSTAT_FRAMERR_MASK)
N#define USART_RXDATSTAT_PARITYERR_MASK           (0x4000U)
N#define USART_RXDATSTAT_PARITYERR_SHIFT          (14U)
N#define USART_RXDATSTAT_PARITYERR(x)             (((uint32_t)(((uint32_t)(x)) << USART_RXDATSTAT_PARITYERR_SHIFT)) & USART_RXDATSTAT_PARITYERR_MASK)
N#define USART_RXDATSTAT_RXNOISE_MASK             (0x8000U)
N#define USART_RXDATSTAT_RXNOISE_SHIFT            (15U)
N#define USART_RXDATSTAT_RXNOISE(x)               (((uint32_t)(((uint32_t)(x)) << USART_RXDATSTAT_RXNOISE_SHIFT)) & USART_RXDATSTAT_RXNOISE_MASK)
N/*! @} */
N
N/*! @name TXDAT - Transmit Data register. Data to be transmitted is written here. */
N/*! @{ */
N#define USART_TXDAT_TXDAT_MASK                   (0x1FFU)
N#define USART_TXDAT_TXDAT_SHIFT                  (0U)
N#define USART_TXDAT_TXDAT(x)                     (((uint32_t)(((uint32_t)(x)) << USART_TXDAT_TXDAT_SHIFT)) & USART_TXDAT_TXDAT_MASK)
N/*! @} */
N
N/*! @name BRG - Baud Rate Generator register. 16-bit integer baud rate divisor value. */
N/*! @{ */
N#define USART_BRG_BRGVAL_MASK                    (0xFFFFU)
N#define USART_BRG_BRGVAL_SHIFT                   (0U)
N#define USART_BRG_BRGVAL(x)                      (((uint32_t)(((uint32_t)(x)) << USART_BRG_BRGVAL_SHIFT)) & USART_BRG_BRGVAL_MASK)
N/*! @} */
N
N/*! @name INTSTAT - Interrupt status register. Reflects interrupts that are currently enabled. */
N/*! @{ */
N#define USART_INTSTAT_RXRDY_MASK                 (0x1U)
N#define USART_INTSTAT_RXRDY_SHIFT                (0U)
N#define USART_INTSTAT_RXRDY(x)                   (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_RXRDY_SHIFT)) & USART_INTSTAT_RXRDY_MASK)
N#define USART_INTSTAT_TXRDY_MASK                 (0x4U)
N#define USART_INTSTAT_TXRDY_SHIFT                (2U)
N#define USART_INTSTAT_TXRDY(x)                   (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_TXRDY_SHIFT)) & USART_INTSTAT_TXRDY_MASK)
N#define USART_INTSTAT_TXIDLE_MASK                (0x8U)
N#define USART_INTSTAT_TXIDLE_SHIFT               (3U)
N#define USART_INTSTAT_TXIDLE(x)                  (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_TXIDLE_SHIFT)) & USART_INTSTAT_TXIDLE_MASK)
N#define USART_INTSTAT_DELTACTS_MASK              (0x20U)
N#define USART_INTSTAT_DELTACTS_SHIFT             (5U)
N#define USART_INTSTAT_DELTACTS(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_DELTACTS_SHIFT)) & USART_INTSTAT_DELTACTS_MASK)
N#define USART_INTSTAT_TXDISINT_MASK              (0x40U)
N#define USART_INTSTAT_TXDISINT_SHIFT             (6U)
N#define USART_INTSTAT_TXDISINT(x)                (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_TXDISINT_SHIFT)) & USART_INTSTAT_TXDISINT_MASK)
N#define USART_INTSTAT_OVERRUNINT_MASK            (0x100U)
N#define USART_INTSTAT_OVERRUNINT_SHIFT           (8U)
N#define USART_INTSTAT_OVERRUNINT(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_OVERRUNINT_SHIFT)) & USART_INTSTAT_OVERRUNINT_MASK)
N#define USART_INTSTAT_DELTARXBRK_MASK            (0x800U)
N#define USART_INTSTAT_DELTARXBRK_SHIFT           (11U)
N#define USART_INTSTAT_DELTARXBRK(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_DELTARXBRK_SHIFT)) & USART_INTSTAT_DELTARXBRK_MASK)
N#define USART_INTSTAT_START_MASK                 (0x1000U)
N#define USART_INTSTAT_START_SHIFT                (12U)
N#define USART_INTSTAT_START(x)                   (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_START_SHIFT)) & USART_INTSTAT_START_MASK)
N#define USART_INTSTAT_FRAMERRINT_MASK            (0x2000U)
N#define USART_INTSTAT_FRAMERRINT_SHIFT           (13U)
N#define USART_INTSTAT_FRAMERRINT(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_FRAMERRINT_SHIFT)) & USART_INTSTAT_FRAMERRINT_MASK)
N#define USART_INTSTAT_PARITYERRINT_MASK          (0x4000U)
N#define USART_INTSTAT_PARITYERRINT_SHIFT         (14U)
N#define USART_INTSTAT_PARITYERRINT(x)            (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_PARITYERRINT_SHIFT)) & USART_INTSTAT_PARITYERRINT_MASK)
N#define USART_INTSTAT_RXNOISEINT_MASK            (0x8000U)
N#define USART_INTSTAT_RXNOISEINT_SHIFT           (15U)
N#define USART_INTSTAT_RXNOISEINT(x)              (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_RXNOISEINT_SHIFT)) & USART_INTSTAT_RXNOISEINT_MASK)
N#define USART_INTSTAT_ABERR_MASK                 (0x10000U)
N#define USART_INTSTAT_ABERR_SHIFT                (16U)
N#define USART_INTSTAT_ABERR(x)                   (((uint32_t)(((uint32_t)(x)) << USART_INTSTAT_ABERR_SHIFT)) & USART_INTSTAT_ABERR_MASK)
N/*! @} */
N
N/*! @name OSR - Oversample selection register for asynchronous communication. */
N/*! @{ */
N#define USART_OSR_OSRVAL_MASK                    (0xFU)
N#define USART_OSR_OSRVAL_SHIFT                   (0U)
N#define USART_OSR_OSRVAL(x)                      (((uint32_t)(((uint32_t)(x)) << USART_OSR_OSRVAL_SHIFT)) & USART_OSR_OSRVAL_MASK)
N/*! @} */
N
N/*! @name ADDR - Address register for automatic address matching. */
N/*! @{ */
N#define USART_ADDR_ADDRESS_MASK                  (0xFFU)
N#define USART_ADDR_ADDRESS_SHIFT                 (0U)
N#define USART_ADDR_ADDRESS(x)                    (((uint32_t)(((uint32_t)(x)) << USART_ADDR_ADDRESS_SHIFT)) & USART_ADDR_ADDRESS_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group USART_Register_Masks */
N
N
N/* USART - Peripheral instance base addresses */
N/** Peripheral USART0 base address */
N#define USART0_BASE                              (0x40064000u)
N/** Peripheral USART0 base pointer */
N#define USART0                                   ((USART_Type *)USART0_BASE)
N/** Peripheral USART1 base address */
N#define USART1_BASE                              (0x40068000u)
N/** Peripheral USART1 base pointer */
N#define USART1                                   ((USART_Type *)USART1_BASE)
N/** Peripheral USART2 base address */
N#define USART2_BASE                              (0x4006C000u)
N/** Peripheral USART2 base pointer */
N#define USART2                                   ((USART_Type *)USART2_BASE)
N/** Array initializer of USART peripheral base addresses */
N#define USART_BASE_ADDRS                         { USART0_BASE, USART1_BASE, USART2_BASE }
N/** Array initializer of USART peripheral base pointers */
N#define USART_BASE_PTRS                          { USART0, USART1, USART2 }
N/** Interrupt vectors for the USART peripheral type */
N#define USART_IRQS                               { USART0_IRQn, USART1_IRQn, USART2_IRQn }
N
N/*!
N * @}
N */ /* end of group USART_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- WKT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup WKT_Peripheral_Access_Layer WKT Peripheral Access Layer
N * @{
N */
N
N/** WKT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CTRL;                              /**< Self wake-up timer control register., offset: 0x0 */
X  volatile uint32_t CTRL;                               
N       uint8_t RESERVED_0[8];
N  __IO uint32_t COUNT;                             /**< Counter register., offset: 0xC */
X  volatile uint32_t COUNT;                              
N} WKT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- WKT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup WKT_Register_Masks WKT Register Masks
N * @{
N */
N
N/*! @name CTRL - Self wake-up timer control register. */
N/*! @{ */
N#define WKT_CTRL_CLKSEL_MASK                     (0x1U)
N#define WKT_CTRL_CLKSEL_SHIFT                    (0U)
N#define WKT_CTRL_CLKSEL(x)                       (((uint32_t)(((uint32_t)(x)) << WKT_CTRL_CLKSEL_SHIFT)) & WKT_CTRL_CLKSEL_MASK)
N#define WKT_CTRL_ALARMFLAG_MASK                  (0x2U)
N#define WKT_CTRL_ALARMFLAG_SHIFT                 (1U)
N#define WKT_CTRL_ALARMFLAG(x)                    (((uint32_t)(((uint32_t)(x)) << WKT_CTRL_ALARMFLAG_SHIFT)) & WKT_CTRL_ALARMFLAG_MASK)
N#define WKT_CTRL_CLEARCTR_MASK                   (0x4U)
N#define WKT_CTRL_CLEARCTR_SHIFT                  (2U)
N#define WKT_CTRL_CLEARCTR(x)                     (((uint32_t)(((uint32_t)(x)) << WKT_CTRL_CLEARCTR_SHIFT)) & WKT_CTRL_CLEARCTR_MASK)
N#define WKT_CTRL_SEL_EXTCLK_MASK                 (0x8U)
N#define WKT_CTRL_SEL_EXTCLK_SHIFT                (3U)
N#define WKT_CTRL_SEL_EXTCLK(x)                   (((uint32_t)(((uint32_t)(x)) << WKT_CTRL_SEL_EXTCLK_SHIFT)) & WKT_CTRL_SEL_EXTCLK_MASK)
N/*! @} */
N
N/*! @name COUNT - Counter register. */
N/*! @{ */
N#define WKT_COUNT_VALUE_MASK                     (0xFFFFFFFFU)
N#define WKT_COUNT_VALUE_SHIFT                    (0U)
N#define WKT_COUNT_VALUE(x)                       (((uint32_t)(((uint32_t)(x)) << WKT_COUNT_VALUE_SHIFT)) & WKT_COUNT_VALUE_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group WKT_Register_Masks */
N
N
N/* WKT - Peripheral instance base addresses */
N/** Peripheral WKT base address */
N#define WKT_BASE                                 (0x40008000u)
N/** Peripheral WKT base pointer */
N#define WKT                                      ((WKT_Type *)WKT_BASE)
N/** Array initializer of WKT peripheral base addresses */
N#define WKT_BASE_ADDRS                           { WKT_BASE }
N/** Array initializer of WKT peripheral base pointers */
N#define WKT_BASE_PTRS                            { WKT }
N/** Interrupt vectors for the WKT peripheral type */
N#define WKT_IRQS                                 { WKT_IRQn }
N
N/*!
N * @}
N */ /* end of group WKT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- WWDT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup WWDT_Peripheral_Access_Layer WWDT Peripheral Access Layer
N * @{
N */
N
N/** WWDT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t MOD;                               /**< Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer., offset: 0x0 */
X  volatile uint32_t MOD;                                
N  __IO uint32_t TC;                                /**< Watchdog timer constant register. This 24-bit register determines the time-out value., offset: 0x4 */
X  volatile uint32_t TC;                                 
N  __O  uint32_t FEED;                              /**< Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in TC., offset: 0x8 */
X  volatile  uint32_t FEED;                               
N  __I  uint32_t TV;                                /**< Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer., offset: 0xC */
X  volatile const  uint32_t TV;                                 
N       uint8_t RESERVED_0[4];
N  __IO uint32_t WARNINT;                           /**< Watchdog Warning Interrupt compare value., offset: 0x14 */
X  volatile uint32_t WARNINT;                            
N  __IO uint32_t WINDOW;                            /**< Watchdog Window compare value., offset: 0x18 */
X  volatile uint32_t WINDOW;                             
N} WWDT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- WWDT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup WWDT_Register_Masks WWDT Register Masks
N * @{
N */
N
N/*! @name MOD - Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer. */
N/*! @{ */
N#define WWDT_MOD_WDEN_MASK                       (0x1U)
N#define WWDT_MOD_WDEN_SHIFT                      (0U)
N#define WWDT_MOD_WDEN(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDEN_SHIFT)) & WWDT_MOD_WDEN_MASK)
N#define WWDT_MOD_WDRESET_MASK                    (0x2U)
N#define WWDT_MOD_WDRESET_SHIFT                   (1U)
N#define WWDT_MOD_WDRESET(x)                      (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDRESET_SHIFT)) & WWDT_MOD_WDRESET_MASK)
N#define WWDT_MOD_WDTOF_MASK                      (0x4U)
N#define WWDT_MOD_WDTOF_SHIFT                     (2U)
N#define WWDT_MOD_WDTOF(x)                        (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDTOF_SHIFT)) & WWDT_MOD_WDTOF_MASK)
N#define WWDT_MOD_WDINT_MASK                      (0x8U)
N#define WWDT_MOD_WDINT_SHIFT                     (3U)
N#define WWDT_MOD_WDINT(x)                        (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDINT_SHIFT)) & WWDT_MOD_WDINT_MASK)
N#define WWDT_MOD_WDPROTECT_MASK                  (0x10U)
N#define WWDT_MOD_WDPROTECT_SHIFT                 (4U)
N#define WWDT_MOD_WDPROTECT(x)                    (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_WDPROTECT_SHIFT)) & WWDT_MOD_WDPROTECT_MASK)
N#define WWDT_MOD_LOCK_MASK                       (0x20U)
N#define WWDT_MOD_LOCK_SHIFT                      (5U)
N#define WWDT_MOD_LOCK(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_MOD_LOCK_SHIFT)) & WWDT_MOD_LOCK_MASK)
N/*! @} */
N
N/*! @name TC - Watchdog timer constant register. This 24-bit register determines the time-out value. */
N/*! @{ */
N#define WWDT_TC_COUNT_MASK                       (0xFFFFFFU)
N#define WWDT_TC_COUNT_SHIFT                      (0U)
N#define WWDT_TC_COUNT(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_TC_COUNT_SHIFT)) & WWDT_TC_COUNT_MASK)
N/*! @} */
N
N/*! @name FEED - Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in TC. */
N/*! @{ */
N#define WWDT_FEED_FEED_MASK                      (0xFFU)
N#define WWDT_FEED_FEED_SHIFT                     (0U)
N#define WWDT_FEED_FEED(x)                        (((uint32_t)(((uint32_t)(x)) << WWDT_FEED_FEED_SHIFT)) & WWDT_FEED_FEED_MASK)
N/*! @} */
N
N/*! @name TV - Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer. */
N/*! @{ */
N#define WWDT_TV_COUNT_MASK                       (0xFFFFFFU)
N#define WWDT_TV_COUNT_SHIFT                      (0U)
N#define WWDT_TV_COUNT(x)                         (((uint32_t)(((uint32_t)(x)) << WWDT_TV_COUNT_SHIFT)) & WWDT_TV_COUNT_MASK)
N/*! @} */
N
N/*! @name WARNINT - Watchdog Warning Interrupt compare value. */
N/*! @{ */
N#define WWDT_WARNINT_WARNINT_MASK                (0x3FFU)
N#define WWDT_WARNINT_WARNINT_SHIFT               (0U)
N#define WWDT_WARNINT_WARNINT(x)                  (((uint32_t)(((uint32_t)(x)) << WWDT_WARNINT_WARNINT_SHIFT)) & WWDT_WARNINT_WARNINT_MASK)
N/*! @} */
N
N/*! @name WINDOW - Watchdog Window compare value. */
N/*! @{ */
N#define WWDT_WINDOW_WINDOW_MASK                  (0xFFFFFFU)
N#define WWDT_WINDOW_WINDOW_SHIFT                 (0U)
N#define WWDT_WINDOW_WINDOW(x)                    (((uint32_t)(((uint32_t)(x)) << WWDT_WINDOW_WINDOW_SHIFT)) & WWDT_WINDOW_WINDOW_MASK)
N/*! @} */
N
N
N/*!
N * @}
N */ /* end of group WWDT_Register_Masks */
N
N
N/* WWDT - Peripheral instance base addresses */
N/** Peripheral WWDT base address */
N#define WWDT_BASE                                (0x40000000u)
N/** Peripheral WWDT base pointer */
N#define WWDT                                     ((WWDT_Type *)WWDT_BASE)
N/** Array initializer of WWDT peripheral base addresses */
N#define WWDT_BASE_ADDRS                          { WWDT_BASE }
N/** Array initializer of WWDT peripheral base pointers */
N#define WWDT_BASE_PTRS                           { WWDT }
N
N/*!
N * @}
N */ /* end of group WWDT_Peripheral_Access_Layer */
N
N
N/*
N** End of section using anonymous unions
N*/
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #if (__ARMCC_VERSION >= 6010050)
X  #if (5060300 >= 6010050)
S    #pragma clang diagnostic pop
N  #else
N    #pragma pop
N  #endif
N#elif defined(__GNUC__)
S  /* leave anonymous unions enabled */
S#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma language=default
S#else
S  #error Not supported compiler type
N#endif
N
N/*!
N * @}
N */ /* end of group Peripheral_access_layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- Macros for use with bit field definitions (xxx_SHIFT, xxx_MASK).
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup Bit_Field_Generic_Macros Macros for use with bit field definitions (xxx_SHIFT, xxx_MASK).
N * @{
N */
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #if (__ARMCC_VERSION >= 6010050)
X  #if (5060300 >= 6010050)
S    #pragma clang system_header
N  #endif
N#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma system_include
N#endif
N
N/**
N * @brief Mask and left-shift a bit field value for use in a register bit range.
N * @param field Name of the register bit field.
N * @param value Value of the bit field.
N * @return Masked and shifted value.
N */
N#define NXP_VAL2FLD(field, value)    (((value) << (field ## _SHIFT)) & (field ## _MASK))
N/**
N * @brief Mask and right-shift a register value to extract a bit field value.
N * @param field Name of the register bit field.
N * @param value Value of the register.
N * @return Masked and shifted bit field value.
N */
N#define NXP_FLD2VAL(field, value)    (((value) & (field ## _MASK)) >> (field ## _SHIFT))
N
N/*!
N * @}
N */ /* end of group Bit_Field_Generic_Macros */
N
N
N/* ----------------------------------------------------------------------------
N   -- SDK Compatibility
N   ---------------------------------------------------------------------------- */
N
N/*!
N * @addtogroup SDK_Compatibility_Symbols SDK Compatibility
N * @{
N */
N
N/* No SDK compatibility issues. */
N
N/*!
N * @}
N */ /* end of group SDK_Compatibility_Symbols */
N
N
N#endif  /* _LPC824_H_ */
N
L 79 "lpc_chip_82x\system_LPC824.c" 2
N
N/* get system pll input freq */
Nstatic uint32_t CLOCK_GetSystemPLLInClkRate(void)
N{
N    uint32_t freq = 0U;
N
N    switch ((SYSCON->SYSPLLCLKSEL & SYSCON_SYSPLLCLKSEL_SEL_MASK))
X    switch ((((SYSCON_Type *)(0x40048000u))->SYSPLLCLKSEL & (0x3U)))
N    {
N        /* source from external clock in */
N        case 0x00U:
N            freq = CLK_IRC_12MHZ;
X            freq = 12000000u;
N            break;
N        /* source from the IRC clock */
N        case 0x01U:
N            freq = CLK_OSC_IN;
X            freq = 12000000u;
N            break;
N        /* source from external clock clock */
N        case 0x03U:
N            freq = EXT_CLK_IN;
X            freq = 0u;
N            break;
N
N        default:
N            break;
N    }
N
N    return freq;
N}
N
N/* get system pll output freq*/
Nstatic uint32_t Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
N{
N    uint32_t m_val = ((PLLReg & 0x1F) + 1);
N
N    return (inputRate * m_val);
N}
N
N
N
N/* ----------------------------------------------------------------------------
N   -- Core clock
N   ---------------------------------------------------------------------------- */
N
Nuint32_t SystemCoreClock = DEFAULT_SYSTEM_CLOCK;
Xuint32_t SystemCoreClock = 12000000u;
N
N/* ----------------------------------------------------------------------------
N   -- SystemInit()
N   ---------------------------------------------------------------------------- */
N
Nvoid SystemInit (void) {
N
N#if defined(__MCUXPRESSO)
X#if 0L
S    extern void(*const g_pfnVectors[]) (void);
S    SCB->VTOR = (uint32_t) &g_pfnVectors;
N#else
N    extern void *__Vectors;
N    SCB->VTOR = (uint32_t) &__Vectors;
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR = (uint32_t) &__Vectors;
N#endif
N    SystemCoreClock = DEFAULT_SYSTEM_CLOCK;
X    SystemCoreClock = 12000000u;
N}
N
N
N
N/* ----------------------------------------------------------------------------
N   -- SystemCoreClockUpdate()
N   ---------------------------------------------------------------------------- */
Nvoid SystemCoreClockUpdate (void) {
N  uint32_t wdt_osc = 0U;
N  uint32_t irc_clk = 12000000U;
N
N  switch ((SYSCON->WDTOSCCTRL >> 5) & 0x0F) {
X  switch ((((SYSCON_Type *)(0x40048000u))->WDTOSCCTRL >> 5) & 0x0F) {
N    case 0:  wdt_osc =       0; break;
N    case 1:  wdt_osc =  600000; break;
N    case 2:  wdt_osc = 1050000; break;
N    case 3:  wdt_osc = 1400000; break;
N    case 4:  wdt_osc = 1750000; break;
N    case 5:  wdt_osc = 2100000; break;
N    case 6:  wdt_osc = 2400000; break;
N    case 7:  wdt_osc = 2700000; break;
N    case 8:  wdt_osc = 3000000; break;
N    case 9:  wdt_osc = 3250000; break;
N    case 10: wdt_osc = 3500000; break;
N    case 11: wdt_osc = 3750000; break;
N    case 12: wdt_osc = 4000000; break;
N    case 13: wdt_osc = 4200000; break;
N    case 14: wdt_osc = 4400000; break;
N    case 15: wdt_osc = 4600000; break;
N  }
N  wdt_osc /= (((SYSCON->WDTOSCCTRL & 0x1F) + 1) << 1);
X  wdt_osc /= (((((SYSCON_Type *)(0x40048000u))->WDTOSCCTRL & 0x1F) + 1) << 1);
N
N  switch (SYSCON->MAINCLKSEL & SYSCON_MAINCLKSEL_SEL_MASK)
X  switch (((SYSCON_Type *)(0x40048000u))->MAINCLKSEL & (0x3U))
N  {
N    case 0U:                                              /* IRC  */
N      SystemCoreClock = irc_clk;
N      break;
N      case 1U:                                            /* System PLL input */
N        switch (SYSCON->SYSPLLCLKSEL & 0x03) {
X        switch (((SYSCON_Type *)(0x40048000u))->SYSPLLCLKSEL & 0x03) {
N          case 0:                                         /* IRC */
N            SystemCoreClock = irc_clk;
N            break;
N          case 1:                                         /* System oscillator */
N            SystemCoreClock = CLK_OSC_IN;
X            SystemCoreClock = 12000000u;
N            break;
N          case 3:                                         /* CLKIN */
N            SystemCoreClock = EXT_CLK_IN;
X            SystemCoreClock = 0u;
N            break;
N          default:
N            break;
N        }
N      break;
N    case 2U:                                              /* watchdog oscillator */
N      SystemCoreClock = wdt_osc;
N      break;
N    case 3U:                                              /* System PLL  */
N      SystemCoreClock = Clock_GetPLLFreq((SYSCON->SYSPLLCTRL & SYSCON_SYSPLLCTRL_MSEL_MASK), CLOCK_GetSystemPLLInClkRate());
X      SystemCoreClock = Clock_GetPLLFreq((((SYSCON_Type *)(0x40048000u))->SYSPLLCTRL & (0x1FU)), CLOCK_GetSystemPLLInClkRate());
N      break;
N    default:
N      break;
N  }
N
N  SystemCoreClock /= SYSCON->SYSAHBCLKDIV;
X  SystemCoreClock /= ((SYSCON_Type *)(0x40048000u))->SYSAHBCLKDIV;
N}
