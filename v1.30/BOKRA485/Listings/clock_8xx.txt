; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\clock_8xx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\clock_8xx.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\clock_8xx.crf lpc_chip_82x\src\clock_8xx.c]
                          THUMB

                          AREA ||i.Chip_Clock_GetIOCONCLKDIVClockRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetIOCONCLKDIVClockRate PROC
;;;280    /* Get the IOCONCLKDIV clock rate */
;;;281    uint32_t Chip_Clock_GetIOCONCLKDIVClockRate(CHIP_PIN_CLKDIV_T reg)
000000  b570              PUSH     {r4-r6,lr}
;;;282    {
000002  4604              MOV      r4,r0
;;;283    	uint32_t div = LPC_SYSCTL->IOCONCLKDIV[reg] & ~SYSCTL_IOCONCLKDIV_RESERVED;
000004  00a0              LSLS     r0,r4,#2
000006  4908              LDR      r1,|L1.40|
000008  1840              ADDS     r0,r0,r1
00000a  6b40              LDR      r0,[r0,#0x34]
00000c  b2c5              UXTB     r5,r0
;;;284    	uint32_t main_clk = Chip_Clock_GetMainClockRate();
00000e  f7fffffe          BL       Chip_Clock_GetMainClockRate
000012  4606              MOV      r6,r0
;;;285    	
;;;286    	return (div == 0) ? 0 : (main_clk / div);
000014  2d00              CMP      r5,#0
000016  d101              BNE      |L1.28|
000018  2000              MOVS     r0,#0
                  |L1.26|
;;;287    }
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  4629              MOV      r1,r5                 ;286
00001e  4630              MOV      r0,r6                 ;286
000020  f7fffffe          BL       __aeabi_uidivmod
000024  e7f9              B        |L1.26|
;;;288    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40048100

                          AREA ||i.Chip_Clock_GetMainClockRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetMainClockRate PROC
;;;176    /* Return main clock rate */
;;;177    uint32_t Chip_Clock_GetMainClockRate(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179    	uint32_t clkRate = 0;
000002  2400              MOVS     r4,#0
;;;180    
;;;181    	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
000004  480f              LDR      r0,|L2.68|
000006  6b00              LDR      r0,[r0,#0x30]
000008  0780              LSLS     r0,r0,#30
00000a  0f80              LSRS     r0,r0,#30
00000c  2800              CMP      r0,#0
00000e  d006              BEQ      |L2.30|
000010  2801              CMP      r0,#1
000012  d008              BEQ      |L2.38|
000014  2802              CMP      r0,#2
000016  d00a              BEQ      |L2.46|
000018  2803              CMP      r0,#3
00001a  d110              BNE      |L2.62|
00001c  e00b              B        |L2.54|
                  |L2.30|
;;;182    	case SYSCTL_MAINCLKSRC_IRC:
;;;183    		clkRate = Chip_Clock_GetIntOscRate();
00001e  bf00              NOP      
000020  4809              LDR      r0,|L2.72|
000022  4604              MOV      r4,r0
;;;184    		break;
000024  e00b              B        |L2.62|
                  |L2.38|
;;;185    
;;;186    	case SYSCTL_MAINCLKSRC_PLLIN:
;;;187    		clkRate = Chip_Clock_GetSystemPLLInClockRate();
000026  f7fffffe          BL       Chip_Clock_GetSystemPLLInClockRate
00002a  4604              MOV      r4,r0
;;;188    		break;
00002c  e007              B        |L2.62|
                  |L2.46|
;;;189    
;;;190    	case SYSCTL_MAINCLKSRC_WDTOSC:
;;;191    		clkRate = Chip_Clock_GetWDTOSCRate();
00002e  f7fffffe          BL       Chip_Clock_GetWDTOSCRate
000032  4604              MOV      r4,r0
;;;192    		break;
000034  e003              B        |L2.62|
                  |L2.54|
;;;193    
;;;194    	case SYSCTL_MAINCLKSRC_PLLOUT:
;;;195    		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
000036  f7fffffe          BL       Chip_Clock_GetSystemPLLOutClockRate
00003a  4604              MOV      r4,r0
;;;196    		break;
00003c  bf00              NOP      
                  |L2.62|
00003e  bf00              NOP                            ;184
;;;197    	}
;;;198    
;;;199    	return clkRate;
000040  4620              MOV      r0,r4
;;;200    }
000042  bd10              POP      {r4,pc}
;;;201    
                          ENDP

                  |L2.68|
                          DCD      0x40048040
                  |L2.72|
                          DCD      0x00b71b00

                          AREA ||i.Chip_Clock_GetPLLFreq||, CODE, READONLY, ALIGN=1

                  Chip_Clock_GetPLLFreq PROC
;;;80     /* Compute PLL frequency */
;;;81     static uint32_t Chip_Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
000000  4602              MOV      r2,r0
;;;82     {
;;;83     	uint32_t m_val = ((PLLReg & 0x1F) + 1);
000002  06d0              LSLS     r0,r2,#27
000004  0ec0              LSRS     r0,r0,#27
000006  1c43              ADDS     r3,r0,#1
;;;84     
;;;85     	return (inputRate * m_val);
000008  4608              MOV      r0,r1
00000a  4358              MULS     r0,r3,r0
;;;86     }
00000c  4770              BX       lr
;;;87     
                          ENDP


                          AREA ||i.Chip_Clock_GetSystemClockRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetSystemClockRate PROC
;;;202    /* Return system clock rate */
;;;203    uint32_t Chip_Clock_GetSystemClockRate(void)
000000  b510              PUSH     {r4,lr}
;;;204    {
;;;205    	/* No point in checking for divide by 0 */
;;;206    	return Chip_Clock_GetMainClockRate() / (LPC_SYSCTL->SYSAHBCLKDIV & ~SYSCTL_SYSAHBCLKDIV_RESERVED);
000002  f7fffffe          BL       Chip_Clock_GetMainClockRate
000006  4604              MOV      r4,r0
000008  4803              LDR      r0,|L4.24|
00000a  6b80              LDR      r0,[r0,#0x38]
00000c  b2c1              UXTB     r1,r0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       __aeabi_uidivmod
;;;207    }
000014  bd10              POP      {r4,pc}
;;;208    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x40048040

                          AREA ||i.Chip_Clock_GetSystemPLLInClockRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetSystemPLLInClockRate PROC
;;;144    /* Return System PLL input clock rate */
;;;145    uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
000000  490e              LDR      r1,|L5.60|
;;;146    {
;;;147    	uint32_t clkRate;
;;;148    
;;;149    	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
000002  6809              LDR      r1,[r1,#0]
000004  0789              LSLS     r1,r1,#30
000006  0f89              LSRS     r1,r1,#30
000008  2900              CMP      r1,#0
00000a  d004              BEQ      |L5.22|
00000c  2901              CMP      r1,#1
00000e  d006              BEQ      |L5.30|
000010  2903              CMP      r1,#3
000012  d10e              BNE      |L5.50|
000014  e008              B        |L5.40|
                  |L5.22|
;;;150    	case SYSCTL_PLLCLKSRC_IRC:
;;;151    		clkRate = Chip_Clock_GetIntOscRate();
000016  bf00              NOP      
000018  4809              LDR      r0,|L5.64|
00001a  bf00              NOP      
;;;152    		break;
00001c  e00b              B        |L5.54|
                  |L5.30|
;;;153    
;;;154    	case SYSCTL_PLLCLKSRC_SYSOSC:
;;;155    		clkRate = Chip_Clock_GetMainOscRate();
00001e  bf00              NOP      
000020  4908              LDR      r1,|L5.68|
000022  6808              LDR      r0,[r1,#0]  ; OscRateIn
000024  bf00              NOP      
;;;156    		break;
000026  e006              B        |L5.54|
                  |L5.40|
;;;157    
;;;158    	case SYSCTL_PLLCLKSRC_EXT_CLKIN:
;;;159    		clkRate = Chip_Clock_GetExtClockInRate();
000028  bf00              NOP      
00002a  4907              LDR      r1,|L5.72|
00002c  6808              LDR      r0,[r1,#0]  ; ExtRateIn
00002e  bf00              NOP      
;;;160    		break;
000030  e001              B        |L5.54|
                  |L5.50|
;;;161    
;;;162    	default:
;;;163    		clkRate = 0;
000032  2000              MOVS     r0,#0
000034  bf00              NOP                            ;149
                  |L5.54|
000036  bf00              NOP                            ;152
;;;164    	}
;;;165    
;;;166    	return clkRate;
;;;167    }
000038  4770              BX       lr
;;;168    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      0x40048040
                  |L5.64|
                          DCD      0x00b71b00
                  |L5.68|
                          DCD      OscRateIn
                  |L5.72|
                          DCD      ExtRateIn

                          AREA ||i.Chip_Clock_GetSystemPLLOutClockRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetSystemPLLOutClockRate PROC
;;;169    /* Return System PLL output clock rate */
;;;170    uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
000000  b510              PUSH     {r4,lr}
;;;171    {
;;;172    	return Chip_Clock_GetPLLFreq((LPC_SYSCTL->SYSPLLCTRL & ~SYSCTL_SYSPLLCTRL_RESERVED),
000002  f7fffffe          BL       Chip_Clock_GetSystemPLLInClockRate
000006  4604              MOV      r4,r0
000008  4903              LDR      r1,|L6.24|
00000a  6889              LDR      r1,[r1,#8]
00000c  0648              LSLS     r0,r1,#25
00000e  0e40              LSRS     r0,r0,#25
000010  4621              MOV      r1,r4
000012  f7fffffe          BL       Chip_Clock_GetPLLFreq
;;;173    								 Chip_Clock_GetSystemPLLInClockRate());
;;;174    }
000016  bd10              POP      {r4,pc}
;;;175    
                          ENDP

                  |L6.24|
                          DCD      0x40048000

                          AREA ||i.Chip_Clock_GetUSARTNBaseClockRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetUSARTNBaseClockRate PROC
;;;209    /* Get USART 0/1/2 UART base rate */
;;;210    uint32_t Chip_Clock_GetUSARTNBaseClockRate(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;211    {
000002  b089              SUB      sp,sp,#0x24
;;;212    	uint64_t inclk;
;;;213    	uint32_t div;
;;;214    
;;;215    	div = (uint32_t) Chip_Clock_GetUARTClockDiv();
000004  bf00              NOP      
000006  481e              LDR      r0,|L7.128|
000008  6940              LDR      r0,[r0,#0x14]
00000a  b2c0              UXTB     r0,r0
00000c  9005              STR      r0,[sp,#0x14]
;;;216    	if (div == 0) {
00000e  9805              LDR      r0,[sp,#0x14]
000010  2800              CMP      r0,#0
000012  d101              BNE      |L7.24|
;;;217    		/* Divider is 0 so UART clock is disabled */
;;;218    		inclk = 0;
000014  2400              MOVS     r4,#0
000016  e02f              B        |L7.120|
                  |L7.24|
;;;219    	}
;;;220    	else {
;;;221    		uint32_t mult, divf;
;;;222    
;;;223    		/* Input clock into FRG block is the divided main system clock */
;;;224    		inclk = (uint64_t) (Chip_Clock_GetMainClockRate() / div);
000018  f7fffffe          BL       Chip_Clock_GetMainClockRate
00001c  9002              STR      r0,[sp,#8]
00001e  9905              LDR      r1,[sp,#0x14]
000020  f7fffffe          BL       __aeabi_uidivmod
000024  2500              MOVS     r5,#0
000026  4604              MOV      r4,r0
;;;225    
;;;226    		divf = Chip_SYSCTL_GetUSARTFRGDivider();
000028  bf00              NOP      
00002a  4815              LDR      r0,|L7.128|
00002c  3040              ADDS     r0,r0,#0x40
00002e  6b00              LDR      r0,[r0,#0x30]
000030  b2c0              UXTB     r0,r0
000032  9003              STR      r0,[sp,#0xc]
;;;227    		if (divf == 0xFF) {
000034  9803              LDR      r0,[sp,#0xc]
000036  28ff              CMP      r0,#0xff
000038  d11d              BNE      |L7.118|
;;;228    			/* Fractional part is enabled, get multiplier */
;;;229    			mult = (uint32_t) Chip_SYSCTL_GetUSARTFRGMultiplier();
00003a  bf00              NOP      
00003c  4810              LDR      r0,|L7.128|
00003e  3040              ADDS     r0,r0,#0x40
000040  6b40              LDR      r0,[r0,#0x34]
000042  b2c0              UXTB     r0,r0
000044  9004              STR      r0,[sp,#0x10]
;;;230    
;;;231    			/* Get fractional error */
;;;232    			inclk = (inclk * 256) / (uint64_t) (256 + mult);
000046  9804              LDR      r0,[sp,#0x10]
000048  30ff              ADDS     r0,r0,#0xff
00004a  3001              ADDS     r0,#1
00004c  21ff              MOVS     r1,#0xff
00004e  3101              ADDS     r1,#1
000050  9002              STR      r0,[sp,#8]
000052  2000              MOVS     r0,#0
000054  4626              MOV      r6,r4
000056  462f              MOV      r7,r5
000058  9107              STR      r1,[sp,#0x1c]
00005a  9006              STR      r0,[sp,#0x18]
00005c  4630              MOV      r0,r6
00005e  4639              MOV      r1,r7
000060  9b06              LDR      r3,[sp,#0x18]
000062  9a07              LDR      r2,[sp,#0x1c]
000064  f7fffffe          BL       __aeabi_lmul
000068  9101              STR      r1,[sp,#4]
00006a  9000              STR      r0,[sp,#0]
00006c  2300              MOVS     r3,#0
00006e  9a02              LDR      r2,[sp,#8]
000070  f7fffffe          BL       __aeabi_uldivmod
000074  4604              MOV      r4,r0
                  |L7.118|
;;;233    		}
;;;234    	}
000076  bf00              NOP      
                  |L7.120|
;;;235    
;;;236    	return (uint32_t) inclk;
000078  4620              MOV      r0,r4
;;;237    }
00007a  b009              ADD      sp,sp,#0x24
00007c  bdf0              POP      {r4-r7,pc}
;;;238    
                          ENDP

00007e  0000              DCW      0x0000
                  |L7.128|
                          DCD      0x40048080

                          AREA ||i.Chip_Clock_GetWDTLFORate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetWDTLFORate PROC
;;;66     /* Compute a WDT or LFO rate */
;;;67     static uint32_t Chip_Clock_GetWDTLFORate(uint32_t reg)
000000  b570              PUSH     {r4-r6,lr}
;;;68     {
000002  4604              MOV      r4,r0
;;;69     	uint32_t div;
;;;70     	CHIP_WDTLFO_OSC_T clk;
;;;71     
;;;72     	/* Get WDT oscillator settings */
;;;73     	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
000004  05e0              LSLS     r0,r4,#23
000006  0f06              LSRS     r6,r0,#28
;;;74     	div = reg & 0x1F;
000008  06e5              LSLS     r5,r4,#27
00000a  0eed              LSRS     r5,r5,#27
;;;75     
;;;76     	/* Compute clock rate and divided by divde value */
;;;77     	return wdtOSCRate[clk] / ((div + 1) << 1);
00000c  1c6a              ADDS     r2,r5,#1
00000e  0051              LSLS     r1,r2,#1
000010  00b2              LSLS     r2,r6,#2
000012  4b02              LDR      r3,|L8.28|
000014  5898              LDR      r0,[r3,r2]
000016  f7fffffe          BL       __aeabi_uidivmod
;;;78     }
00001a  bd70              POP      {r4-r6,pc}
;;;79     
                          ENDP

                  |L8.28|
                          DCD      wdtOSCRate

                          AREA ||i.Chip_Clock_GetWDTOSCRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_GetWDTOSCRate PROC
;;;138    /* Return estimated watchdog oscillator rate */
;;;139    uint32_t Chip_Clock_GetWDTOSCRate(void)
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141    	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL & ~SYSCTL_WDTOSCCTRL_RESERVED);
000002  4903              LDR      r1,|L9.16|
000004  6a49              LDR      r1,[r1,#0x24]
000006  05c8              LSLS     r0,r1,#23
000008  0dc0              LSRS     r0,r0,#23
00000a  f7fffffe          BL       Chip_Clock_GetWDTLFORate
;;;142    }
00000e  bd10              POP      {r4,pc}
;;;143    
                          ENDP

                  |L9.16|
                          DCD      0x40048000

                          AREA ||i.Chip_Clock_SetCLKOUTSource||, CODE, READONLY, ALIGN=2

                  Chip_Clock_SetCLKOUTSource PROC
;;;127    /* Set CLKOUT clock source and divider */
;;;128    void Chip_Clock_SetCLKOUTSource(CHIP_SYSCTL_CLKOUTSRC_T src, uint32_t div)
000000  4a04              LDR      r2,|L10.20|
;;;129    {
;;;130    	LPC_SYSCTL->CLKOUTSEL = (uint32_t) src;
000002  6210              STR      r0,[r2,#0x20]
;;;131        
;;;132        /* sequnce a 0 followed by 1 to update CLKOUT source selection */
;;;133    	LPC_SYSCTL->CLKOUTUEN = 0;
000004  2200              MOVS     r2,#0
000006  4b03              LDR      r3,|L10.20|
000008  625a              STR      r2,[r3,#0x24]
;;;134    	LPC_SYSCTL->CLKOUTUEN = 1;
00000a  2201              MOVS     r2,#1
00000c  625a              STR      r2,[r3,#0x24]
;;;135    	LPC_SYSCTL->CLKOUTDIV = div;
00000e  461a              MOV      r2,r3
000010  6291              STR      r1,[r2,#0x28]
;;;136    }
000012  4770              BX       lr
;;;137    
                          ENDP

                  |L10.20|
                          DCD      0x400480c0

                          AREA ||i.Chip_Clock_SetIOCONCLKDIV||, CODE, READONLY, ALIGN=2

                  Chip_Clock_SetIOCONCLKDIV PROC
;;;288    
;;;289    void Chip_Clock_SetIOCONCLKDIV(CHIP_PIN_CLKDIV_T reg, uint8_t div)
000000  b510              PUSH     {r4,lr}
;;;290    {
;;;291    	int t_reg = IOCONCLK_MAX-reg;
000002  2306              MOVS     r3,#6
000004  1a1a              SUBS     r2,r3,r0
;;;292    	LPC_SYSCTL->IOCONCLKDIV[t_reg] = div;
000006  4b02              LDR      r3,|L11.16|
000008  0094              LSLS     r4,r2,#2
00000a  5119              STR      r1,[r3,r4]
;;;293    }
00000c  bd10              POP      {r4,pc}
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      0x40048134

                          AREA ||i.Chip_Clock_SetMainClockSource||, CODE, READONLY, ALIGN=2

                  Chip_Clock_SetMainClockSource PROC
;;;117    /* Set main system clock source */
;;;118    void Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src)
000000  4903              LDR      r1,|L12.16|
;;;119    {
;;;120    	LPC_SYSCTL->MAINCLKSEL  = (uint32_t) src;
000002  6308              STR      r0,[r1,#0x30]
;;;121        
;;;122        /* sequnce a 0 followed by 1 to update MAINCLK source selection */
;;;123    	LPC_SYSCTL->MAINCLKUEN  = 0;
000004  2100              MOVS     r1,#0
000006  4a02              LDR      r2,|L12.16|
000008  6351              STR      r1,[r2,#0x34]
;;;124    	LPC_SYSCTL->MAINCLKUEN  = 1;
00000a  2101              MOVS     r1,#1
00000c  6351              STR      r1,[r2,#0x34]
;;;125    }
00000e  4770              BX       lr
;;;126    
                          ENDP

                  |L12.16|
                          DCD      0x40048040

                          AREA ||i.Chip_Clock_SetPLLBypass||, CODE, READONLY, ALIGN=2

                  Chip_Clock_SetPLLBypass PROC
;;;102    /* Bypass System Oscillator and set oscillator frequency range */
;;;103    void Chip_Clock_SetPLLBypass(bool bypass, bool highfr)
000000  4602              MOV      r2,r0
;;;104    {
;;;105    	uint32_t ctrl = 0;
000002  2000              MOVS     r0,#0
;;;106    
;;;107    	if (bypass) {
000004  2a00              CMP      r2,#0
000006  d001              BEQ      |L13.12|
;;;108    		ctrl |= (1 << 0);
000008  2301              MOVS     r3,#1
00000a  4318              ORRS     r0,r0,r3
                  |L13.12|
;;;109    	}
;;;110    	if (highfr) {
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L13.20|
;;;111    		ctrl |= (1 << 1);
000010  2302              MOVS     r3,#2
000012  4318              ORRS     r0,r0,r3
                  |L13.20|
;;;112    	}
;;;113    
;;;114    	LPC_SYSCTL->SYSOSCCTRL = ctrl;
000014  4b01              LDR      r3,|L13.28|
000016  6218              STR      r0,[r3,#0x20]
;;;115    }
000018  4770              BX       lr
;;;116    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40048000

                          AREA ||i.Chip_Clock_SetSystemPLLSource||, CODE, READONLY, ALIGN=2

                  Chip_Clock_SetSystemPLLSource PROC
;;;92     /* Set System PLL clock source */
;;;93     void Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src)
000000  4903              LDR      r1,|L14.16|
;;;94     {
;;;95     	LPC_SYSCTL->SYSPLLCLKSEL  = (uint32_t) src;
000002  6008              STR      r0,[r1,#0]
;;;96         
;;;97         /* sequnce a 0 followed by 1 to update PLL source selection */
;;;98     	LPC_SYSCTL->SYSPLLCLKUEN  = 0;  
000004  2100              MOVS     r1,#0
000006  4a02              LDR      r2,|L14.16|
000008  6051              STR      r1,[r2,#4]
;;;99     	LPC_SYSCTL->SYSPLLCLKUEN  = 1;  
00000a  2101              MOVS     r1,#1
00000c  6051              STR      r1,[r2,#4]
;;;100    }
00000e  4770              BX       lr
;;;101    
                          ENDP

                  |L14.16|
                          DCD      0x40048040

                          AREA ||i.Chip_Clock_SetUSARTNBaseClockRate||, CODE, READONLY, ALIGN=2

                  Chip_Clock_SetUSARTNBaseClockRate PROC
;;;239    /* Set USART 0/1/2 UART base rate */
;;;240    uint32_t Chip_Clock_SetUSARTNBaseClockRate(uint32_t rate, bool fEnable)
000000  b5fe              PUSH     {r1-r7,lr}
;;;241    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;242    	uint32_t div, inclk;
;;;243    
;;;244    	/* Input clock into FRG block is the main system clock */
;;;245    	inclk = Chip_Clock_GetMainClockRate();
000006  f7fffffe          BL       Chip_Clock_GetMainClockRate
00000a  9001              STR      r0,[sp,#4]
;;;246    
;;;247    	/* Get integer divider for coarse rate */
;;;248    	div = inclk / rate;
00000c  4629              MOV      r1,r5
00000e  9801              LDR      r0,[sp,#4]
000010  f7fffffe          BL       __aeabi_uidivmod
000014  4604              MOV      r4,r0
;;;249    	if (div == 0) {
000016  2c00              CMP      r4,#0
000018  d100              BNE      |L15.28|
;;;250    		div = 1;
00001a  2401              MOVS     r4,#1
                  |L15.28|
;;;251    	}
;;;252    
;;;253    	/* Approximated rate with only integer divider */
;;;254    	Chip_Clock_SetUARTClockDiv((uint8_t) div);
00001c  b2e0              UXTB     r0,r4
00001e  491d              LDR      r1,|L15.148|
000020  6148              STR      r0,[r1,#0x14]
000022  bf00              NOP      
;;;255    
;;;256    	if (fEnable) {
000024  2e00              CMP      r6,#0
000026  d02f              BEQ      |L15.136|
;;;257    		uint32_t uart_fra_multiplier;
;;;258    
;;;259    		/* Reset FRG */
;;;260    		Chip_SYSCTL_PeriphReset(RESET_UARTFBRG);
000028  2002              MOVS     r0,#2
00002a  bf00              NOP      
00002c  4919              LDR      r1,|L15.148|
00002e  3980              SUBS     r1,r1,#0x80
000030  684a              LDR      r2,[r1,#4]
000032  2101              MOVS     r1,#1
000034  4081              LSLS     r1,r1,r0
000036  4b18              LDR      r3,|L15.152|
000038  4319              ORRS     r1,r1,r3
00003a  438a              BICS     r2,r2,r1
00003c  4915              LDR      r1,|L15.148|
00003e  3980              SUBS     r1,r1,#0x80
000040  604a              STR      r2,[r1,#4]
000042  bf00              NOP      
000044  bf00              NOP      
000046  2101              MOVS     r1,#1
000048  4081              LSLS     r1,r1,r0
00004a  4a12              LDR      r2,|L15.148|
00004c  3a80              SUBS     r2,r2,#0x80
00004e  6852              LDR      r2,[r2,#4]
000050  43db              MVNS     r3,r3
000052  401a              ANDS     r2,r2,r3
000054  4311              ORRS     r1,r1,r2
000056  4a0f              LDR      r2,|L15.148|
000058  3a80              SUBS     r2,r2,#0x80
00005a  6051              STR      r1,[r2,#4]
00005c  bf00              NOP      
00005e  bf00              NOP      
;;;261    
;;;262    		/* Enable fractional divider */
;;;263    		Chip_SYSCTL_SetUSARTFRGDivider(0xFF);
000060  20ff              MOVS     r0,#0xff
000062  f7fffffe          BL       Chip_SYSCTL_SetUSARTFRGDivider
;;;264    
;;;265    		/* Compute the fractional divisor (the lower byte is the
;;;266    		   fractional portion) */
;;;267    		uart_fra_multiplier = ((inclk / div) * 256) / rate;
000066  4621              MOV      r1,r4
000068  9801              LDR      r0,[sp,#4]
00006a  f7fffffe          BL       __aeabi_uidivmod
00006e  0207              LSLS     r7,r0,#8
000070  4629              MOV      r1,r5
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       __aeabi_uidivmod
000078  9000              STR      r0,[sp,#0]
;;;268    
;;;269    		/* ...just the fractional portion (the lower byte) */
;;;270    		Chip_SYSCTL_SetUSARTFRGMultiplier((uint8_t) uart_fra_multiplier);
00007a  9900              LDR      r1,[sp,#0]
00007c  b2c8              UXTB     r0,r1
00007e  4905              LDR      r1,|L15.148|
000080  3140              ADDS     r1,r1,#0x40
000082  6348              STR      r0,[r1,#0x34]
000084  bf00              NOP      
;;;271    	}
000086  e002              B        |L15.142|
                  |L15.136|
;;;272    	else {
;;;273    		/* Disable fractional generator and use integer divider only */
;;;274    		Chip_SYSCTL_SetUSARTFRGDivider(0);
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       Chip_SYSCTL_SetUSARTFRGDivider
                  |L15.142|
;;;275    	}
;;;276    
;;;277    	return Chip_Clock_GetUSARTNBaseClockRate();
00008e  f7fffffe          BL       Chip_Clock_GetUSARTNBaseClockRate
;;;278    }
000092  bdfe              POP      {r1-r7,pc}
;;;279    
                          ENDP

                  |L15.148|
                          DCD      0x40048080
                  |L15.152|
                          DCD      0xfffe2000

                          AREA ||i.Chip_SYSCTL_SetUSARTFRGDivider||, CODE, READONLY, ALIGN=2

                  Chip_SYSCTL_SetUSARTFRGDivider PROC
;;;241     */
;;;242    STATIC INLINE void Chip_SYSCTL_SetUSARTFRGDivider(uint8_t div)
000000  4901              LDR      r1,|L16.8|
;;;243    {
;;;244    	LPC_SYSCTL->UARTFRGDIV = (uint32_t) div;
000002  6308              STR      r0,[r1,#0x30]
;;;245    }
000004  4770              BX       lr
;;;246    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x400480c0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  wdtOSCRate
                          DCD      0x00000000
                          DCD      0x000927c0
                          DCD      0x00100590
                          DCD      0x00155cc0
                          DCD      0x001ab3f0
                          DCD      0x00200b20
                          DCD      0x00249f00
                          DCD      0x002932e0
                          DCD      0x002dc6c0
                          DCD      0x00319750
                          DCD      0x003567e0
                          DCD      0x00393870
                          DCD      0x003d0900
                          DCD      0x00401640
                          DCD      0x00432380
                          DCD      0x004630c0

;*** Start embedded assembler ***

#line 1 "lpc_chip_82x\\src\\clock_8xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_clock_8xx_c_49830408____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___11_clock_8xx_c_49830408____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_clock_8xx_c_49830408____REVSH|
#line 480
|__asm___11_clock_8xx_c_49830408____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
