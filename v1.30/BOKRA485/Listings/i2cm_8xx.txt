; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\i2cm_8xx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\i2cm_8xx.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\i2cm_8xx.crf lpc_chip_82x\src\i2cm_8xx.c]
                          THUMB

                          AREA ||i.Chip_I2CM_ClearStatus||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_ClearStatus PROC
;;;143     */
;;;144    static INLINE void Chip_I2CM_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
000000  2250              MOVS     r2,#0x50
;;;145    {
;;;146    	/* Clear Master Arbitration Loss and Start, Stop Error */
;;;147    	pI2C->STAT = clrStatus & (I2C_STAT_MSTRARBLOSS | I2C_STAT_MSTSTSTPERR);
000002  400a              ANDS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;148    }
000006  4770              BX       lr
;;;149    
                          ENDP


                          AREA ||i.Chip_I2CM_SendStop||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_SendStop PROC
;;;193     */
;;;194    static INLINE void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
000000  2104              MOVS     r1,#4
;;;195    {
;;;196    	pI2C->MSTCTL = I2C_MSTCTL_MSTSTOP;
000002  6201              STR      r1,[r0,#0x20]
;;;197    }
000004  4770              BX       lr
;;;198    
                          ENDP


                          AREA ||i.Chip_I2CM_SetBusSpeed||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_SetBusSpeed PROC
;;;80     /* Set up bus speed for LPC_I2C interface */
;;;81     void Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed)
000000  b5f8              PUSH     {r3-r7,lr}
;;;82     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;83     	uint32_t scl = Chip_Clock_GetSystemClockRate() / (Chip_I2C_GetClockDiv(pI2C) * busSpeed);
000006  bf00              NOP      
000008  6968              LDR      r0,[r5,#0x14]
00000a  b280              UXTH     r0,r0
00000c  1c40              ADDS     r0,r0,#1
00000e  4370              MULS     r0,r6,r0
000010  4607              MOV      r7,r0
000012  f7fffffe          BL       Chip_Clock_GetSystemClockRate
000016  4639              MOV      r1,r7
000018  9000              STR      r0,[sp,#0]
00001a  f7fffffe          BL       __aeabi_uidivmod
00001e  4604              MOV      r4,r0
;;;84     	Chip_I2CM_SetDutyCycle(pI2C, (scl >> 1), (scl - (scl >> 1)));
000020  0860              LSRS     r0,r4,#1
000022  1a20              SUBS     r0,r4,r0
000024  b282              UXTH     r2,r0
000026  03e0              LSLS     r0,r4,#15
000028  0c01              LSRS     r1,r0,#16
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       Chip_I2CM_SetDutyCycle
;;;85     }
000030  bdf8              POP      {r3-r7,pc}
;;;86     
                          ENDP


                          AREA ||i.Chip_I2CM_SetDutyCycle||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_SetDutyCycle PROC
;;;56      */
;;;57     static void Chip_I2CM_SetDutyCycle(LPC_I2C_T *pI2C, uint16_t sclH, uint16_t sclL)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59     	/* Limit to usable range of timing values */
;;;60     	if (sclH < 2) {
000002  2902              CMP      r1,#2
000004  da01              BGE      |L4.10|
;;;61     		sclH = 2;
000006  2102              MOVS     r1,#2
000008  e002              B        |L4.16|
                  |L4.10|
;;;62     	}
;;;63     	else if (sclH > 9) {
00000a  2909              CMP      r1,#9
00000c  dd00              BLE      |L4.16|
;;;64     		sclH = 9;
00000e  2109              MOVS     r1,#9
                  |L4.16|
;;;65     	}
;;;66     	if (sclL < 2) {
000010  2a02              CMP      r2,#2
000012  da01              BGE      |L4.24|
;;;67     		sclL = 2;
000014  2202              MOVS     r2,#2
000016  e002              B        |L4.30|
                  |L4.24|
;;;68     	}
;;;69     	else if (sclL > 9) {
000018  2a09              CMP      r2,#9
00001a  dd00              BLE      |L4.30|
;;;70     		sclL = 9;
00001c  2209              MOVS     r2,#9
                  |L4.30|
;;;71     	}
;;;72     
;;;73     	pI2C->MSTTIME = (((sclH - 2) & 0x07) << 4) | ((sclL - 2) & 0x07);
00001e  1e8b              SUBS     r3,r1,#2
000020  075b              LSLS     r3,r3,#29
000022  0e5b              LSRS     r3,r3,#25
000024  1e94              SUBS     r4,r2,#2
000026  0764              LSLS     r4,r4,#29
000028  0f64              LSRS     r4,r4,#29
00002a  4323              ORRS     r3,r3,r4
00002c  6243              STR      r3,[r0,#0x24]
;;;74     }
00002e  bd10              POP      {r4,pc}
;;;75     
                          ENDP


                          AREA ||i.Chip_I2CM_WriteByte||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_WriteByte PROC
;;;220     */
;;;221    static INLINE void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
000000  6281              STR      r1,[r0,#0x28]
;;;222    {
;;;223    	pI2C->MSTDAT = (uint32_t) data;
;;;224    }
000002  4770              BX       lr
;;;225    
                          ENDP


                          AREA ||i.Chip_I2CM_Xfer||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_Xfer PROC
;;;194    /* Transmit and Receive data in master mode */
;;;195    void Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;197    	/* set the transfer status as busy */
;;;198    	xfer->status = I2CM_STATUS_BUSY;
000006  20ff              MOVS     r0,#0xff
000008  81a0              STRH     r0,[r4,#0xc]
;;;199    	/* Clear controller state. */
;;;200    	Chip_I2CM_ClearStatus(pI2C, I2C_STAT_MSTRARBLOSS | I2C_STAT_MSTSTSTPERR);
00000a  2150              MOVS     r1,#0x50
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       Chip_I2CM_ClearStatus
;;;201    	/* Write Address and RW bit to data register */
;;;202    	Chip_I2CM_WriteByte(pI2C, (xfer->slaveAddr << 1) | (xfer->txSz == 0));
000012  7ba0              LDRB     r0,[r4,#0xe]
000014  0040              LSLS     r0,r0,#1
000016  8922              LDRH     r2,[r4,#8]
000018  2a00              CMP      r2,#0
00001a  d101              BNE      |L6.32|
00001c  2201              MOVS     r2,#1
00001e  e000              B        |L6.34|
                  |L6.32|
000020  2200              MOVS     r2,#0
                  |L6.34|
000022  4310              ORRS     r0,r0,r2
000024  b2c1              UXTB     r1,r0
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       Chip_I2CM_WriteByte
;;;203    	/* Enter to Master Transmitter mode */
;;;204    	Chip_I2CM_SendStart(pI2C);
00002c  bf00              NOP      
00002e  2002              MOVS     r0,#2
000030  6228              STR      r0,[r5,#0x20]
000032  bf00              NOP      
;;;205    }
000034  bd70              POP      {r4-r6,pc}
;;;206    
                          ENDP


                          AREA ||i.Chip_I2CM_XferBlocking||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_XferBlocking PROC
;;;207    /* Transmit and Receive data in master mode */
;;;208    uint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;210    	uint32_t ret = 0;
000006  2500              MOVS     r5,#0
;;;211    	/* start transfer */
;;;212    	Chip_I2CM_Xfer(pI2C, xfer);
000008  4631              MOV      r1,r6
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       Chip_I2CM_Xfer
;;;213    
;;;214    	while (ret == 0) {
000010  e00b              B        |L7.42|
                  |L7.18|
;;;215    		/* wait for status change interrupt */
;;;216    		while (!Chip_I2CM_IsMasterPending(pI2C)) {}
000012  bf00              NOP      
                  |L7.20|
000014  bf00              NOP      
000016  6860              LDR      r0,[r4,#4]
000018  07c0              LSLS     r0,r0,#31
00001a  0fc0              LSRS     r0,r0,#31
00001c  2800              CMP      r0,#0
00001e  d0f9              BEQ      |L7.20|
;;;217    		/* call state change handler */
;;;218    		ret = Chip_I2CM_XferHandler(pI2C, xfer);
000020  4631              MOV      r1,r6
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       Chip_I2CM_XferHandler
000028  4605              MOV      r5,r0
                  |L7.42|
00002a  2d00              CMP      r5,#0                 ;214
00002c  d0f1              BEQ      |L7.18|
;;;219    	}
;;;220    	return ret;
00002e  4628              MOV      r0,r5
;;;221    }
000030  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||i.Chip_I2CM_XferHandler||, CODE, READONLY, ALIGN=1

                  Chip_I2CM_XferHandler PROC
;;;87     /* Master transfer state change handler handler */
;;;88     uint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;90     	uint32_t status = pI2C->INTSTAT;
000006  69ae              LDR      r6,[r5,#0x18]
;;;91     	//uint32_t status = Chip_I2CM_GetIntStatus(pI2C);
;;;92     	/* Master Lost Arbitration */
;;;93     	if (status & I2C_STAT_MSTRARBLOSS) {
000008  2010              MOVS     r0,#0x10
00000a  4030              ANDS     r0,r0,r6
00000c  2800              CMP      r0,#0
00000e  d00b              BEQ      |L8.40|
;;;94     		/* Set transfer status as Arbitration Lost */
;;;95     		xfer->status = I2CM_STATUS_ARBLOST;
000010  2005              MOVS     r0,#5
000012  81a0              STRH     r0,[r4,#0xc]
;;;96     		/* Clear Status Flags */
;;;97     		Chip_I2CM_ClearStatus(pI2C, I2C_STAT_MSTRARBLOSS);
000014  2110              MOVS     r1,#0x10
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       Chip_I2CM_ClearStatus
;;;98     		Chip_I2C_DisableInt(pI2C, UINT32_MAX);
00001c  2100              MOVS     r1,#0
00001e  43c9              MVNS     r1,r1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       Chip_I2C_DisableInt
000026  e091              B        |L8.332|
                  |L8.40|
;;;99     	}
;;;100    	/* Master Start Stop Error */
;;;101    	else if (status & I2C_STAT_MSTSTSTPERR) {
000028  2040              MOVS     r0,#0x40
00002a  4030              ANDS     r0,r0,r6
00002c  2800              CMP      r0,#0
00002e  d00b              BEQ      |L8.72|
;;;102    		/* Set transfer status as Bus Error */
;;;103    		xfer->status = I2CM_STATUS_BUS_ERROR;
000030  2003              MOVS     r0,#3
000032  81a0              STRH     r0,[r4,#0xc]
;;;104    		/* Clear Status Flags */
;;;105    		Chip_I2CM_ClearStatus(pI2C, I2C_STAT_MSTSTSTPERR);
000034  2140              MOVS     r1,#0x40
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       Chip_I2CM_ClearStatus
;;;106    		Chip_I2C_DisableInt(pI2C, UINT32_MAX);
00003c  2100              MOVS     r1,#0
00003e  43c9              MVNS     r1,r1
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       Chip_I2C_DisableInt
000046  e081              B        |L8.332|
                  |L8.72|
;;;107    	}
;;;108    	/* Master is Pending */
;;;109    	else if (status & I2C_STAT_MSTPENDING) {
000048  07f0              LSLS     r0,r6,#31
00004a  0fc0              LSRS     r0,r0,#31
00004c  2800              CMP      r0,#0
00004e  d077              BEQ      |L8.320|
;;;110    		/* Branch based on Master State Code */
;;;111    		switch (Chip_I2CM_GetMasterState(pI2C)) {
000050  bf00              NOP      
000052  6868              LDR      r0,[r5,#4]
000054  210e              MOVS     r1,#0xe
000056  4008              ANDS     r0,r0,r1
000058  0840              LSRS     r0,r0,#1
00005a  0003              MOVS     r3,r0
00005c  f7fffffe          BL       __ARM_common_switch8
000060  05040523          DCB      0x05,0x04,0x05,0x23
000064  515c6800          DCB      0x51,0x5c,0x68,0x00
;;;112    		/* Master idle */
;;;113    		case I2C_STAT_MSTCODE_IDLE:
;;;114    			/* Do Nothing */
;;;115    //			Chip_I2C_DisableInt(pI2C, I2C_INTENSET_MSTPENDING);
;;;116    			break;
000068  e069              B        |L8.318|
;;;117    
;;;118    		/* Receive data is available */
;;;119    		case I2C_STAT_MSTCODE_RXREADY:
;;;120    			/* Read Data */
;;;121    			*xfer->rxBuff++ = pI2C->MSTDAT;
00006a  6aa8              LDR      r0,[r5,#0x28]
00006c  b2c1              UXTB     r1,r0
00006e  6862              LDR      r2,[r4,#4]
000070  1c50              ADDS     r0,r2,#1
000072  6060              STR      r0,[r4,#4]
000074  7011              STRB     r1,[r2,#0]
;;;122    			xfer->rxSz--;
000076  8960              LDRH     r0,[r4,#0xa]
000078  1e40              SUBS     r0,r0,#1
00007a  8160              STRH     r0,[r4,#0xa]
;;;123    			if (xfer->rxSz) {
00007c  8960              LDRH     r0,[r4,#0xa]
00007e  2800              CMP      r0,#0
000080  d006              BEQ      |L8.144|
;;;124    				/* Set Continue if there is more data to read */
;;;125    				Chip_I2CM_MasterContinue(pI2C);
000082  bf00              NOP      
000084  2001              MOVS     r0,#1
000086  6228              STR      r0,[r5,#0x20]
000088  bf00              NOP      
;;;126    				xfer->status = I2CM_STATUS_BUSY;
00008a  20ff              MOVS     r0,#0xff
00008c  81a0              STRH     r0,[r4,#0xc]
00008e  e009              B        |L8.164|
                  |L8.144|
;;;127    			}
;;;128    			else {
;;;129    				/* Set transfer status as OK */
;;;130    				xfer->status = I2CM_STATUS_OK;
000090  2000              MOVS     r0,#0
000092  81a0              STRH     r0,[r4,#0xc]
;;;131    				/* No data to read send Stop */
;;;132    				Chip_I2CM_SendStop(pI2C);
000094  4628              MOV      r0,r5
000096  f7fffffe          BL       Chip_I2CM_SendStop
;;;133    				Chip_I2C_DisableInt(pI2C, UINT32_MAX);
00009a  2100              MOVS     r1,#0
00009c  43c9              MVNS     r1,r1
00009e  4628              MOV      r0,r5
0000a0  f7fffffe          BL       Chip_I2C_DisableInt
                  |L8.164|
;;;134    			}
;;;135    			break;
0000a4  e04b              B        |L8.318|
;;;136    
;;;137    		/* Master Transmit available */
;;;138    		case I2C_STAT_MSTCODE_TXREADY:
;;;139    			if (xfer->txSz) {
0000a6  8920              LDRH     r0,[r4,#8]
0000a8  2800              CMP      r0,#0
0000aa  d00e              BEQ      |L8.202|
;;;140    				/* If Tx data available transmit data and continue */
;;;141    				xfer->status = I2CM_STATUS_BUSY;
0000ac  20ff              MOVS     r0,#0xff
0000ae  81a0              STRH     r0,[r4,#0xc]
;;;142    				pI2C->MSTDAT = *xfer->txBuff++;
0000b0  6821              LDR      r1,[r4,#0]
0000b2  1c48              ADDS     r0,r1,#1
0000b4  6020              STR      r0,[r4,#0]
0000b6  7808              LDRB     r0,[r1,#0]
0000b8  62a8              STR      r0,[r5,#0x28]
;;;143    				xfer->txSz--;
0000ba  8920              LDRH     r0,[r4,#8]
0000bc  1e40              SUBS     r0,r0,#1
0000be  8120              STRH     r0,[r4,#8]
;;;144    				Chip_I2CM_MasterContinue(pI2C);
0000c0  bf00              NOP      
0000c2  2001              MOVS     r0,#1
0000c4  6228              STR      r0,[r5,#0x20]
0000c6  bf00              NOP      
0000c8  e01a              B        |L8.256|
                  |L8.202|
;;;145    			}
;;;146    			else {
;;;147    				/* If receive queued after transmit then initiate master receive transfer*/
;;;148    				if (xfer->rxSz) {
0000ca  8960              LDRH     r0,[r4,#0xa]
0000cc  2800              CMP      r0,#0
0000ce  d00d              BEQ      |L8.236|
;;;149    					/* Write Address and RW bit to data register */
;;;150    					Chip_I2CM_WriteByte(pI2C, (xfer->slaveAddr << 1) | 0x1);
0000d0  7ba0              LDRB     r0,[r4,#0xe]
0000d2  0040              LSLS     r0,r0,#1
0000d4  1c40              ADDS     r0,r0,#1
0000d6  b2c1              UXTB     r1,r0
0000d8  4628              MOV      r0,r5
0000da  f7fffffe          BL       Chip_I2CM_WriteByte
;;;151    					/* Enter to Master Transmitter mode */
;;;152    					Chip_I2CM_SendStart(pI2C);
0000de  bf00              NOP      
0000e0  2002              MOVS     r0,#2
0000e2  6228              STR      r0,[r5,#0x20]
0000e4  bf00              NOP      
;;;153    					xfer->status = I2CM_STATUS_BUSY;
0000e6  20ff              MOVS     r0,#0xff
0000e8  81a0              STRH     r0,[r4,#0xc]
0000ea  e009              B        |L8.256|
                  |L8.236|
;;;154    				}
;;;155    				else {
;;;156    					/* If no receive queued then set transfer status as OK */
;;;157    					xfer->status = I2CM_STATUS_OK;
0000ec  2000              MOVS     r0,#0
0000ee  81a0              STRH     r0,[r4,#0xc]
;;;158    					/* Send Stop */
;;;159    					Chip_I2CM_SendStop(pI2C);
0000f0  4628              MOV      r0,r5
0000f2  f7fffffe          BL       Chip_I2CM_SendStop
;;;160    					Chip_I2C_DisableInt(pI2C, UINT32_MAX);
0000f6  2100              MOVS     r1,#0
0000f8  43c9              MVNS     r1,r1
0000fa  4628              MOV      r0,r5
0000fc  f7fffffe          BL       Chip_I2C_DisableInt
                  |L8.256|
;;;161    				}
;;;162    			}
;;;163    			break;
000100  e01d              B        |L8.318|
;;;164    
;;;165    		case I2C_STAT_MSTCODE_NACKADR:
;;;166    			/* Set transfer status as NACK on address */
;;;167    			xfer->status = I2CM_STATUS_NAK_ADR;
000102  2002              MOVS     r0,#2
000104  81a0              STRH     r0,[r4,#0xc]
;;;168    			Chip_I2CM_SendStop(pI2C);
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       Chip_I2CM_SendStop
;;;169    			Chip_I2C_DisableInt(pI2C, UINT32_MAX);
00010c  2100              MOVS     r1,#0
00010e  43c9              MVNS     r1,r1
000110  4628              MOV      r0,r5
000112  f7fffffe          BL       Chip_I2C_DisableInt
;;;170    			break;
000116  e012              B        |L8.318|
;;;171    
;;;172    		case I2C_STAT_MSTCODE_NACKDAT:
;;;173    			/* Set transfer status as NACK on data */
;;;174    			xfer->status = I2CM_STATUS_NAK_DAT;
000118  2004              MOVS     r0,#4
00011a  81a0              STRH     r0,[r4,#0xc]
;;;175    			Chip_I2CM_SendStop(pI2C);
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       Chip_I2CM_SendStop
;;;176    			Chip_I2C_DisableInt(pI2C, UINT32_MAX);
000122  2100              MOVS     r1,#0
000124  43c9              MVNS     r1,r1
000126  4628              MOV      r0,r5
000128  f7fffffe          BL       Chip_I2C_DisableInt
;;;177    			break;
00012c  e007              B        |L8.318|
00012e  e007              B        |L8.320|
;;;178    
;;;179    		default:
;;;180    			/* Default case should not occur*/
;;;181    			xfer->status = I2CM_STATUS_ERROR;
000130  2001              MOVS     r0,#1
000132  81a0              STRH     r0,[r4,#0xc]
;;;182    			Chip_I2C_DisableInt(pI2C, UINT32_MAX);
000134  1e81              SUBS     r1,r0,#2
000136  4628              MOV      r0,r5
000138  f7fffffe          BL       Chip_I2C_DisableInt
;;;183    			break;
00013c  bf00              NOP      
                  |L8.318|
00013e  e005              B        |L8.332|
                  |L8.320|
;;;184    		}
;;;185    	}
;;;186    	else {
;;;187    		/* Default case should not occur */
;;;188    		xfer->status = I2CM_STATUS_ERROR;
000140  2001              MOVS     r0,#1
000142  81a0              STRH     r0,[r4,#0xc]
;;;189    		Chip_I2C_DisableInt(pI2C, UINT32_MAX);
000144  1e81              SUBS     r1,r0,#2
000146  4628              MOV      r0,r5
000148  f7fffffe          BL       Chip_I2C_DisableInt
                  |L8.332|
;;;190    	}
;;;191    	return xfer->status;// != I2CM_STATUS_BUSY;
00014c  89a0              LDRH     r0,[r4,#0xc]
;;;192    }
00014e  bd70              POP      {r4-r6,pc}
;;;193    
                          ENDP


                          AREA ||i.Chip_I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  Chip_I2C_DisableInt PROC
;;;293     */
;;;294    static INLINE void Chip_I2C_DisableInt(LPC_I2C_T *pI2C, uint32_t intClr)
000000  60c1              STR      r1,[r0,#0xc]
;;;295    {
;;;296    	pI2C->INTENCLR = intClr;
;;;297    }
000002  4770              BX       lr
;;;298    
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L56.24|
                  |L56.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L56.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L56.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "lpc_chip_82x\\src\\i2cm_8xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_i2cm_8xx_c_b9e2fb71____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___10_i2cm_8xx_c_b9e2fb71____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_i2cm_8xx_c_b9e2fb71____REVSH|
#line 480
|__asm___10_i2cm_8xx_c_b9e2fb71____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
