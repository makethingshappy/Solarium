; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\uart_8xx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart_8xx.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\uart_8xx.crf lpc_chip_82x\src\uart_8xx.c]
                          THUMB

                          AREA ||i.Chip_SYSCTL_PeriphReset||, CODE, READONLY, ALIGN=2

                  Chip_SYSCTL_PeriphReset PROC
;;;296     */
;;;297    STATIC INLINE void Chip_SYSCTL_PeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
000000  bf00              NOP      
000002  490b              LDR      r1,|L1.48|
000004  684a              LDR      r2,[r1,#4]
000006  2101              MOVS     r1,#1
000008  4081              LSLS     r1,r1,r0
00000a  4b0a              LDR      r3,|L1.52|
00000c  4319              ORRS     r1,r1,r3
00000e  438a              BICS     r2,r2,r1
000010  4907              LDR      r1,|L1.48|
000012  604a              STR      r2,[r1,#4]
000014  bf00              NOP      
;;;298    {
;;;299    	Chip_SYSCTL_AssertPeriphReset(periph);
;;;300    	Chip_SYSCTL_DeassertPeriphReset(periph);
000016  bf00              NOP      
000018  2101              MOVS     r1,#1
00001a  4081              LSLS     r1,r1,r0
00001c  4a04              LDR      r2,|L1.48|
00001e  6852              LDR      r2,[r2,#4]
000020  43db              MVNS     r3,r3
000022  401a              ANDS     r2,r2,r3
000024  4311              ORRS     r1,r1,r2
000026  4a02              LDR      r2,|L1.48|
000028  6051              STR      r1,[r2,#4]
00002a  bf00              NOP      
;;;301    }
00002c  4770              BX       lr
;;;302    
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40048000
                  |L1.52|
                          DCD      0xfffe2000

                          AREA ||i.Chip_UART_DeInit||, CODE, READONLY, ALIGN=2

                  Chip_UART_DeInit PROC
;;;84     /* Initialize the UART peripheral */
;;;85     void Chip_UART_DeInit(LPC_USART_T *pUART)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
000002  4605              MOV      r5,r0
;;;87     	/* Disable USART clock */
;;;88     	Chip_Clock_DisablePeriphClock(getUARTClockID(pUART));
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       getUARTClockID
00000a  4604              MOV      r4,r0
00000c  4805              LDR      r0,|L2.36|
00000e  6801              LDR      r1,[r0,#0]
000010  2001              MOVS     r0,#1
000012  40a0              LSLS     r0,r0,r4
000014  4a04              LDR      r2,|L2.40|
000016  4310              ORRS     r0,r0,r2
000018  4381              BICS     r1,r1,r0
00001a  4802              LDR      r0,|L2.36|
00001c  6001              STR      r1,[r0,#0]
00001e  bf00              NOP      
;;;89     }
000020  bd70              POP      {r4-r6,pc}
;;;90     
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x40048080
                  |L2.40|
                          DCD      0xda100000

                          AREA ||i.Chip_UART_GetStatus||, CODE, READONLY, ALIGN=2

                  Chip_UART_GetStatus PROC
;;;301     */
;;;302    STATIC INLINE uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
000000  4601              MOV      r1,r0
;;;303    {
;;;304    	return (pUART->STAT & ~UART_STAT_RESERVED);
000002  6888              LDR      r0,[r1,#8]
000004  4a01              LDR      r2,|L3.12|
000006  4010              ANDS     r0,r0,r2
;;;305    }
000008  4770              BX       lr
;;;306    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x0001fd7f

                          AREA ||i.Chip_UART_IRQRBHandler||, CODE, READONLY, ALIGN=1

                  Chip_UART_IRQRBHandler PROC
;;;217    /* UART receive/transmit interrupt handler for ring buffers */
;;;218    void Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB)
000000  b570              PUSH     {r4-r6,lr}
;;;219    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;220    	/* Handle transmit interrupt if enabled */
;;;221    	if ((Chip_UART_GetStatus(pUART) & UART_STAT_TXRDY) != 0) {
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       Chip_UART_GetStatus
00000e  2104              MOVS     r1,#4
000010  4008              ANDS     r0,r0,r1
000012  2800              CMP      r0,#0
000014  d011              BEQ      |L4.58|
;;;222    		Chip_UART_TXIntHandlerRB(pUART, pTXRB);
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       Chip_UART_TXIntHandlerRB
;;;223    
;;;224    		/* Disable transmit interrupt if the ring buffer is empty */
;;;225    		if (RingBuffer_IsEmpty(pTXRB)) {
00001e  bf00              NOP      
000020  68e0              LDR      r0,[r4,#0xc]
000022  6921              LDR      r1,[r4,#0x10]
000024  4288              CMP      r0,r1
000026  d101              BNE      |L4.44|
000028  2001              MOVS     r0,#1
00002a  e000              B        |L4.46|
                  |L4.44|
00002c  2000              MOVS     r0,#0
                  |L4.46|
00002e  2800              CMP      r0,#0
000030  d003              BEQ      |L4.58|
;;;226    			Chip_UART_IntDisable(pUART, UART_INTEN_TXRDY);
000032  2104              MOVS     r1,#4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       Chip_UART_IntDisable
                  |L4.58|
;;;227    		}
;;;228    	}
;;;229    
;;;230    	/* Handle receive interrupt */
;;;231    	Chip_UART_RXIntHandlerRB(pUART, pRXRB);
00003a  4631              MOV      r1,r6
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       Chip_UART_RXIntHandlerRB
;;;232    }
000042  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||i.Chip_UART_Init||, CODE, READONLY, ALIGN=2

                  Chip_UART_Init PROC
;;;63     /* Initialize the UART peripheral */
;;;64     void Chip_UART_Init(LPC_USART_T *pUART)
000000  b570              PUSH     {r4-r6,lr}
;;;65     {
000002  4604              MOV      r4,r0
;;;66     	/* Enable USART clock */
;;;67     	Chip_Clock_EnablePeriphClock(getUARTClockID(pUART));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       getUARTClockID
00000a  4605              MOV      r5,r0
00000c  2001              MOVS     r0,#1
00000e  40a8              LSLS     r0,r0,r5
000010  490c              LDR      r1,|L5.68|
000012  6809              LDR      r1,[r1,#0]
000014  4a0c              LDR      r2,|L5.72|
000016  4011              ANDS     r1,r1,r2
000018  4308              ORRS     r0,r0,r1
00001a  490a              LDR      r1,|L5.68|
00001c  6008              STR      r0,[r1,#0]
00001e  bf00              NOP      
;;;68     
;;;69     	/* UART reset */
;;;70     	if (pUART == LPC_USART0) {
000020  480a              LDR      r0,|L5.76|
000022  4284              CMP      r4,r0
000024  d103              BNE      |L5.46|
;;;71     		/* Peripheral reset control to USART0 */
;;;72     		Chip_SYSCTL_PeriphReset(RESET_USART0);
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       Chip_SYSCTL_PeriphReset
00002c  e009              B        |L5.66|
                  |L5.46|
;;;73     	}
;;;74     	else if (pUART == LPC_USART1) {
00002e  4808              LDR      r0,|L5.80|
000030  4284              CMP      r4,r0
000032  d103              BNE      |L5.60|
;;;75     		/* Peripheral reset control to USART1 */
;;;76     		Chip_SYSCTL_PeriphReset(RESET_USART1);
000034  2004              MOVS     r0,#4
000036  f7fffffe          BL       Chip_SYSCTL_PeriphReset
00003a  e002              B        |L5.66|
                  |L5.60|
;;;77     	}
;;;78     	else {
;;;79     		/* Peripheral reset control to USART2 */
;;;80     		Chip_SYSCTL_PeriphReset(RESET_USART2);
00003c  2005              MOVS     r0,#5
00003e  f7fffffe          BL       Chip_SYSCTL_PeriphReset
                  |L5.66|
;;;81     	}
;;;82     }
000042  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  |L5.68|
                          DCD      0x40048080
                  |L5.72|
                          DCD      0x25efffff
                  |L5.76|
                          DCD      0x40064000
                  |L5.80|
                          DCD      0x40068000

                          AREA ||i.Chip_UART_IntDisable||, CODE, READONLY, ALIGN=1

                  Chip_UART_IntDisable PROC
;;;243     */
;;;244    STATIC INLINE void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
000000  6101              STR      r1,[r0,#0x10]
;;;245    {
;;;246    	pUART->INTENCLR = intMask;
;;;247    }
000002  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.Chip_UART_RXIntHandlerRB||, CODE, READONLY, ALIGN=1

                  Chip_UART_RXIntHandlerRB PROC
;;;165    /* UART receive-only interrupt handler for ring buffers */
;;;166    void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
000000  b538              PUSH     {r3-r5,lr}
;;;167    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;168    	/* New data will be ignored if data not popped in time */
;;;169    	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
000006  e008              B        |L7.26|
                  |L7.8|
;;;170    		uint8_t ch = Chip_UART_ReadByte(pUART);
000008  bf00              NOP      
00000a  6960              LDR      r0,[r4,#0x14]
00000c  b2c0              UXTB     r0,r0
00000e  9000              STR      r0,[sp,#0]
;;;171    		RingBuffer_Insert(pRB, &ch);
000010  4669              MOV      r1,sp
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       RingBuffer_Insert
;;;172    	}
000018  bf00              NOP      
                  |L7.26|
00001a  4620              MOV      r0,r4                 ;169
00001c  f7fffffe          BL       Chip_UART_GetStatus
000020  07c0              LSLS     r0,r0,#31             ;169
000022  0fc0              LSRS     r0,r0,#31             ;169
000024  2800              CMP      r0,#0                 ;169
000026  d1ef              BNE      |L7.8|
;;;173    }
000028  bd38              POP      {r3-r5,pc}
;;;174    
                          ENDP


                          AREA ||i.Chip_UART_Read||, CODE, READONLY, ALIGN=1

                  Chip_UART_Read PROC
;;;124    /* Read data through the UART peripheral (non-blocking) */
;;;125    int Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;126    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;127    	int readBytes = 0;
000006  2400              MOVS     r4,#0
;;;128    	uint8_t *p8 = (uint8_t *) data;
000008  4637              MOV      r7,r6
;;;129    
;;;130    	/* Send until the transmit FIFO is full or out of bytes */
;;;131    	while ((readBytes < numBytes) &&
00000a  e004              B        |L8.22|
                  |L8.12|
;;;132    		   ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0)) {
;;;133    		*p8 = Chip_UART_ReadByte(pUART);
00000c  bf00              NOP      
00000e  6968              LDR      r0,[r5,#0x14]
000010  7038              STRB     r0,[r7,#0]
;;;134    		p8++;
000012  1c7f              ADDS     r7,r7,#1
;;;135    		readBytes++;
000014  1c64              ADDS     r4,r4,#1
                  |L8.22|
000016  9802              LDR      r0,[sp,#8]            ;131
000018  4284              CMP      r4,r0                 ;131
00001a  da06              BGE      |L8.42|
00001c  4628              MOV      r0,r5                 ;132
00001e  f7fffffe          BL       Chip_UART_GetStatus
000022  07c0              LSLS     r0,r0,#31             ;132
000024  0fc0              LSRS     r0,r0,#31             ;132
000026  2800              CMP      r0,#0                 ;132
000028  d1f0              BNE      |L8.12|
                  |L8.42|
;;;136    	}
;;;137    
;;;138    	return readBytes;
00002a  4620              MOV      r0,r4
;;;139    }
00002c  bdfe              POP      {r1-r7,pc}
;;;140    
                          ENDP


                          AREA ||i.Chip_UART_ReadBlocking||, CODE, READONLY, ALIGN=1

                  Chip_UART_ReadBlocking PROC
;;;141    /* Read data through the UART peripheral (blocking) */
;;;142    int Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;143    {
000002  b082              SUB      sp,sp,#8
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
;;;144    	int pass, readBytes = 0;
000008  2600              MOVS     r6,#0
;;;145    	uint8_t *p8 = (uint8_t *) data;
00000a  9701              STR      r7,[sp,#4]
;;;146    
;;;147    	while (readBytes < numBytes) {
00000c  e00a              B        |L9.36|
                  |L9.14|
;;;148    		pass = Chip_UART_Read(pUART, p8, numBytes);
00000e  462a              MOV      r2,r5
000010  9901              LDR      r1,[sp,#4]
000012  9802              LDR      r0,[sp,#8]
000014  f7fffffe          BL       Chip_UART_Read
000018  4604              MOV      r4,r0
;;;149    		numBytes -= pass;
00001a  1b2d              SUBS     r5,r5,r4
;;;150    		readBytes += pass;
00001c  1936              ADDS     r6,r6,r4
;;;151    		p8 += pass;
00001e  9801              LDR      r0,[sp,#4]
000020  1900              ADDS     r0,r0,r4
000022  9001              STR      r0,[sp,#4]
                  |L9.36|
000024  42ae              CMP      r6,r5                 ;147
000026  dbf2              BLT      |L9.14|
;;;152    	}
;;;153    
;;;154    	return readBytes;
000028  4630              MOV      r0,r6
;;;155    }
00002a  b005              ADD      sp,sp,#0x14
00002c  bdf0              POP      {r4-r7,pc}
;;;156    
                          ENDP


                          AREA ||i.Chip_UART_ReadRB||, CODE, READONLY, ALIGN=1

                  Chip_UART_ReadRB PROC
;;;209    /* Copy data from a receive ring buffer */
;;;210    int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes)
000000  b5f8              PUSH     {r3-r7,lr}
;;;211    {
000002  4607              MOV      r7,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;212    	(void) pUART;
;;;213    
;;;214    	return RingBuffer_PopMult(pRB, (uint8_t *) data, bytes);
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RingBuffer_PopMult
;;;215    }
000014  bdf8              POP      {r3-r7,pc}
;;;216    
                          ENDP


                          AREA ||i.Chip_UART_Send||, CODE, READONLY, ALIGN=1

                  Chip_UART_Send PROC
;;;91     /* Transmit a byte array through the UART peripheral (non-blocking) */
;;;92     int Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;93     {
000002  460d              MOV      r5,r1
000004  4616              MOV      r6,r2
;;;94     	int sent = 0;
000006  2400              MOVS     r4,#0
;;;95     	uint8_t *p8 = (uint8_t *) data;
000008  462f              MOV      r7,r5
;;;96     
;;;97     	/* Send until the transmit FIFO is full or out of bytes */
;;;98     	while ((sent < numBytes) &&
00000a  e005              B        |L11.24|
                  |L11.12|
;;;99     		   ((Chip_UART_GetStatus(pUART) & UART_STAT_TXRDY) != 0)) {
;;;100    		Chip_UART_SendByte(pUART, *p8);
00000c  7839              LDRB     r1,[r7,#0]
00000e  9800              LDR      r0,[sp,#0]
000010  f7fffffe          BL       Chip_UART_SendByte
;;;101    		p8++;
000014  1c7f              ADDS     r7,r7,#1
;;;102    		sent++;
000016  1c64              ADDS     r4,r4,#1
                  |L11.24|
000018  42b4              CMP      r4,r6                 ;98
00001a  da06              BGE      |L11.42|
00001c  9800              LDR      r0,[sp,#0]            ;99
00001e  f7fffffe          BL       Chip_UART_GetStatus
000022  2104              MOVS     r1,#4                 ;99
000024  4008              ANDS     r0,r0,r1              ;99
000026  2800              CMP      r0,#0                 ;99
000028  d1f0              BNE      |L11.12|
                  |L11.42|
;;;103    	}
;;;104    
;;;105    	return sent;
00002a  4620              MOV      r0,r4
;;;106    }
00002c  bdfe              POP      {r1-r7,pc}
;;;107    
                          ENDP


                          AREA ||i.Chip_UART_SendBlocking||, CODE, READONLY, ALIGN=1

                  Chip_UART_SendBlocking PROC
;;;108    /* Transmit a byte array through the UART peripheral (blocking) */
;;;109    int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;110    {
000002  b082              SUB      sp,sp,#8
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;111    	int pass, sent = 0;
000008  2700              MOVS     r7,#0
;;;112    	uint8_t *p8 = (uint8_t *) data;
00000a  9601              STR      r6,[sp,#4]
;;;113    
;;;114    	while (numBytes > 0) {
00000c  e00a              B        |L12.36|
                  |L12.14|
;;;115    		pass = Chip_UART_Send(pUART, p8, numBytes);
00000e  462a              MOV      r2,r5
000010  9901              LDR      r1,[sp,#4]
000012  9802              LDR      r0,[sp,#8]
000014  f7fffffe          BL       Chip_UART_Send
000018  4604              MOV      r4,r0
;;;116    		numBytes -= pass;
00001a  1b2d              SUBS     r5,r5,r4
;;;117    		sent += pass;
00001c  193f              ADDS     r7,r7,r4
;;;118    		p8 += pass;
00001e  9801              LDR      r0,[sp,#4]
000020  1900              ADDS     r0,r0,r4
000022  9001              STR      r0,[sp,#4]
                  |L12.36|
000024  2d00              CMP      r5,#0                 ;114
000026  dcf2              BGT      |L12.14|
;;;119    	}
;;;120    
;;;121    	return sent;
000028  4638              MOV      r0,r7
;;;122    }
00002a  b005              ADD      sp,sp,#0x14
00002c  bdf0              POP      {r4-r7,pc}
;;;123    
                          ENDP


                          AREA ||i.Chip_UART_SendByte||, CODE, READONLY, ALIGN=1

                  Chip_UART_SendByte PROC
;;;203     */
;;;204    STATIC INLINE void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
000000  61c1              STR      r1,[r0,#0x1c]
;;;205    {
;;;206    	pUART->TXDATA = (uint32_t) data;
;;;207    }
000002  4770              BX       lr
;;;208    
                          ENDP


                          AREA ||i.Chip_UART_SendRB||, CODE, READONLY, ALIGN=1

                  Chip_UART_SendRB PROC
;;;187    /* Populate a transmit ring buffer and start UART transmit */
;;;188    uint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int count)
000000  b5ff              PUSH     {r0-r7,lr}
;;;189    {
000002  b081              SUB      sp,sp,#4
000004  4607              MOV      r7,r0
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;190    	uint32_t ret;
;;;191    	uint8_t *p8 = (uint8_t *) data;
00000a  9500              STR      r5,[sp,#0]
;;;192    
;;;193    	/* Don't let UART transmit ring buffer change in the UART IRQ handler */
;;;194    	Chip_UART_IntDisable(pUART, UART_INTEN_TXRDY);
00000c  2104              MOVS     r1,#4
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       Chip_UART_IntDisable
;;;195    
;;;196    	/* Move as much data as possible into transmit ring buffer */
;;;197    	ret = RingBuffer_InsertMult(pRB, p8, count);
000014  4632              MOV      r2,r6
000016  9900              LDR      r1,[sp,#0]
000018  9802              LDR      r0,[sp,#8]
00001a  f7fffffe          BL       RingBuffer_InsertMult
00001e  4604              MOV      r4,r0
;;;198    	Chip_UART_TXIntHandlerRB(pUART, pRB);
000020  4638              MOV      r0,r7
000022  9902              LDR      r1,[sp,#8]
000024  f7fffffe          BL       Chip_UART_TXIntHandlerRB
;;;199    
;;;200    	/* Add additional data to transmit ring buffer if possible */
;;;201    	ret += RingBuffer_InsertMult(pRB, (p8 + ret), (count - ret));
000028  1b32              SUBS     r2,r6,r4
00002a  9d00              LDR      r5,[sp,#0]
00002c  1929              ADDS     r1,r5,r4
00002e  9802              LDR      r0,[sp,#8]
000030  f7fffffe          BL       RingBuffer_InsertMult
000034  1904              ADDS     r4,r0,r4
;;;202    
;;;203    	/* Enable UART transmit interrupt */
;;;204    	Chip_UART_IntEnable(pUART, UART_INTEN_TXRDY);
000036  2004              MOVS     r0,#4
000038  60f8              STR      r0,[r7,#0xc]
00003a  bf00              NOP      
;;;205    
;;;206    	return ret;
00003c  4620              MOV      r0,r4
;;;207    }
00003e  b005              ADD      sp,sp,#0x14
000040  bdf0              POP      {r4-r7,pc}
;;;208    
                          ENDP


                          AREA ||i.Chip_UART_SetBaud||, CODE, READONLY, ALIGN=1

                  Chip_UART_SetBaud PROC
;;;157    /* Set baud rate for UART */
;;;158    void Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
000000  b5f8              PUSH     {r3-r7,lr}
;;;159    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;160    	uint32_t baudRateGenerator;
;;;161    	baudRateGenerator = Chip_Clock_GetUSARTNBaseClockRate() / (16 * baudrate);
000006  f7fffffe          BL       Chip_Clock_GetUSARTNBaseClockRate
00000a  4607              MOV      r7,r0
00000c  0129              LSLS     r1,r5,#4
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  4606              MOV      r6,r0
;;;162    	pUART->BRG = baudRateGenerator - 1;	/* baud rate */
000014  1e70              SUBS     r0,r6,#1
000016  6220              STR      r0,[r4,#0x20]
;;;163    }
000018  bdf8              POP      {r3-r7,pc}
;;;164    
                          ENDP


                          AREA ||i.Chip_UART_TXIntHandlerRB||, CODE, READONLY, ALIGN=1

                  Chip_UART_TXIntHandlerRB PROC
;;;175    /* UART transmit-only interrupt handler for ring buffers */
;;;176    void Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
000000  b538              PUSH     {r3-r5,lr}
;;;177    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;178    	uint8_t ch;
;;;179    
;;;180    	/* Fill FIFO until full or until TX ring buffer is empty */
;;;181    	while (((Chip_UART_GetStatus(pUART) & UART_STAT_TXRDY) != 0) &&
000006  e004              B        |L16.18|
                  |L16.8|
;;;182    		   RingBuffer_Pop(pRB, &ch)) {
;;;183    		Chip_UART_SendByte(pUART, ch);
000008  4668              MOV      r0,sp
00000a  7801              LDRB     r1,[r0,#0]
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       Chip_UART_SendByte
                  |L16.18|
000012  4628              MOV      r0,r5                 ;181
000014  f7fffffe          BL       Chip_UART_GetStatus
000018  2104              MOVS     r1,#4                 ;181
00001a  4008              ANDS     r0,r0,r1              ;181
00001c  2800              CMP      r0,#0                 ;181
00001e  d005              BEQ      |L16.44|
000020  4669              MOV      r1,sp                 ;182
000022  4620              MOV      r0,r4                 ;182
000024  f7fffffe          BL       RingBuffer_Pop
000028  2800              CMP      r0,#0                 ;182
00002a  d1ed              BNE      |L16.8|
                  |L16.44|
;;;184    	}
;;;185    }
00002c  bd38              POP      {r3-r5,pc}
;;;186    
                          ENDP


                          AREA ||i.getUARTClockID||, CODE, READONLY, ALIGN=2

                  getUARTClockID PROC
;;;46     /* Return UART clock ID from the UART register address */
;;;47     static CHIP_SYSCTL_CLOCK_T getUARTClockID(LPC_USART_T *pUART)
000000  4601              MOV      r1,r0
;;;48     {
;;;49     	if (pUART == LPC_USART0) {
000002  4806              LDR      r0,|L17.28|
000004  4281              CMP      r1,r0
000006  d101              BNE      |L17.12|
;;;50     		return SYSCTL_CLOCK_UART0;
000008  200e              MOVS     r0,#0xe
                  |L17.10|
;;;51     	}
;;;52     	else if (pUART == LPC_USART1) {
;;;53     		return SYSCTL_CLOCK_UART1;
;;;54     	}
;;;55     
;;;56     	return SYSCTL_CLOCK_UART2;
;;;57     }
00000a  4770              BX       lr
                  |L17.12|
00000c  4804              LDR      r0,|L17.32|
00000e  4281              CMP      r1,r0                 ;52
000010  d101              BNE      |L17.22|
000012  200f              MOVS     r0,#0xf               ;53
000014  e7f9              B        |L17.10|
                  |L17.22|
000016  2010              MOVS     r0,#0x10              ;56
000018  e7f7              B        |L17.10|
;;;58     
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40064000
                  |L17.32|
                          DCD      0x40068000

;*** Start embedded assembler ***

#line 1 "lpc_chip_82x\\src\\uart_8xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_uart_8xx_c_b8b3c308____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___10_uart_8xx_c_b8b3c308____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_uart_8xx_c_b8b3c308____REVSH|
#line 480
|__asm___10_uart_8xx_c_b8b3c308____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
