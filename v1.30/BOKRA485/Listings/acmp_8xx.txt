; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\acmp_8xx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\acmp_8xx.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\BOKRA485 -I.\_CMSIS\v5.20\Include -I.\lpc_chip_82x\inc -I.\Hardware -IC:\Users\Peter\Documents\Projects\Workspace-Keil\LPC824\BOKRA485\v1.30\BOKRA485\RTE -IC:\Keil_v5\ARM\PACK\Keil\LPC800_DFP\1.10.1\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DLPC824M201JHI33 -DCORE_M0PLUS --omf_browse=.\objects\acmp_8xx.crf lpc_chip_82x\src\acmp_8xx.c]
                          THUMB

                          AREA ||i.Chip_ACMP_Deinit||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_Deinit PROC
;;;54     /* De-initializes the ACMP */
;;;55     void Chip_ACMP_Deinit(LPC_CMP_T *pACMP)
000000  b510              PUSH     {r4,lr}
;;;56     {
000002  4604              MOV      r4,r0
;;;57     	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_ACOMP);
000004  2013              MOVS     r0,#0x13
000006  4907              LDR      r1,|L1.36|
000008  680a              LDR      r2,[r1,#0]
00000a  2101              MOVS     r1,#1
00000c  4081              LSLS     r1,r1,r0
00000e  4b06              LDR      r3,|L1.40|
000010  4319              ORRS     r1,r1,r3
000012  438a              BICS     r2,r2,r1
000014  4903              LDR      r1,|L1.36|
000016  600a              STR      r2,[r1,#0]
000018  bf00              NOP      
;;;58     	Chip_SYSCTL_PowerDown(SYSCTL_SLPWAKE_ACMP_PD);
00001a  2001              MOVS     r0,#1
00001c  03c0              LSLS     r0,r0,#15
00001e  f7fffffe          BL       Chip_SYSCTL_PowerDown
;;;59     }
000022  bd10              POP      {r4,pc}
;;;60     
                          ENDP

                  |L1.36|
                          DCD      0x40048080
                  |L1.40|
                          DCD      0xda100000

                          AREA ||i.Chip_ACMP_EdgeClear||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_EdgeClear PROC
;;;61     /* Clears the ACMP interrupt (EDGECLR bit) */
;;;62     void Chip_ACMP_EdgeClear(LPC_CMP_T *pACMP)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64     	uint32_t reg = pACMP->CTRL & ~ACMP_CTRL_RESERVED;
000002  4b06              LDR      r3,|L2.28|
000004  401a              ANDS     r2,r2,r3
000006  4611              MOV      r1,r2
;;;65     
;;;66     	/* Toggle EDGECLR bit high and then low */
;;;67     	pACMP->CTRL = reg | ACMP_EDGECLR_BIT;
000008  2201              MOVS     r2,#1
00000a  0512              LSLS     r2,r2,#20
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;68     	pACMP->CTRL = reg & ~ACMP_EDGECLR_BIT;
000010  2301              MOVS     r3,#1
000012  051b              LSLS     r3,r3,#20
000014  460a              MOV      r2,r1
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
;;;69     }
00001a  4770              BX       lr
;;;70     
                          ENDP

                  |L2.28|
                          DCD      0x06b03f58

                          AREA ||i.Chip_ACMP_Init||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_Init PROC
;;;47     /* Initializes the ACMP */
;;;48     void Chip_ACMP_Init(LPC_CMP_T *pACMP)
000000  b510              PUSH     {r4,lr}
;;;49     {
000002  4604              MOV      r4,r0
;;;50     	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_ACMP_PD);
000004  2001              MOVS     r0,#1
000006  03c0              LSLS     r0,r0,#15
000008  f7fffffe          BL       Chip_SYSCTL_PowerUp
;;;51     	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_ACOMP);
00000c  2013              MOVS     r0,#0x13
00000e  2101              MOVS     r1,#1
000010  4081              LSLS     r1,r1,r0
000012  4a04              LDR      r2,|L3.36|
000014  6812              LDR      r2,[r2,#0]
000016  4b04              LDR      r3,|L3.40|
000018  401a              ANDS     r2,r2,r3
00001a  4311              ORRS     r1,r1,r2
00001c  4a01              LDR      r2,|L3.36|
00001e  6011              STR      r1,[r2,#0]
000020  bf00              NOP      
;;;52     }
000022  bd10              POP      {r4,pc}
;;;53     
                          ENDP

                  |L3.36|
                          DCD      0x40048080
                  |L3.40|
                          DCD      0x25efffff

                          AREA ||i.Chip_ACMP_SetEdgeSelection||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_SetEdgeSelection PROC
;;;71     /* Sets up ACMP edge selection */
;;;72     void Chip_ACMP_SetEdgeSelection(LPC_CMP_T *pACMP, ACMP_EDGESEL_T edgeSel)
000000  b510              PUSH     {r4,lr}
;;;73     {
;;;74     	uint32_t reg = pACMP->CTRL & ~(ACMP_EDGESEL_MASK | ACMP_CTRL_RESERVED);
000002  6803              LDR      r3,[r0,#0]
000004  4c03              LDR      r4,|L4.20|
000006  4023              ANDS     r3,r3,r4
000008  461a              MOV      r2,r3
;;;75     
;;;76     	/* Select edge for COMPEDGE */
;;;77     	pACMP->CTRL = reg | (uint32_t) edgeSel;
00000a  4613              MOV      r3,r2
00000c  430b              ORRS     r3,r3,r1
00000e  6003              STR      r3,[r0,#0]
;;;78     }
000010  bd10              POP      {r4,pc}
;;;79     
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x06b03f40

                          AREA ||i.Chip_ACMP_SetHysteresis||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_SetHysteresis PROC
;;;98     /* Selects hysteresis level */
;;;99     void Chip_ACMP_SetHysteresis(LPC_CMP_T *pACMP, ACMP_HYS_T hys)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101    	uint32_t reg = pACMP->CTRL & ~(ACMP_HYSTERESIS_MASK | ACMP_CTRL_RESERVED);
000002  6803              LDR      r3,[r0,#0]
000004  4c03              LDR      r4,|L5.20|
000006  4023              ANDS     r3,r3,r4
000008  461a              MOV      r2,r3
;;;102    
;;;103    	/* Select negative input */
;;;104    	pACMP->CTRL = reg | (uint32_t) hys;
00000a  4613              MOV      r3,r2
00000c  430b              ORRS     r3,r3,r1
00000e  6003              STR      r3,[r0,#0]
;;;105    }
000010  bd10              POP      {r4,pc}
;;;106    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x00b03f58

                          AREA ||i.Chip_ACMP_SetNegVoltRef||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_SetNegVoltRef PROC
;;;89     /* Selects negative voltage input */
;;;90     void Chip_ACMP_SetNegVoltRef(LPC_CMP_T *pACMP, ACMP_NEG_INPUT_T Neginput)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92     	uint32_t reg = pACMP->CTRL & ~(ACMP_COMPVMSEL_MASK | ACMP_CTRL_RESERVED);
000002  6803              LDR      r3,[r0,#0]
000004  4c03              LDR      r4,|L6.20|
000006  4023              ANDS     r3,r3,r4
000008  461a              MOV      r2,r3
;;;93     
;;;94     	/* Select negative input */
;;;95     	pACMP->CTRL = reg | (uint32_t) Neginput;
00000a  4613              MOV      r3,r2
00000c  430b              ORRS     r3,r3,r1
00000e  6003              STR      r3,[r0,#0]
;;;96     }
000010  bd10              POP      {r4,pc}
;;;97     
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x06b00758

                          AREA ||i.Chip_ACMP_SetPosVoltRef||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_SetPosVoltRef PROC
;;;80     /* Selects positive voltage input */
;;;81     void Chip_ACMP_SetPosVoltRef(LPC_CMP_T *pACMP, ACMP_POS_INPUT_T Posinput)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83     	uint32_t reg = pACMP->CTRL & ~(ACMP_COMPVPSEL_MASK | ACMP_CTRL_RESERVED);
000002  6803              LDR      r3,[r0,#0]
000004  4c03              LDR      r4,|L7.20|
000006  4023              ANDS     r3,r3,r4
000008  461a              MOV      r2,r3
;;;84     
;;;85     	/* Select positive input */
;;;86     	pACMP->CTRL = reg | (uint32_t) Posinput;
00000a  4613              MOV      r3,r2
00000c  430b              ORRS     r3,r3,r1
00000e  6003              STR      r3,[r0,#0]
;;;87     }
000010  bd10              POP      {r4,pc}
;;;88     
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x06b03858

                          AREA ||i.Chip_ACMP_SetupAMCPRefs||, CODE, READONLY, ALIGN=2

                  Chip_ACMP_SetupAMCPRefs PROC
;;;107    /* Helper function for setting up ACMP control */
;;;108    void Chip_ACMP_SetupAMCPRefs(LPC_CMP_T *pACMP, ACMP_EDGESEL_T edgeSel,
000000  b5f0              PUSH     {r4-r7,lr}
;;;109    							 ACMP_POS_INPUT_T Posinput, ACMP_NEG_INPUT_T Neginput,
;;;110    							 ACMP_HYS_T hys)
;;;111    {
000002  9c05              LDR      r4,[sp,#0x14]
;;;112    	uint32_t reg = pACMP->CTRL & ~(ACMP_HYSTERESIS_MASK | ACMP_CTRL_RESERVED |
000004  6806              LDR      r6,[r0,#0]
000006  4f05              LDR      r7,|L8.28|
000008  403e              ANDS     r6,r6,r7
00000a  4635              MOV      r5,r6
;;;113    								   ACMP_COMPVMSEL_MASK | ACMP_COMPVPSEL_MASK | ACMP_EDGESEL_MASK);
;;;114    
;;;115    	/* Select negative input */
;;;116    	pACMP->CTRL = reg | (uint32_t) edgeSel | (uint32_t) Posinput |
00000c  462e              MOV      r6,r5
00000e  430e              ORRS     r6,r6,r1
000010  4316              ORRS     r6,r6,r2
000012  431e              ORRS     r6,r6,r3
000014  4326              ORRS     r6,r6,r4
000016  6006              STR      r6,[r0,#0]
;;;117    				  (uint32_t) Neginput | (uint32_t) hys;
;;;118    }
000018  bdf0              POP      {r4-r7,pc}
;;;119    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x00b00040

                          AREA ||i.Chip_ACMP_SetupVoltLadder||, CODE, READONLY, ALIGN=1

                  Chip_ACMP_SetupVoltLadder PROC
;;;120    /* Sets up voltage ladder */
;;;121    void Chip_ACMP_SetupVoltLadder(LPC_CMP_T *pACMP, uint32_t ladsel, bool ladrefVDDCMP)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    	uint32_t reg = pACMP->LAD & ~(ACMP_LADSEL_MASK | ACMP_LADREF_MASK | ACMP_LAD_RESERVED);
000002  6844              LDR      r4,[r0,#4]
000004  07e3              LSLS     r3,r4,#31
000006  0fdb              LSRS     r3,r3,#31
;;;124    
;;;125    	/* Setup voltage ladder and ladder reference */
;;;126    	if (ladrefVDDCMP) {
000008  2a00              CMP      r2,#0
00000a  d001              BEQ      |L9.16|
;;;127    		reg |= ACMP_LADREF_MASK;
00000c  2440              MOVS     r4,#0x40
00000e  4323              ORRS     r3,r3,r4
                  |L9.16|
;;;128    	}
;;;129    	pACMP->LAD = reg | (ladsel << 1);
000010  004c              LSLS     r4,r1,#1
000012  431c              ORRS     r4,r4,r3
000014  6044              STR      r4,[r0,#4]
;;;130    }
000016  bd10              POP      {r4,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "lpc_chip_82x\\src\\acmp_8xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_acmp_8xx_c_01bd7939____REV16|
#line 465 ".\\_CMSIS\\v5.20\\Include\\cmsis_armcc.h"
|__asm___10_acmp_8xx_c_01bd7939____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_acmp_8xx_c_01bd7939____REVSH|
#line 480
|__asm___10_acmp_8xx_c_01bd7939____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
